{"version":3,"file":"ShareDirectoryClient.js","sourceRoot":"","sources":["../../src/ShareDirectoryClient.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { AbortSignalLike } from \"@azure/abort-controller\";\nimport {\n  DirectoryCreateResponse,\n  DirectoryDeleteResponse,\n  DirectoryGetPropertiesResponse,\n  DirectoryItem,\n  DirectoryListFilesAndDirectoriesSegmentResponse,\n  DirectoryListHandlesResponse,\n  DirectorySetMetadataResponse,\n  DirectorySetPropertiesResponse,\n  FileCreateResponse,\n  FileDeleteResponse,\n  FileItem,\n  HandleItem,\n  DirectoryForceCloseHandlesHeaders\n} from \"./generatedModels\";\nimport { Directory } from \"./generated/src/operations\";\nimport {\n  Metadata,\n  FileAndDirectoryCreateCommonOptions,\n  FileAndDirectorySetPropertiesCommonOptions,\n  validateAndSetDefaultsForFileAndDirectoryCreateCommonOptions,\n  fileAttributesToString,\n  fileCreationTimeToString,\n  fileLastWriteTimeToString,\n  validateAndSetDefaultsForFileAndDirectorySetPropertiesCommonOptions,\n  CloseHandlesInfo\n} from \"./models\";\nimport { newPipeline, StoragePipelineOptions, Pipeline } from \"./Pipeline\";\nimport { appendToURLPath, getShareNameAndPathFromUrl } from \"./utils/utils.common\";\nimport { StorageClient, CommonOptions } from \"./StorageClient\";\nimport \"@azure/core-paging\";\nimport { PageSettings, PagedAsyncIterableIterator } from \"@azure/core-paging\";\nimport { ShareFileClient, FileCreateOptions, FileDeleteOptions } from \"./ShareFileClient\";\nimport { Credential } from \"./credentials/Credential\";\nimport { AnonymousCredential } from \"./credentials/AnonymousCredential\";\nimport { FileSystemAttributes } from \"./FileSystemAttributes\";\nimport { createSpan } from \"./utils/tracing\";\nimport { CanonicalCode } from \"@opentelemetry/api\";\nimport { HttpResponse } from \"@azure/core-http\";\n\n/**\n * Options to configure {@link ShareDirectoryClient.create} operation.\n *\n * @export\n * @interface DirectoryCreateOptions\n */\nexport interface DirectoryCreateOptions extends FileAndDirectoryCreateCommonOptions, CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   *\n   * @type {AbortSignalLike}\n   * @memberof DirectoryCreateOptions\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * A collection of key-value string pair to associate with the file storage object.\n   *\n   * @type {Metadata}\n   * @memberof DirectoryCreateOptions\n   */\n  metadata?: Metadata;\n}\n\nexport interface DirectoryProperties\n  extends FileAndDirectorySetPropertiesCommonOptions,\n    CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   *\n   * @type {AbortSignalLike}\n   * @memberof DirectoryProperties\n   */\n  abortSignal?: AbortSignalLike;\n}\n\n/**\n * Options to configure Directory - List Files and Directories Segment operations.\n *\n * See:\n * - {@link ShareDirectoryClient.iterateFilesAndDirectoriesSegments}\n * - {@link ShareDirectoryClient.listFilesAndDirectoriesItems}\n * - {@link ShareDirectoryClient.listFilesAndDirectoriesSegment}\n *\n * @interface DirectoryListFilesAndDirectoriesSegmentOptions\n */\ninterface DirectoryListFilesAndDirectoriesSegmentOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   *\n   * @type {AbortSignalLike}\n   * @memberof DirectoryListFilesAndDirectoriesSegmentOptions\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * Filters the results to return only entries whose\n   * name begins with the specified prefix.\n   *\n   * @type {string}\n   * @memberof DirectoryListFilesAndDirectoriesSegmentOptions\n   */\n  prefix?: string;\n\n  /**\n   * Specifies the maximum number of entries to\n   * return. If the request does not specify maxResults, or specifies a value\n   * greater than 5,000, the server will return up to 5,000 items.\n   *\n   * @type {number}\n   * @memberof DirectoryListFilesAndDirectoriesSegmentOptions\n   */\n  maxResults?: number;\n}\n\n/**\n * Options to configure {@link ShareDirectoryClient.listFilesAndDirectories} operation.\n *\n * @export\n * @interface DirectoryListFilesAndDirectoriesOptions\n */\nexport interface DirectoryListFilesAndDirectoriesOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   *\n   * @type {AbortSignalLike}\n   * @memberof DirectoryListFilesAndDirectoriesOptions\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * Filters the results to return only entries whose\n   * name begins with the specified prefix.\n   *\n   * @type {string}\n   * @memberof DirectoryListFilesAndDirectoriesOptions\n   */\n  prefix?: string;\n}\n\n/**\n * Options to configure the {@link ShareDirectoryClient.delete} operation.\n *\n * @export\n * @interface DirectoryDeleteOptions\n */\nexport interface DirectoryDeleteOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   *\n   * @type {AbortSignalLike}\n   * @memberof DirectoryDeleteOptions\n   */\n  abortSignal?: AbortSignalLike;\n}\n\n/**\n * Options to configure the {@link ShareDirectoryClient.exists} operation.\n *\n * @export\n * @interface DirectoryExistsOptions\n */\nexport interface DirectoryExistsOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   *\n   * @type {AbortSignalLike}\n   * @memberof DirectoryExistsOptions\n   */\n  abortSignal?: AbortSignalLike;\n}\n\n/**\n * Options to configure the {@link ShareDirectoryClient.getProperties} operation.\n *\n * @export\n * @interface DirectoryGetPropertiesOptions\n */\nexport interface DirectoryGetPropertiesOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   *\n   * @type {AbortSignalLike}\n   * @memberof DirectoryGetPropertiesOptions\n   */\n  abortSignal?: AbortSignalLike;\n}\n\n/**\n * Options to configure the {@link ShareDirectoryClient.setMetadata} operation.\n *\n * @export\n * @interface DirectorySetMetadataOptions\n */\nexport interface DirectorySetMetadataOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   *\n   * @type {AbortSignalLike}\n   * @memberof DirectorySetMetadataOptions\n   */\n  abortSignal?: AbortSignalLike;\n}\n\n/**\n * Options to configure Directory - List Handles Segment operations.\n *\n * See:\n * - {@link ShareDirectoryClient.listHandlesSegment}\n * - {@link ShareDirectoryClient.iterateHandleSegments}\n * - {@link ShareDirectoryClient.listHandleItems}\n *\n *\n * @export\n * @interface DirectoryListHandlesSegmentOptions\n */\nexport interface DirectoryListHandlesSegmentOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   *\n   * @type {AbortSignalLike}\n   * @memberof DirectoryListHandlesSegmentOptions\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * Specifies the maximum number of entries to return. If the request does not specify maxResults,\n   * or specifies a value greater than 5,000, the server will return up to 5,000 items.\n   *\n   * @type {number}\n   * @memberof DirectoryListHandlesSegmentOptions\n   */\n  maxResults?: number;\n  /**\n   * Specifies operation should apply to the directory specified in the URI, its files, its\n   * subdirectories and their files.\n   *\n   * @type {boolean}\n   * @memberof DirectoryListHandlesSegmentOptions\n   */\n  recursive?: boolean;\n}\n\n/**\n * Options to configure the {@link ShareDirectoryClient.listHandles} operation.\n *\n * @export\n * @interface DirectoryListHandlesOptions\n */\nexport interface DirectoryListHandlesOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   *\n   * @type {AbortSignalLike}\n   * @memberof DirectoryListHandlesOptions\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * Specifies whether operation should apply to the directory specified in the URI, its files, its\n   * subdirectories and their files.\n   *\n   * @type {boolean}\n   * @memberof DirectoryListHandlesOptions\n   */\n  recursive?: boolean;\n}\n\n/**\n * Options to configure Directory - Force Close Handles Segment operations.\n *\n * See:\n * - {@link ShareDirectoryClient.forceCloseHandlesSegment}\n * - {@link ShareDirectoryClient.forceCloseAllHandles}\n *\n * @export\n * @interface DirectoryForceCloseHandlesSegmentOptions\n */\nexport interface DirectoryForceCloseHandlesSegmentOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   *\n   * @type {AbortSignalLike}\n   * @memberof DirectoryForceCloseHandlesSegmentOptions\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * Specifies operation should apply to the directory specified in the URI, its files, its\n   * subdirectories and their files.\n   *\n   * @type {boolean}\n   * @memberof DirectoryForceCloseHandlesSegmentOptions\n   */\n  recursive?: boolean;\n}\n\n/**\n * Additional response header values for close handles request.\n */\nexport interface DirectoryCloseHandlesHeaders {\n  /**\n   * This header uniquely identifies the request that was made and can be used for troubleshooting\n   * the request.\n   */\n  requestId?: string;\n  /**\n   * Indicates the version of the File service used to execute the request.\n   */\n  version?: string;\n  /**\n   * A UTC date/time value generated by the service that indicates the time at which the response\n   * was initiated.\n   */\n  date?: Date;\n  /**\n   * A string describing next handle to be closed. It is returned when more handles need to be\n   * closed to complete the request.\n   */\n  marker?: string;\n}\n\n/**\n * Response type for {@link ShareDirectoryClient.forceCloseHandle}.\n */\nexport type DirectoryForceCloseHandlesResponse = CloseHandlesInfo &\n  DirectoryCloseHandlesHeaders & {\n    /**\n     * The underlying HTTP response.\n     */\n    _response: HttpResponse & {\n      /**\n       * The parsed HTTP response headers.\n       */\n      parsedHeaders: DirectoryForceCloseHandlesHeaders;\n    };\n  };\n\n/**\n * Options to configure {@link ShareDirectoryClient.forceCloseHandle}.\n *\n * @export\n * @interface DirectoryForceCloseHandlesOptions\n */\nexport interface DirectoryForceCloseHandlesOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   *\n   * @type {AbortSignalLike}\n   * @memberof DirectoryForceCloseHandlesOptions\n   */\n  abortSignal?: AbortSignalLike;\n}\n\n/**\n * Contains response data for the {@link DirectoryClient.createIfNotExists} operation.\n *\n * @export\n * @interface DirectoryCreateIfNotExistsResponse\n */\nexport interface DirectoryCreateIfNotExistsResponse extends DirectoryCreateResponse {\n  /**\n   * Indicate whether the directory is successfully created. Is false when the directory is not changed as it already exists.\n   *\n   * @type {boolean}\n   * @memberof DirectoryCreateIfNotExistsResponse\n   */\n  succeeded: boolean;\n}\n\n/**\n * Contains response data for the {@link DirectoryClient.deleteIfExists} operation.\n *\n * @export\n * @interface DirectoryDeleteIfExistsResponse\n */\nexport interface DirectoryDeleteIfExistsResponse extends DirectoryDeleteResponse {\n  /**\n   * Indicate whether the directory is successfully deleted. Is false if the directory does not exist in the first place.\n   *\n   * @type {boolean}\n   * @memberof DirectoryDeleteIfExistsResponse\n   */\n  succeeded: boolean;\n}\n\n/**\n * A ShareDirectoryClient represents a URL to the Azure Storage directory allowing you to manipulate its files and directories.\n *\n * @export\n * @class ShareDirectoryClient\n */\nexport class ShareDirectoryClient extends StorageClient {\n  /**\n   * context provided by protocol layer.\n   *\n   * @private\n   * @type {Directory}\n   * @memberof ShareDirectoryClient\n   */\n  private context: Directory;\n\n  private _shareName: string;\n  private _path: string;\n  private _name: string;\n\n  /**\n   * The share name corresponding to this directory client\n   *\n   * @type {string}\n   * @memberof ShareDirectoryClient\n   */\n  public get shareName(): string {\n    return this._shareName;\n  }\n\n  /**\n   * The full path of the directory\n   *\n   * @type {string}\n   * @memberof ShareDirectoryClient\n   */\n  public get path(): string {\n    return this._path;\n  }\n\n  /**\n   * The name of the directory\n   *\n   * @type {string}\n   * @memberof ShareDirectoryClient\n   */\n  public get name(): string {\n    return this._name;\n  }\n\n  /**\n   * Creates an instance of DirectoryClient.\n   *\n   * @param {string} url A URL string pointing to Azure Storage file directory, such as\n   *                     \"https://myaccount.file.core.windows.net/myshare/mydirectory\". You can\n   *                     append a SAS if using AnonymousCredential, such as\n   *                     \"https://myaccount.file.core.windows.net/myshare/mydirectory?sasString\".\n   *                     This method accepts an encoded URL or non-encoded URL pointing to a directory.\n   *                     Encoded URL string will NOT be escaped twice, only special characters in URL path will be escaped.\n   *                     However, if a directory name includes %, directory name must be encoded in the URL.\n   *                     Such as a directory named \"mydir%\", the URL should be \"https://myaccount.file.core.windows.net/myshare/mydir%25\".\n   * @param {Credential} [credential] Such as AnonymousCredential or StorageSharedKeyCredential.\n   *                                  If not specified, AnonymousCredential is used.\n   * @param {StoragePipelineOptions} [options] Optional. Options to configure the HTTP pipeline.\n   * @memberof ShareDirectoryClient\n   */\n  constructor(url: string, credential?: Credential, options?: StoragePipelineOptions);\n  /**\n   * Creates an instance of DirectoryClient.\n   *\n   * @param {string} url A URL string pointing to Azure Storage file directory, such as\n   *                     \"https://myaccount.file.core.windows.net/myshare/mydirectory\". You can\n   *                     append a SAS if using AnonymousCredential, such as\n   *                     \"https://myaccount.file.core.windows.net/myshare/mydirectory?sasString\".\n   *                     This method accepts an encoded URL or non-encoded URL pointing to a directory.\n   *                     Encoded URL string will NOT be escaped twice, only special characters in URL path will be escaped.\n   *                     However, if a directory name includes %, directory name must be encoded in the URL.\n   *                     Such as a directory named \"mydir%\", the URL should be \"https://myaccount.file.core.windows.net/myshare/mydir%25\".\n   * @param {Pipeline} pipeline Call newPipeline() to create a default\n   *                            pipeline, or provide a customized pipeline.\n   * @memberof ShareDirectoryClient\n   */\n  constructor(url: string, pipeline: Pipeline);\n  constructor(\n    url: string,\n    credentialOrPipeline?: Credential | Pipeline,\n    options: StoragePipelineOptions = {}\n  ) {\n    let pipeline: Pipeline;\n    if (credentialOrPipeline instanceof Pipeline) {\n      pipeline = credentialOrPipeline;\n    } else if (credentialOrPipeline instanceof Credential) {\n      pipeline = newPipeline(credentialOrPipeline, options);\n    } else {\n      // The second parameter is undefined. Use anonymous credential.\n      pipeline = newPipeline(new AnonymousCredential(), options);\n    }\n\n    super(url, pipeline);\n    ({\n      baseName: this._name,\n      shareName: this._shareName,\n      path: this._path\n    } = getShareNameAndPathFromUrl(this.url));\n    this.context = new Directory(this.storageClientContext);\n  }\n\n  /**\n   * Creates a new directory under the specified share or parent directory.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-directory\n   *\n   * @param {DirectoryCreateOptions} [options] Options to Directory Create operation.\n   * @returns {Promise<DirectoryCreateResponse>} Response data for the Directory  operation.\n   * @memberof ShareDirectoryClient\n   */\n  public async create(options: DirectoryCreateOptions = {}): Promise<DirectoryCreateResponse> {\n    const { span, spanOptions } = createSpan(\"ShareDirectoryClient-create\", options.tracingOptions);\n    try {\n      if (!options.fileAttributes) {\n        options = validateAndSetDefaultsForFileAndDirectoryCreateCommonOptions(options);\n        // By default set it as a directory.\n        const attributes: FileSystemAttributes = new FileSystemAttributes();\n        attributes.directory = true;\n        options.fileAttributes = attributes;\n      }\n\n      return await this.context.create(\n        fileAttributesToString(options.fileAttributes!),\n        fileCreationTimeToString(options.creationTime!),\n        fileLastWriteTimeToString(options.lastWriteTime!),\n        {\n          abortSignal: options.abortSignal,\n          metadata: options.metadata,\n          filePermission: options.filePermission,\n          filePermissionKey: options.filePermissionKey,\n          spanOptions\n        }\n      );\n    } catch (e) {\n      span.setStatus({\n        code: CanonicalCode.UNKNOWN,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Creates a new directory under the specified share or parent directory if it does not already exists.\n   * If the directory already exists, it is not modified.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-directory\n   *\n   * @param {DirectoryCreateOptions} [options]\n   * @returns {Promise<DirectoryCreateIfNotExistsResponse>}\n   * @memberof ShareDirectoryClient\n   */\n  public async createIfNotExists(\n    options: DirectoryCreateOptions = {}\n  ): Promise<DirectoryCreateIfNotExistsResponse> {\n    const { span, spanOptions } = createSpan(\n      \"ShareDirectoryClient-createIfNotExists\",\n      options.tracingOptions\n    );\n    try {\n      const res = await this.create({\n        ...options,\n        tracingOptions: { ...options!.tracingOptions, spanOptions }\n      });\n      return {\n        succeeded: true,\n        ...res\n      };\n    } catch (e) {\n      if (e.details?.errorCode === \"ResourceAlreadyExists\") {\n        span.setStatus({\n          code: CanonicalCode.ALREADY_EXISTS,\n          message: \"Expected exception when creating a directory only if it does not already exist.\"\n        });\n        return {\n          succeeded: false,\n          ...e.response?.parsedHeaders,\n          _response: e.response\n        };\n      }\n      span.setStatus({\n        code: CanonicalCode.UNKNOWN,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Sets properties on the directory.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-directory-properties\n   *\n   * @param {properties} [DirectoryProperties] Directory properties. If no values are provided,\n   *                                            existing values will be preserved.\n   * @returns {Promise<DirectorySetPropertiesResponse>}\n   * @memberof ShareDirectoryClient\n   */\n  public async setProperties(\n    properties: DirectoryProperties = {}\n  ): Promise<DirectorySetPropertiesResponse> {\n    const { span, spanOptions } = createSpan(\n      \"ShareDirectoryClient-setProperties\",\n      properties.tracingOptions\n    );\n    try {\n      properties = validateAndSetDefaultsForFileAndDirectorySetPropertiesCommonOptions(properties);\n\n      return await this.context.setProperties(\n        fileAttributesToString(properties.fileAttributes!),\n        fileCreationTimeToString(properties.creationTime!),\n        fileLastWriteTimeToString(properties.lastWriteTime!),\n        {\n          abortSignal: properties.abortSignal,\n          filePermission: properties.filePermission,\n          filePermissionKey: properties.filePermissionKey,\n          spanOptions\n        }\n      );\n    } catch (e) {\n      span.setStatus({\n        code: CanonicalCode.UNKNOWN,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Creates a ShareDirectoryClient object for a sub directory.\n   *\n   * @param subDirectoryName A subdirectory name\n   * @returns {ShareDirectoryClient} The ShareDirectoryClient object for the given subdirectory name.\n   * @memberof ShareDirectoryClient\n   *\n   * Example usage:\n   *\n   * ```js\n   * const directoryClient = shareClient.getDirectoryClient(\"<directory name>\");\n   * await directoryClient.create();\n   * console.log(\"Created directory successfully\");\n   * ```\n   */\n  public getDirectoryClient(subDirectoryName: string): ShareDirectoryClient {\n    return new ShareDirectoryClient(\n      appendToURLPath(this.url, encodeURIComponent(subDirectoryName)),\n      this.pipeline\n    );\n  }\n\n  /**\n   * Creates a new subdirectory under this directory.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-directory\n   *\n   * @param {string} directoryName\n   * @param {DirectoryCreateOptions} [options] Options to Directory Create operation.\n   * @returns {Promise<{ directoryClient: ShareDirectoryClient; directoryCreateResponse: DirectoryCreateResponse; }>} Directory create response data and the corresponding DirectoryClient instance.\n   * @memberof ShareDirectoryClient\n   */\n  public async createSubdirectory(\n    directoryName: string,\n    options: DirectoryCreateOptions = {}\n  ): Promise<{\n    directoryClient: ShareDirectoryClient;\n    directoryCreateResponse: DirectoryCreateResponse;\n  }> {\n    const { span, spanOptions } = createSpan(\n      \"ShareDirectoryClient-createSubdirectory\",\n      options.tracingOptions\n    );\n    try {\n      const directoryClient = this.getDirectoryClient(directoryName);\n      const directoryCreateResponse = await directoryClient.create({\n        ...options,\n        tracingOptions: { ...options!.tracingOptions, spanOptions }\n      });\n      return {\n        directoryClient,\n        directoryCreateResponse\n      };\n    } catch (e) {\n      span.setStatus({\n        code: CanonicalCode.UNKNOWN,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Removes the specified empty sub directory under this directory.\n   * Note that the directory must be empty before it can be deleted.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-directory\n   *\n   * @param {string} directoryName\n   * @param {DirectoryDeleteOptions} [options] Options to Directory Delete operation.\n   * @returns {DirectoryDeleteResponse} Directory deletion response data.\n   * @memberof ShareDirectoryClient\n   */\n  public async deleteSubdirectory(\n    directoryName: string,\n    options: DirectoryDeleteOptions = {}\n  ): Promise<DirectoryDeleteResponse> {\n    const { span, spanOptions } = createSpan(\n      \"ShareDirectoryClient-deleteSubdirectory\",\n      options.tracingOptions\n    );\n    try {\n      const directoryClient = this.getDirectoryClient(directoryName);\n      return await directoryClient.delete({\n        ...options,\n        tracingOptions: { ...options!.tracingOptions, spanOptions }\n      });\n    } catch (e) {\n      span.setStatus({\n        code: CanonicalCode.UNKNOWN,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Creates a new file or replaces a file under this directory. Note it only initializes the file with no content.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-file\n   *\n   * @param {string} fileName\n   * @param {number} size Specifies the maximum size in bytes for the file, up to 1 TB.\n   * @param {FileCreateOptions} [options] Options to File Create operation.\n   * @returns {Promise<{ fileClient: ShareFileClient, fileCreateResponse: FileCreateResponse }>} File creation response data and the corresponding file client.\n   * @memberof ShareDirectoryClient\n   */\n  public async createFile(\n    fileName: string,\n    size: number,\n    options: FileCreateOptions = {}\n  ): Promise<{ fileClient: ShareFileClient; fileCreateResponse: FileCreateResponse }> {\n    const { span, spanOptions } = createSpan(\n      \"ShareDirectoryClient-createFile\",\n      options.tracingOptions\n    );\n    try {\n      const fileClient = this.getFileClient(fileName);\n      const fileCreateResponse = await fileClient.create(size, {\n        ...options,\n        tracingOptions: { ...options!.tracingOptions, spanOptions }\n      });\n      return {\n        fileClient,\n        fileCreateResponse\n      };\n    } catch (e) {\n      span.setStatus({\n        code: CanonicalCode.UNKNOWN,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Removes the specified file under this directory from the storage account.\n   * When a file is successfully deleted, it is immediately removed from the storage\n   * account's index and is no longer accessible to clients. The file's data is later\n   * removed from the service during garbage collection.\n   *\n   * Delete File will fail with status code 409 (Conflict) and error code SharingViolation\n   * if the file is open on an SMB client.\n   *\n   * Delete File is not supported on a share snapshot, which is a read-only copy of\n   * a share. An attempt to perform this operation on a share snapshot will fail with 400 (InvalidQueryParameterValue)\n   *\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-file2\n   *\n   * @param {string} fileName Name of the file to delete\n   * @param {FileDeleteOptions} [options] Options to File Delete operation.\n   * @returns {Promise<FileDeleteResponse>} File deletion response data.\n   * @memberof ShareDirectoryClient\n   */\n  public async deleteFile(\n    fileName: string,\n    options: FileDeleteOptions = {}\n  ): Promise<FileDeleteResponse> {\n    const { span, spanOptions } = createSpan(\n      \"ShareDirectoryClient-deleteFile\",\n      options.tracingOptions\n    );\n    try {\n      const fileClient = this.getFileClient(fileName);\n      return await fileClient.delete({\n        ...options,\n        tracingOptions: { ...options!.tracingOptions, spanOptions }\n      });\n    } catch (e) {\n      span.setStatus({\n        code: CanonicalCode.UNKNOWN,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Creates a {@link ShareFileClient} object.\n   *\n   * @param {string} fileName A file name.\n   * @returns {ShareFileClient} A new ShareFileClient object for the given file name.\n   * @memberof ShareFileClient\n   *\n   * Example usage:\n   *\n   * ```js\n   * const content = \"Hello world!\"\n   *\n   * const fileClient = directoryClient.getFileClient(\"<file name>\");\n   *\n   * await fileClient.create(content.length);\n   * console.log(\"Created file successfully!\");\n   *\n   * await fileClient.uploadRange(content, 0, content.length);\n   * console.log(\"Updated file successfully!\")\n   * ```\n   */\n  public getFileClient(fileName: string): ShareFileClient {\n    return new ShareFileClient(\n      appendToURLPath(this.url, encodeURIComponent(fileName)),\n      this.pipeline\n    );\n  }\n\n  /**\n   * Returns true if the specified directory exists; false otherwise.\n   *\n   * NOTE: use this function with care since an existing directory might be deleted by other clients or\n   * applications. Vice versa new directories might be added by other clients or applications after this\n   * function completes.\n   *\n   * @param {DirectoryExistsOptions} [options] options to Exists operation.\n   * @returns {Promise<boolean>}\n   * @memberof ShareDirectoryClient\n   */\n  public async exists(options: DirectoryExistsOptions = {}): Promise<boolean> {\n    const { span, spanOptions } = createSpan(\"ShareDirectoryClient-exists\", options.tracingOptions);\n    try {\n      await this.getProperties({\n        abortSignal: options.abortSignal,\n        tracingOptions: {\n          ...options.tracingOptions,\n          spanOptions\n        }\n      });\n      return true;\n    } catch (e) {\n      if (e.statusCode === 404) {\n        span.setStatus({\n          code: CanonicalCode.NOT_FOUND,\n          message: \"Expected exception when checking directory existence\"\n        });\n        return false;\n      }\n      span.setStatus({\n        code: CanonicalCode.UNKNOWN,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Returns all system properties for the specified directory, and can also be used to check the\n   * existence of a directory. The data returned does not include the files in the directory or any\n   * subdirectories.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-directory-properties\n   *\n   * @param {DirectoryGetPropertiesOptions} [options] Options to Directory Get Properties operation.\n   * @returns {Promise<DirectoryGetPropertiesResponse>} Response data for the Directory Get Properties operation.\n   * @memberof ShareDirectoryClient\n   */\n  public async getProperties(\n    options: DirectoryGetPropertiesOptions = {}\n  ): Promise<DirectoryGetPropertiesResponse> {\n    const { span, spanOptions } = createSpan(\n      \"ShareDirectoryClient-getProperties\",\n      options.tracingOptions\n    );\n    try {\n      return await this.context.getProperties({\n        abortSignal: options.abortSignal,\n        spanOptions\n      });\n    } catch (e) {\n      span.setStatus({\n        code: CanonicalCode.UNKNOWN,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Removes the specified empty directory. Note that the directory must be empty before it can be\n   * deleted.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-directory\n   *\n   * @param {DirectoryDeleteOptions} [options] Options to Directory Delete operation.\n   * @returns {Promise<DirectoryDeleteResponse>} Response data for the Directory Delete operation.\n   * @memberof ShareDirectoryClient\n   */\n  public async delete(options: DirectoryDeleteOptions = {}): Promise<DirectoryDeleteResponse> {\n    const { span, spanOptions } = createSpan(\"ShareDirectoryClient-delete\", options.tracingOptions);\n    try {\n      return await this.context.deleteMethod({\n        abortSignal: options.abortSignal,\n        spanOptions\n      });\n    } catch (e) {\n      span.setStatus({\n        code: CanonicalCode.UNKNOWN,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Removes the specified empty directory if it exists. Note that the directory must be empty before it can be\n   * deleted.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-directory\n   *\n   * @param {DirectoryDeleteOptions} [options]\n   * @returns {Promise<DirectoryDeleteIfExistsResponse>}\n   * @memberof ShareDirectoryClient\n   */\n  public async deleteIfExists(\n    options: DirectoryDeleteOptions = {}\n  ): Promise<DirectoryDeleteIfExistsResponse> {\n    const { span, spanOptions } = createSpan(\n      \"ShareDirectoryClient-deleteIfExists\",\n      options.tracingOptions\n    );\n    try {\n      const res = await this.delete({\n        ...options,\n        tracingOptions: { ...options!.tracingOptions, spanOptions }\n      });\n      return {\n        succeeded: true,\n        ...res\n      };\n    } catch (e) {\n      if (e.details?.errorCode === \"ResourceNotFound\") {\n        span.setStatus({\n          code: CanonicalCode.NOT_FOUND,\n          message: \"Expected exception when deleting a directory only if it exists.\"\n        });\n        return {\n          succeeded: false,\n          ...e.response?.parsedHeaders,\n          _response: e.response\n        };\n      }\n      span.setStatus({\n        code: CanonicalCode.UNKNOWN,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Updates user defined metadata for the specified directory.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-directory-metadata\n   *\n   * @param {Metadata} [metadata] If no metadata provided, all existing directory metadata will be removed\n   * @param {DirectorySetMetadataOptions} [options] Options to Directory Set Metadata operation.\n   * @returns {Promise<DirectorySetMetadataResponse>} Response data for the Directory Set Metadata operation.\n   * @memberof ShareDirectoryClient\n   */\n  public async setMetadata(\n    metadata?: Metadata,\n    options: DirectorySetMetadataOptions = {}\n  ): Promise<DirectorySetMetadataResponse> {\n    const { span, spanOptions } = createSpan(\n      \"ShareDirectoryClient-setMetadata\",\n      options.tracingOptions\n    );\n    try {\n      return await this.context.setMetadata({\n        abortSignal: options.abortSignal,\n        metadata,\n        spanOptions\n      });\n    } catch (e) {\n      span.setStatus({\n        code: CanonicalCode.UNKNOWN,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Returns an AsyncIterableIterator for {@link DirectoryListFilesAndDirectoriesSegmentResponse} objects\n   *\n   * @private\n   * @param {string} [marker] A string value that identifies the portion of\n   *                          the list of files and directories to be returned with the next listing operation. The\n   *                          operation returns the ContinuationToken value within the response body if the\n   *                          listing operation did not return all files and directories remaining to be listed\n   *                          with the current page. The ContinuationToken value can be used as the value for\n   *                          the marker parameter in a subsequent call to request the next page of list\n   *                          items. The marker value is opaque to the client.\n   * @param {DirectoryListFilesAndDirectoriesSegmentOptions} [options] Options to list files and directories operation.\n   * @returns {AsyncIterableIterator<DirectoryListFilesAndDirectoriesSegmentResponse>}\n   * @memberof ShareDirectoryClient\n   */\n  private async *iterateFilesAndDirectoriesSegments(\n    marker?: string,\n    options: DirectoryListFilesAndDirectoriesSegmentOptions = {}\n  ): AsyncIterableIterator<DirectoryListFilesAndDirectoriesSegmentResponse> {\n    if (options.prefix === \"\") {\n      options.prefix = undefined;\n    }\n\n    let listFilesAndDirectoriesResponse;\n    do {\n      listFilesAndDirectoriesResponse = await this.listFilesAndDirectoriesSegment(marker, options);\n      marker = listFilesAndDirectoriesResponse.continuationToken;\n      yield await listFilesAndDirectoriesResponse;\n    } while (marker);\n  }\n\n  /**\n   * Returns an AsyncIterableIterator for file and directory items\n   *\n   * @private\n   * @param {DirectoryListFilesAndDirectoriesSegmentOptions} [options] Options to list files and directories operation.\n   * @returns {AsyncIterableIterator<{ kind: \"file\" } & FileItem | { kind: \"directory\" } & DirectoryItem>}\n   * @memberof ShareDirectoryClient\n   */\n  private async *listFilesAndDirectoriesItems(\n    options: DirectoryListFilesAndDirectoriesSegmentOptions = {}\n  ): AsyncIterableIterator<\n    ({ kind: \"file\" } & FileItem) | ({ kind: \"directory\" } & DirectoryItem)\n  > {\n    if (options.prefix === \"\") {\n      options.prefix = undefined;\n    }\n\n    let marker: string | undefined;\n    for await (const listFilesAndDirectoriesResponse of this.iterateFilesAndDirectoriesSegments(\n      marker,\n      options\n    )) {\n      for (const file of listFilesAndDirectoriesResponse.segment.fileItems) {\n        yield { kind: \"file\", ...file };\n      }\n      for (const directory of listFilesAndDirectoriesResponse.segment.directoryItems) {\n        yield { kind: \"directory\", ...directory };\n      }\n    }\n  }\n\n  /**\n   * Returns an async iterable iterator to list all the files and directories\n   * under the specified account.\n   *\n   * .byPage() returns an async iterable iterator to list the files and directories in pages.\n   *\n   * Example using `for await` syntax:\n   *\n   * ```js\n   * let i = 1;\n   * for await (const entity of directoryClient.listFilesAndDirectories()) {\n   *   if (entity.kind === \"directory\") {\n   *     console.log(`${i++} - directory\\t: ${entity.name}`);\n   *   } else {\n   *     console.log(`${i++} - file\\t: ${entity.name}`);\n   *   }\n   * }\n   * ```\n   *\n   * Example using `iter.next()`:\n   *\n   * ```js\n   * let i = 1;\n   * let iter = directoryClient.listFilesAndDirectories();\n   * let entity = await iter.next();\n   * while (!entity.done) {\n   *   if (entity.value.kind === \"directory\") {\n   *     console.log(`${i++} - directory\\t: ${entity.value.name}`);\n   *   } else {\n   *     console.log(`${i++} - file\\t: ${entity.value.name}`);\n   *   }\n   *   entity = await iter.next();\n   * }\n   * ```\n   *\n   * Example using `byPage()`:\n   *\n   * ```js\n   * // passing optional maxPageSize in the page settings\n   * let i = 1;\n   * for await (const response of directoryClient\n   *   .listFilesAndDirectories()\n   *   .byPage({ maxPageSize: 20 })) {\n   *   for (const fileItem of response.segment.fileItems) {\n   *     console.log(`${i++} - file\\t: ${fileItem.name}`);\n   *   }\n   *   for (const dirItem of response.segment.directoryItems) {\n   *     console.log(`${i++} - directory\\t: ${dirItem.name}`);\n   *   }\n   * }\n   * ```\n   *\n   * Example using paging with a marker:\n   *\n   * ```js\n   * let i = 1;\n   * let iterator = directoryClient.listFilesAndDirectories().byPage({ maxPageSize: 3 });\n   * let response = (await iterator.next()).value;\n   *\n   * // Prints 3 file and directory names\n   * for (const fileItem of response.segment.fileItems) {\n   *   console.log(`${i++} - file\\t: ${fileItem.name}`);\n   * }\n   *\n   * for (const dirItem of response.segment.directoryItems) {\n   *   console.log(`${i++} - directory\\t: ${dirItem.name}`);\n   * }\n   *\n   * // Gets next marker\n   * let dirMarker = response.continuationToken;\n   *\n   * // Passing next marker as continuationToken\n   * iterator = directoryClient\n   *   .listFilesAndDirectories()\n   *   .byPage({ continuationToken: dirMarker, maxPageSize: 4 });\n   * response = (await iterator.next()).value;\n   *\n   * // Prints 10 file and directory names\n   * for (const fileItem of response.segment.fileItems) {\n   *   console.log(`${i++} - file\\t: ${fileItem.name}`);\n   * }\n   *\n   * for (const dirItem of response.segment.directoryItems) {\n   *   console.log(`${i++} - directory\\t: ${dirItem.name}`);\n   * }\n   * ```\n   *\n   * @param {DirectoryListFilesAndDirectoriesOptions} [options] Options to list files and directories operation.\n   * @memberof ShareDirectoryClient\n   * @returns {PagedAsyncIterableIterator<{ kind: \"file\" } & FileItem | { kind: \"directory\" } , DirectoryListFilesAndDirectoriesSegmentResponse>}\n   * An asyncIterableIterator that supports paging.\n   */\n  public listFilesAndDirectories(\n    options: DirectoryListFilesAndDirectoriesOptions = {}\n  ): PagedAsyncIterableIterator<\n    ({ kind: \"file\" } & FileItem) | ({ kind: \"directory\" } & DirectoryItem),\n    DirectoryListFilesAndDirectoriesSegmentResponse\n  > {\n    if (options.prefix === \"\") {\n      options.prefix = undefined;\n    }\n\n    // AsyncIterableIterator to iterate over files and directories\n    const iter = this.listFilesAndDirectoriesItems(options);\n    return {\n      /**\n       * @member {Promise} [next] The next method, part of the iteration protocol\n       */\n      async next() {\n        return iter.next();\n      },\n      /**\n       * @member {Symbol} [asyncIterator] The connection to the async iterator, part of the iteration protocol\n       */\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n      /**\n       * @member {Function} [byPage] Return an AsyncIterableIterator that works a page at a time\n       */\n      byPage: (settings: PageSettings = {}) => {\n        return this.iterateFilesAndDirectoriesSegments(settings.continuationToken, {\n          maxResults: settings.maxPageSize,\n          ...options\n        });\n      }\n    };\n  }\n\n  /**\n   * Returns a list of files or directories under the specified share or directory. It lists the\n   * contents only for a single level of the directory hierarchy.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/list-directories-and-files\n   *\n   * @param {string} [marker] A string value that identifies the portion of the list to be returned with the next list operation.\n   * @param {DirectoryListFilesAndDirectoriesSegmentOptions} [options] Options to Directory List Files and Directories Segment operation.\n   * @returns {Promise<DirectoryListFilesAndDirectoriesSegmentResponse>} Response data for the Directory List Files and Directories operation.\n   * @memberof ShareDirectoryClient\n   */\n  private async listFilesAndDirectoriesSegment(\n    marker?: string,\n    options: DirectoryListFilesAndDirectoriesSegmentOptions = {}\n  ): Promise<DirectoryListFilesAndDirectoriesSegmentResponse> {\n    const { span, spanOptions } = createSpan(\n      \"ShareDirectoryClient-listFilesAndDirectoriesSegment\",\n      options.tracingOptions\n    );\n\n    if (options.prefix === \"\") {\n      options.prefix = undefined;\n    }\n\n    try {\n      return await this.context.listFilesAndDirectoriesSegment({\n        marker,\n        ...options,\n        spanOptions\n      });\n    } catch (e) {\n      span.setStatus({\n        code: CanonicalCode.UNKNOWN,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Returns an AsyncIterableIterator for {@link DirectoryListHandlesResponse}\n   *\n   * @private\n   * @param {string} [marker] A string value that identifies the portion of the list to be\n   *                          returned with the next list handles operation. The operation returns a\n   *                          marker value within the response body if the list returned was not complete.\n   *                          The marker value may then be used in a subsequent call to request the next\n   *                          set of list items.\n   * @param {DirectoryListHandlesSegmentOptions} [options] Options to list handles operation.\n   * @returns {AsyncIterableIterator<DirectoryListHandlesResponse>}\n   * @memberof ShareDirectoryClient\n   */\n  private async *iterateHandleSegments(\n    marker?: string,\n    options: DirectoryListHandlesSegmentOptions = {}\n  ): AsyncIterableIterator<DirectoryListHandlesResponse> {\n    let listHandlesResponse;\n    if (!!marker || marker === undefined) {\n      do {\n        listHandlesResponse = await this.listHandlesSegment(marker, options);\n        marker = listHandlesResponse.continuationToken;\n        yield await listHandlesResponse;\n      } while (marker);\n    }\n  }\n\n  /**\n   * Returns an AsyncIterableIterator for handles\n   *\n   * @private\n   * @param {DirectoryListHandlesSegmentOptions} [options] Options to list handles operation.\n   * @returns {AsyncIterableIterator<HandleItem>}\n   * @memberof ShareDirectoryClient\n   */\n  private async *listHandleItems(\n    options: DirectoryListHandlesSegmentOptions = {}\n  ): AsyncIterableIterator<HandleItem> {\n    let marker: string | undefined;\n    for await (const listHandlesResponse of this.iterateHandleSegments(marker, options)) {\n      if (listHandlesResponse.handleList) {\n        for (const handle of listHandlesResponse.handleList) {\n          yield handle;\n        }\n      }\n    }\n  }\n\n  /**\n   * Returns an async iterable iterator to list all the handles.\n   * under the specified account.\n   *\n   * .byPage() returns an async iterable iterator to list the handles in pages.\n   *\n   * Example using `for await` syntax:\n   *\n   * ```js\n   * let i = 1;\n   * let iter = dirClient.listHandles();\n   * for await (const handle of iter) {\n   *   console.log(`Handle ${i++}: ${handle.path}, opened time ${handle.openTime}, clientIp ${handle.clientIp}`);\n   * }\n   * ```\n   *\n   * Example using `iter.next()`:\n   *\n   * ```js\n   * let i = 1;\n   * let iter = dirClient.listHandles();\n   * let handleItem = await iter.next();\n   * while (!handleItem.done) {\n   *   console.log(`Handle ${i++}: ${handleItem.value.path}, opened time ${handleItem.value.openTime}, clientIp ${handleItem.value.clientIp}`);\n   *   handleItem = await iter.next();\n   * }\n   * ```\n   *\n   * Example using `byPage()`:\n   *\n   * ```js\n   * // passing optional maxPageSize in the page settings\n   * let i = 1;\n   * for await (const response of dirClient.listHandles({ recursive: true }).byPage({ maxPageSize: 20 })) {\n   *   if (response.handleList) {\n   *     for (const handle of response.handleList) {\n   *       console.log(`Handle ${i++}: ${handle.path}, opened time ${handle.openTime}, clientIp ${handle.clientIp}`);\n   *     }\n   *   }\n   * }\n   * ```\n   *\n   * Example using paging with a marker:\n   *\n   * ```js\n   * let i = 1;\n   * let iterator = dirClient.listHandles().byPage({ maxPageSize: 2 });\n   * let response = await iterator.next();\n   *\n   * // Prints 2 handles\n   * if (response.value.handleList) {\n   *   for (const handle of response.value.handleList) {\n   *     console.log(`Handle ${i++}: ${handle.path}, opened time ${handle.openTime}, clientIp ${handle.clientIp}`);\n   *   }\n   * }\n   *\n   * // Gets next marker\n   * let marker = response.value.continuationToken;\n   *\n   * // Passing next marker as continuationToken\n   * console.log(`    continuation`);\n   * iterator = dirClient.listHandles().byPage({ continuationToken: marker, maxPageSize: 10 });\n   * response = await iterator.next();\n   *\n   * // Prints 2 more handles assuming you have more than four directory/files opened\n   * if (!response.done && response.value.handleList) {\n   *   for (const handle of response.value.handleList) {\n   *     console.log(`Handle ${i++}: ${handle.path}, opened time ${handle.openTime}, clientIp ${handle.clientIp}`);\n   *   }\n   * }\n   * ```\n   *\n   * @param {DirectoryListHandlesOptions} [options] Options to list handles operation.\n   * @memberof ShareDirectoryClient\n   * @returns {PagedAsyncIterableIterator<HandleItem, DirectoryListHandlesResponse>}\n   * An asyncIterableIterator that supports paging.\n   */\n  public listHandles(\n    options: DirectoryListHandlesOptions = {}\n  ): PagedAsyncIterableIterator<HandleItem, DirectoryListHandlesResponse> {\n    // an AsyncIterableIterator to iterate over handles\n    const iter = this.listHandleItems(options);\n    return {\n      /**\n       * @member {Promise} [next] The next method, part of the iteration protocol\n       */\n      async next() {\n        return iter.next();\n      },\n      /**\n       * @member {Symbol} [asyncIterator] The connection to the async iterator, part of the iteration protocol\n       */\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n      /**\n       * @member {Function} [byPage] Return an AsyncIterableIterator that works a page at a time\n       */\n      byPage: (settings: PageSettings = {}) => {\n        return this.iterateHandleSegments(settings.continuationToken, {\n          maxResults: settings.maxPageSize,\n          ...options\n        });\n      }\n    };\n  }\n\n  /**\n   * Lists handles for a directory.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/list-handles\n   *\n   * @param {string} [marker] Optional. A string value that identifies the portion of the list to be\n   *                          returned with the next list handles operation. The operation returns a\n   *                          marker value within the response body if the list returned was not complete.\n   *                          The marker value may then be used in a subsequent call to request the next\n   *                          set of list items.\n   * @param {DirectoryListHandlesSegmentOptions} [options={}]\n   * @returns {Promise<DirectoryListHandlesResponse>}\n   * @memberof ShareDirectoryClient\n   */\n  private async listHandlesSegment(\n    marker?: string,\n    options: DirectoryListHandlesSegmentOptions = {}\n  ): Promise<DirectoryListHandlesResponse> {\n    const { span, spanOptions } = createSpan(\n      \"ShareDirectoryClient-listHandlesSegment\",\n      options.tracingOptions\n    );\n    try {\n      marker = marker === \"\" ? undefined : marker;\n      const response = await this.context.listHandles({\n        marker,\n        ...options,\n        spanOptions\n      });\n\n      // TODO: Protocol layer issue that when handle list is in returned XML\n      // response.handleList is an empty string\n      if ((response.handleList as any) === \"\") {\n        response.handleList = undefined;\n      }\n      return response;\n    } catch (e) {\n      span.setStatus({\n        code: CanonicalCode.UNKNOWN,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Force close all handles for a directory.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/force-close-handles\n   *\n   * @param {string} [marker] Optional. A string value that identifies the position of handles that will\n   *                          be closed with the next force close handles operation.\n   *                          The operation returns a marker value within the response\n   *                          body if there are more handles to close. The marker value\n   *                          may then be used in a subsequent call to close the next set of handles.\n   * @param {DirectoryForceCloseHandlesSegmentOptions} [options={}]\n   * @returns {Promise<DirectoryForceCloseHandlesResponse>}\n   * @memberof ShareDirectoryClient\n   */\n  private async forceCloseHandlesSegment(\n    marker?: string,\n    options: DirectoryForceCloseHandlesSegmentOptions = {}\n  ): Promise<DirectoryForceCloseHandlesResponse> {\n    const { span, spanOptions } = createSpan(\n      \"ShareDirectoryClient-forceCloseHandlesSegment\",\n      options.tracingOptions\n    );\n    try {\n      marker = marker === \"\" ? undefined : marker;\n      const rawResponse = await this.context.forceCloseHandles(\"*\", {\n        marker,\n        ...options,\n        spanOptions\n      });\n      const response = rawResponse as DirectoryForceCloseHandlesResponse;\n      response.closedHandlesCount = rawResponse.numberOfHandlesClosed || 0;\n      response.closeFailureCount = rawResponse.numberOfHandlesFailedToClose || 0;\n      return response;\n    } catch (e) {\n      span.setStatus({\n        code: CanonicalCode.UNKNOWN,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Force close all handles for a directory.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/force-close-handles\n   *\n   * @param {DirectoryForceCloseHandlesSegmentOptions} [options={}]\n   * @returns {Promise<CloseHandlesInfo>}\n   * @memberof ShareDirectoryClient\n   */\n  public async forceCloseAllHandles(\n    options: DirectoryForceCloseHandlesSegmentOptions = {}\n  ): Promise<CloseHandlesInfo> {\n    const { span, spanOptions } = createSpan(\n      \"ShareDirectoryClient-forceCloseAllHandles\",\n      options.tracingOptions\n    );\n    try {\n      let handlesClosed = 0;\n      let numberOfHandlesFailedToClose = 0;\n      let marker: string | undefined = \"\";\n\n      do {\n        const response: DirectoryForceCloseHandlesResponse = await this.forceCloseHandlesSegment(\n          marker,\n          { ...options, tracingOptions: { ...options!.tracingOptions, spanOptions } }\n        );\n        marker = response.marker;\n        response.closedHandlesCount && (handlesClosed += response.closedHandlesCount);\n        response.closeFailureCount && (numberOfHandlesFailedToClose += response.closeFailureCount);\n      } while (marker);\n\n      return { closedHandlesCount: handlesClosed, closeFailureCount: numberOfHandlesFailedToClose };\n    } catch (e) {\n      span.setStatus({\n        code: CanonicalCode.UNKNOWN,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Force close a specific handle for a directory.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/force-close-handles\n   *\n   * @param {Aborter} aborter Create a new Aborter instance with Aborter.none or Aborter.timeout(),\n   *                          goto documents of Aborter for more examples about request cancellation\n   * @param {string} handleId Specific handle ID, cannot be asterisk \"*\".\n   *                          Use forceCloseHandlesSegment() to close all handles.\n   * @param {DirectoryForceCloseHandlesOptions} [options={}]\n   * @returns {Promise<DirectoryForceCloseHandlesResponse>}\n   * @memberof ShareDirectoryClient\n   */\n  public async forceCloseHandle(\n    handleId: string,\n    options: DirectoryForceCloseHandlesOptions = {}\n  ): Promise<DirectoryForceCloseHandlesResponse> {\n    const { span, spanOptions } = createSpan(\n      \"ShareDirectoryClient-forceCloseHandle\",\n      options.tracingOptions\n    );\n    try {\n      if (handleId === \"*\") {\n        throw new RangeError(\n          `Parameter handleID should be a specified handle ID. Use forceCloseHandlesSegment() to close all handles.`\n        );\n      }\n\n      const rawResponse = await this.context.forceCloseHandles(handleId, {\n        abortSignal: options.abortSignal,\n        spanOptions\n      });\n      const response = rawResponse as DirectoryForceCloseHandlesResponse;\n      response.closedHandlesCount = rawResponse.numberOfHandlesClosed || 0;\n      response.closeFailureCount = rawResponse.numberOfHandlesFailedToClose || 0;\n      return response;\n    } catch (e) {\n      span.setStatus({\n        code: CanonicalCode.UNKNOWN,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n}\n"]}
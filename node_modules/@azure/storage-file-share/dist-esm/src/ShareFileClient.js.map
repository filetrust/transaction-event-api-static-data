{"version":3,"file":"ShareFileClient.js","sourceRoot":"","sources":["../../src/ShareFileClient.ts"],"names":[],"mappings":"AAAA,4DAA4D;AAC5D,kCAAkC;;AAElC,OAAO,EAAiC,MAAM,EAAyB,MAAM,kBAAkB,CAAC;AAChG,OAAO,EAAE,aAAa,EAAE,MAAM,oBAAoB,CAAC;AAEnD,OAAO,EAAE,oBAAoB,EAAE,MAAM,wBAAwB,CAAC;AAsB9D,OAAO,EAAE,IAAI,EAAE,MAAM,4BAA4B,CAAC;AAClD,OAAO,EAAS,aAAa,EAAE,MAAM,SAAS,CAAC;AAC/C,OAAO,EAKL,sBAAsB,EACtB,wBAAwB,EACxB,yBAAyB,EACzB,4DAA4D,EAC5D,mEAAmE,EAEpE,MAAM,UAAU,CAAC;AAClB,OAAO,EAAE,WAAW,EAA0B,QAAQ,EAAE,MAAM,YAAY,CAAC;AAC3E,OAAO,EAAE,aAAa,EAAiB,MAAM,iBAAiB,CAAC;AAC/D,OAAO,EACL,mCAAmC,EACnC,mBAAmB,EACnB,yBAAyB,EACzB,8BAA8B,EAC/B,MAAM,mBAAmB,CAAC;AAC3B,OAAO,oBAAoB,CAAC;AAE5B,OAAO,EAAE,UAAU,EAAE,MAAM,0BAA0B,CAAC;AACtD,OAAO,EAAE,KAAK,EAAE,MAAM,eAAe,CAAC;AACtC,OAAO,EAAE,eAAe,EAAE,MAAM,yBAAyB,CAAC;AAE1D,OAAO,EAAE,mBAAmB,EAAE,MAAM,mCAAmC,CAAC;AACxE,OAAO,EACL,qBAAqB,EACrB,cAAc,EACd,MAAM,EACN,kBAAkB,EACnB,MAAM,oBAAoB,CAAC;AAC5B,OAAO,EAAE,oBAAoB,EAAE,MAAM,wBAAwB,CAAC;AAC9D,OAAO,EAAE,0BAA0B,EAAE,MAAM,sBAAsB,CAAC;AAClE,OAAO,EAAE,UAAU,EAAE,MAAM,iBAAiB,CAAC;AAC7C,OAAO,EAAE,oBAAoB,EAAE,MAAM,sCAAsC,CAAC;AAC5E,OAAO,EAAE,eAAe,EAAE,MAAM,mBAAmB,CAAC;AACpD,OAAO,EAAE,YAAY,EAAE,MAAM,kBAAkB,CAAC;AA00BhD;;;;;GAKG;AACH;IAAqC,mCAAa;IA6EhD,yBACE,GAAW,EACX,oBAA4C,EAC5C,OAAgC;;QAHlC,iBAsBC;QAjBC,IAAI,QAAkB,CAAC;QACvB,IAAI,oBAAoB,YAAY,QAAQ,EAAE;YAC5C,QAAQ,GAAG,oBAAoB,CAAC;SACjC;aAAM,IAAI,oBAAoB,YAAY,UAAU,EAAE;YACrD,QAAQ,GAAG,WAAW,CAAC,oBAAoB,EAAE,OAAO,CAAC,CAAC;SACvD;aAAM;YACL,+DAA+D;YAC/D,QAAQ,GAAG,WAAW,CAAC,IAAI,mBAAmB,EAAE,EAAE,OAAO,CAAC,CAAC;SAC5D;QAED,QAAA,kBAAM,GAAG,EAAE,QAAQ,CAAC,SAAC;QACrB,CAAC,KAIG,0BAA0B,CAAC,KAAI,CAAC,GAAG,CAAC,EAH5B,KAAI,CAAC,KAAK,cAAA,EACT,KAAI,CAAC,UAAU,eAAA,EACpB,KAAI,CAAC,KAAK,UAAA,CACuB,CAAC;QAC1C,KAAI,CAAC,OAAO,GAAG,IAAI,IAAI,CAAC,KAAI,CAAC,oBAAoB,CAAC,CAAC;;IACrD,CAAC;IA/ED,sBAAW,sCAAS;QANpB;;;;;WAKG;aACH;YACE,OAAO,IAAI,CAAC,UAAU,CAAC;QACzB,CAAC;;;OAAA;IAQD,sBAAW,iCAAI;QANf;;;;;WAKG;aACH;YACE,OAAO,IAAI,CAAC,KAAK,CAAC;QACpB,CAAC;;;OAAA;IAQD,sBAAW,iCAAI;QANf;;;;;WAKG;aACH;YACE,OAAO,IAAI,CAAC,KAAK,CAAC;QACpB,CAAC;;;OAAA;IA2DD;;;;;;;;;;;;;;;;;;;;;;OAsBG;IACU,gCAAM,GAAnB,UAAoB,IAAY,EAAE,OAA+B;QAA/B,wBAAA,EAAA,YAA+B;;;;;;wBACzD,KAAwB,UAAU,CAAC,wBAAwB,EAAE,OAAO,CAAC,cAAc,CAAC,EAAlF,IAAI,UAAA,EAAE,WAAW,iBAAA,CAAkE;;;;wBAEzF,IAAI,IAAI,GAAG,CAAC,IAAI,IAAI,GAAG,mBAAmB,EAAE;4BAC1C,MAAM,IAAI,UAAU,CAAC,+BAA6B,mBAAmB,MAAG,CAAC,CAAC;yBAC3E;wBACD,OAAO,GAAG,4DAA4D,CAAC,OAAO,CAAC,CAAC;wBAEhF,IAAI,CAAC,OAAO,CAAC,cAAc,EAAE;4BAErB,UAAU,GAAyB,IAAI,oBAAoB,EAAE,CAAC;4BACpE,UAAU,CAAC,IAAI,GAAG,IAAI,CAAC;4BACvB,OAAO,CAAC,cAAc,GAAG,UAAU,CAAC;yBACrC;wBAED,OAAO,CAAC,eAAe,GAAG,OAAO,CAAC,eAAe,IAAI,EAAE,CAAC;wBAEjD,qBAAM,IAAI,CAAC,OAAO,CAAC,MAAM,CAC9B,IAAI,EACJ,sBAAsB,CAAC,OAAO,CAAC,cAAe,CAAC,EAC/C,wBAAwB,CAAC,OAAO,CAAC,YAAa,CAAC,EAC/C,yBAAyB,CAAC,OAAO,CAAC,aAAc,CAAC,EACjD;gCACE,WAAW,EAAE,OAAO,CAAC,WAAW;gCAChC,eAAe,EAAE,OAAO,CAAC,eAAe;gCACxC,QAAQ,EAAE,OAAO,CAAC,QAAQ;gCAC1B,cAAc,EAAE,OAAO,CAAC,cAAc;gCACtC,iBAAiB,EAAE,OAAO,CAAC,iBAAiB;gCAC5C,qBAAqB,EAAE,OAAO,CAAC,qBAAqB;gCACpD,WAAW,aAAA;6BACZ,CACF,EAAA;4BAdD,sBAAO,SAcN,EAAC;;;wBAEF,IAAI,CAAC,SAAS,CAAC;4BACb,IAAI,EAAE,aAAa,CAAC,OAAO;4BAC3B,OAAO,EAAE,GAAC,CAAC,OAAO;yBACnB,CAAC,CAAC;wBACH,MAAM,GAAC,CAAC;;wBAER,IAAI,CAAC,GAAG,EAAE,CAAC;;;;;;KAEd;IAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;OA6DG;IACU,kCAAQ,GAArB,UACE,MAAkB,EAClB,KAAc,EACd,OAAiC;QAFjC,uBAAA,EAAA,UAAkB;QAElB,wBAAA,EAAA,YAAiC;;;;;;;wBAE3B,KAAwB,UAAU,CAAC,0BAA0B,EAAE,OAAO,CAAC,cAAc,CAAC,EAApF,IAAI,UAAA,EAAE,WAAW,iBAAA,CAAoE;;;;wBAE3F,IAAI,OAAO,CAAC,kBAAkB,IAAI,MAAM,KAAK,CAAC,IAAI,KAAK,KAAK,SAAS,EAAE;4BACrE,MAAM,IAAI,UAAU,CAAC,6DAA6D,CAAC,CAAC;yBACrF;wBAEK,gBAAgB,GAAG,MAAM,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC;wBACpC,qBAAM,IAAI,CAAC,OAAO,CAAC,QAAQ,CAAC;gCACtC,WAAW,EAAE,OAAO,CAAC,WAAW;gCAChC,kBAAkB,EAAE,MAAM,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,OAAO,CAAC,UAAU;gCAC3D,KAAK,EAAE,gBAAgB,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,aAAa,CAAC,EAAE,MAAM,QAAA,EAAE,KAAK,OAAA,EAAE,CAAC;gCACtE,kBAAkB,EAAE,OAAO,CAAC,kBAAkB;gCAC9C,qBAAqB,EAAE,OAAO,CAAC,qBAAqB;gCACpD,WAAW,aAAA;6BACZ,CAAC,EAAA;;wBAPI,QAAM,SAOV;wBAEF,sCAAsC;wBACtC,IAAI,CAAC,MAAM,EAAE;4BACX,sBAAO,KAAG,EAAC;yBACZ;wBAED,8EAA8E;wBAC9E,uEAAuE;wBACvE,uEAAuE;wBACvE,sGAAsG;wBACtG,gDAAgD;wBAChD,IAAI,OAAO,CAAC,gBAAgB,KAAK,SAAS,IAAI,OAAO,CAAC,gBAAgB,GAAG,CAAC,EAAE;4BAC1E,uDAAuD;4BACvD,OAAO,CAAC,gBAAgB,GAAG,mCAAmC,CAAC;yBAChE;wBAED,IAAI,KAAG,CAAC,aAAa,KAAK,SAAS,EAAE;4BACnC,MAAM,IAAI,UAAU,CAAC,oEAAoE,CAAC,CAAC;yBAC5F;wBAED,sBAAO,IAAI,oBAAoB,CAC7B,KAAG,EACH,UAAO,KAAa;;;;;4CACZ,cAAc,GAA+B;gDACjD,KAAK,EAAE,aAAa,CAAC;oDACnB,KAAK,EAAE,MAAM,GAAG,KAAG,CAAC,aAAc,GAAG,KAAK;oDAC1C,MAAM,EAAE,KAAK;iDACd,CAAC;6CACH,CAAC;4CAUA,qBAAM,IAAI,CAAC,OAAO,CAAC,QAAQ,qBACzB,WAAW,EAAE,OAAO,CAAC,WAAW,EAChC,qBAAqB,EAAE,OAAO,CAAC,qBAAqB,IACjD,cAAc,KACjB,WAAW,aAAA,IACX,EAAA;;wCAbJ,qBAAqB;wCACrB,eAAe;wCACf,0CAA0C;wCAC1C,2BAA2B;wCAC3B,mDAAmD;wCACnD,KAAK;wCAEL,sBAAO,CACL,SAKE,CACH,CAAC,kBAAmB,EAAC;;;iCACvB,EACD,MAAM,EACN,KAAG,CAAC,aAAc,EAClB;gCACE,WAAW,EAAE,OAAO,CAAC,WAAW;gCAChC,gBAAgB,EAAE,OAAO,CAAC,gBAAgB;gCAC1C,UAAU,EAAE,OAAO,CAAC,UAAU;6BAC/B,CACF,EAAC;;;wBAEF,IAAI,CAAC,SAAS,CAAC;4BACb,IAAI,EAAE,aAAa,CAAC,OAAO;4BAC3B,OAAO,EAAE,GAAC,CAAC,OAAO;yBACnB,CAAC,CAAC;wBACH,MAAM,GAAC,CAAC;;wBAER,IAAI,CAAC,GAAG,EAAE,CAAC;;;;;;KAEd;IAED;;;;;;;;;;OAUG;IACU,gCAAM,GAAnB,UAAoB,OAA+B;QAA/B,wBAAA,EAAA,YAA+B;;;;;;wBAC3C,KAAwB,UAAU,CAAC,wBAAwB,EAAE,OAAO,CAAC,cAAc,CAAC,EAAlF,IAAI,UAAA,EAAE,WAAW,iBAAA,CAAkE;;;;wBAEzF,qBAAM,IAAI,CAAC,aAAa,CAAC;gCACvB,WAAW,EAAE,OAAO,CAAC,WAAW;gCAChC,cAAc,wBACT,OAAO,CAAC,cAAc,KACzB,WAAW,aAAA,GACZ;6BACF,CAAC,EAAA;;wBANF,SAME,CAAC;wBACH,sBAAO,IAAI,EAAC;;;wBAEZ,IAAI,GAAC,CAAC,UAAU,KAAK,GAAG,EAAE;4BACxB,IAAI,CAAC,SAAS,CAAC;gCACb,IAAI,EAAE,aAAa,CAAC,SAAS;gCAC7B,OAAO,EAAE,iDAAiD;6BAC3D,CAAC,CAAC;4BACH,sBAAO,KAAK,EAAC;yBACd;wBACD,IAAI,CAAC,SAAS,CAAC;4BACb,IAAI,EAAE,aAAa,CAAC,OAAO;4BAC3B,OAAO,EAAE,GAAC,CAAC,OAAO;yBACnB,CAAC,CAAC;wBACH,MAAM,GAAC,CAAC;;wBAER,IAAI,CAAC,GAAG,EAAE,CAAC;;;;;;KAEd;IAED;;;;;;;;OAQG;IACU,uCAAa,GAA1B,UACE,OAAsC;QAAtC,wBAAA,EAAA,YAAsC;;;;gBAEhC,KAAwB,UAAU,CACtC,+BAA+B,EAC/B,OAAO,CAAC,cAAc,CACvB,EAHO,IAAI,UAAA,EAAE,WAAW,iBAAA,CAGvB;gBACF,IAAI;oBACF,sBAAO,IAAI,CAAC,OAAO,CAAC,aAAa,CAAC;4BAChC,WAAW,EAAE,OAAO,CAAC,WAAW;4BAChC,qBAAqB,EAAE,OAAO,CAAC,qBAAqB;4BACpD,WAAW,aAAA;yBACZ,CAAC,EAAC;iBACJ;gBAAC,OAAO,CAAC,EAAE;oBACV,IAAI,CAAC,SAAS,CAAC;wBACb,IAAI,EAAE,aAAa,CAAC,OAAO;wBAC3B,OAAO,EAAE,CAAC,CAAC,OAAO;qBACnB,CAAC,CAAC;oBACH,MAAM,CAAC,CAAC;iBACT;wBAAS;oBACR,IAAI,CAAC,GAAG,EAAE,CAAC;iBACZ;;;;KACF;IAED;;;;;;;;;;OAUG;IACU,uCAAa,GAA1B,UAA2B,UAA+B;QAA/B,2BAAA,EAAA,eAA+B;;;;;;wBAClD,KAAwB,UAAU,CACtC,+BAA+B,EAC/B,UAAU,CAAC,cAAc,CAC1B,EAHO,IAAI,UAAA,EAAE,WAAW,iBAAA,CAGvB;;;;wBAEA,UAAU,GAAG,mEAAmE,CAAC,UAAU,CAAC,CAAC;wBAE7F,UAAU,CAAC,eAAe,GAAG,UAAU,CAAC,eAAe,IAAI,EAAE,CAAC;wBAEvD,qBAAM,IAAI,CAAC,OAAO,CAAC,cAAc,CACtC,sBAAsB,CAAC,UAAU,CAAC,cAAe,CAAC,EAClD,wBAAwB,CAAC,UAAU,CAAC,YAAa,CAAC,EAClD,yBAAyB,CAAC,UAAU,CAAC,aAAc,CAAC,EACpD;gCACE,WAAW,EAAE,UAAU,CAAC,WAAW;gCACnC,eAAe,EAAE,UAAU,CAAC,eAAe;gCAC3C,cAAc,EAAE,UAAU,CAAC,cAAc;gCACzC,iBAAiB,EAAE,UAAU,CAAC,iBAAiB;gCAC/C,qBAAqB,EAAE,UAAU,CAAC,qBAAqB;gCACvD,WAAW,aAAA;6BACZ,CACF,EAAA;4BAZD,sBAAO,SAYN,EAAC;;;wBAEF,IAAI,CAAC,SAAS,CAAC;4BACb,IAAI,EAAE,aAAa,CAAC,OAAO;4BAC3B,OAAO,EAAE,GAAC,CAAC,OAAO;yBACnB,CAAC,CAAC;wBACH,MAAM,GAAC,CAAC;;wBAER,IAAI,CAAC,GAAG,EAAE,CAAC;;;;;;KAEd;IAED;;;;;;;;;;;;;;;;;OAiBG;IACU,gCAAM,GAAnB,UAAoB,OAA+B;QAA/B,wBAAA,EAAA,YAA+B;;;;;;wBAC3C,KAAwB,UAAU,CAAC,wBAAwB,EAAE,OAAO,CAAC,cAAc,CAAC,EAAlF,IAAI,UAAA,EAAE,WAAW,iBAAA,CAAkE;;;;wBAElF,qBAAM,IAAI,CAAC,OAAO,CAAC,YAAY,CAAC;gCACrC,WAAW,EAAE,OAAO,CAAC,WAAW;gCAChC,qBAAqB,EAAE,OAAO,CAAC,qBAAqB;gCACpD,WAAW,aAAA;6BACZ,CAAC,EAAA;4BAJF,sBAAO,SAIL,EAAC;;;wBAEH,IAAI,CAAC,SAAS,CAAC;4BACb,IAAI,EAAE,aAAa,CAAC,OAAO;4BAC3B,OAAO,EAAE,GAAC,CAAC,OAAO;yBACnB,CAAC,CAAC;wBACH,MAAM,GAAC,CAAC;;wBAER,IAAI,CAAC,GAAG,EAAE,CAAC;;;;;;KAEd;IAED;;;;;;;;;;;;;;;;;OAiBG;IACU,wCAAc,GAA3B,UACE,OAA+B;;QAA/B,wBAAA,EAAA,YAA+B;;;;;;wBAEzB,KAAwB,UAAU,CACtC,gCAAgC,EAChC,OAAO,CAAC,cAAc,CACvB,EAHO,IAAI,UAAA,EAAE,WAAW,iBAAA,CAGvB;;;;wBAEY,qBAAM,IAAI,CAAC,MAAM,uBACxB,OAAO,KACV,cAAc,wBAAO,OAAQ,CAAC,cAAc,KAAE,WAAW,aAAA,OACzD,EAAA;;wBAHI,GAAG,GAAG,SAGV;wBACF,iCACE,SAAS,EAAE,IAAI,IACZ,GAAG,GACN;;;wBAEF,IAAI,OAAA,GAAC,CAAC,OAAO,0CAAE,SAAS,MAAK,kBAAkB,EAAE;4BAC/C,IAAI,CAAC,SAAS,CAAC;gCACb,IAAI,EAAE,aAAa,CAAC,SAAS;gCAC7B,OAAO,EAAE,4DAA4D;6BACtE,CAAC,CAAC;4BACH,0CACE,SAAS,EAAE,KAAK,UACb,GAAC,CAAC,QAAQ,0CAAE,aAAa,KAC5B,SAAS,EAAE,GAAC,CAAC,QAAQ,KACrB;yBACH;wBACD,IAAI,CAAC,SAAS,CAAC;4BACb,IAAI,EAAE,aAAa,CAAC,OAAO;4BAC3B,OAAO,EAAE,GAAC,CAAC,OAAO;yBACnB,CAAC,CAAC;wBACH,MAAM,GAAC,CAAC;;wBAER,IAAI,CAAC,GAAG,EAAE,CAAC;;;;;;KAEd;IAED;;;;;;;;;;;;OAYG;IACU,wCAAc,GAA3B,UACE,eAAqC,EACrC,OAAuC;QADvC,gCAAA,EAAA,oBAAqC;QACrC,wBAAA,EAAA,YAAuC;;;;;;wBAEjC,KAAwB,UAAU,CACtC,gCAAgC,EAChC,OAAO,CAAC,cAAc,CACvB,EAHO,IAAI,UAAA,EAAE,WAAW,iBAAA,CAGvB;;;;wBAEA,kFAAkF;wBAClF,OAAO,GAAG,mEAAmE,CAAC,OAAO,CAAC,CAAC;wBAChF,qBAAM,IAAI,CAAC,OAAO,CAAC,cAAc,CACtC,sBAAsB,CAAC,OAAO,CAAC,cAAe,CAAC,EAC/C,wBAAwB,CAAC,OAAO,CAAC,YAAa,CAAC,EAC/C,yBAAyB,CAAC,OAAO,CAAC,aAAc,CAAC,EACjD;gCACE,WAAW,EAAE,OAAO,CAAC,WAAW;gCAChC,eAAe,iBAAA;gCACf,cAAc,EAAE,OAAO,CAAC,cAAc;gCACtC,iBAAiB,EAAE,OAAO,CAAC,iBAAiB;gCAC5C,qBAAqB,EAAE,OAAO,CAAC,qBAAqB;gCACpD,WAAW,aAAA;6BACZ,CACF,EAAA;4BAZD,sBAAO,SAYN,EAAC;;;wBAEF,IAAI,CAAC,SAAS,CAAC;4BACb,IAAI,EAAE,aAAa,CAAC,OAAO;4BAC3B,OAAO,EAAE,GAAC,CAAC,OAAO;yBACnB,CAAC,CAAC;wBACH,MAAM,GAAC,CAAC;;wBAER,IAAI,CAAC,GAAG,EAAE,CAAC;;;;;;KAEd;IAED;;;;;;;;;;;OAWG;IACU,gCAAM,GAAnB,UACE,MAAc,EACd,OAA+B;QAA/B,wBAAA,EAAA,YAA+B;;;;;;wBAEzB,KAAwB,UAAU,CAAC,wBAAwB,EAAE,OAAO,CAAC,cAAc,CAAC,EAAlF,IAAI,UAAA,EAAE,WAAW,iBAAA,CAAkE;;;;wBAEzF,IAAI,MAAM,GAAG,CAAC,EAAE;4BACd,MAAM,IAAI,UAAU,CAAC,6CAA6C,CAAC,CAAC;yBACrE;wBACD,mFAAmF;wBACnF,OAAO,GAAG,mEAAmE,CAAC,OAAO,CAAC,CAAC;wBAEhF,qBAAM,IAAI,CAAC,OAAO,CAAC,cAAc,CACtC,sBAAsB,CAAC,OAAO,CAAC,cAAe,CAAC,EAC/C,wBAAwB,CAAC,OAAO,CAAC,YAAa,CAAC,EAC/C,yBAAyB,CAAC,OAAO,CAAC,aAAc,CAAC,EACjD;gCACE,WAAW,EAAE,OAAO,CAAC,WAAW;gCAChC,iBAAiB,EAAE,MAAM;gCACzB,cAAc,EAAE,OAAO,CAAC,cAAc;gCACtC,iBAAiB,EAAE,OAAO,CAAC,iBAAiB;gCAC5C,qBAAqB,EAAE,OAAO,CAAC,qBAAqB;gCACpD,WAAW,aAAA;6BACZ,CACF,EAAA;4BAZD,sBAAO,SAYN,EAAC;;;wBAEF,IAAI,CAAC,SAAS,CAAC;4BACb,IAAI,EAAE,aAAa,CAAC,OAAO;4BAC3B,OAAO,EAAE,GAAC,CAAC,OAAO;yBACnB,CAAC,CAAC;wBACH,MAAM,GAAC,CAAC;;wBAER,IAAI,CAAC,GAAG,EAAE,CAAC;;;;;;KAEd;IAED;;;;;;;;;;;OAWG;IACU,qCAAW,GAAxB,UACE,QAAuB,EACvB,OAAoC;QADpC,yBAAA,EAAA,aAAuB;QACvB,wBAAA,EAAA,YAAoC;;;;;;wBAE9B,KAAwB,UAAU,CAAC,6BAA6B,EAAE,OAAO,CAAC,cAAc,CAAC,EAAvF,IAAI,UAAA,EAAE,WAAW,iBAAA,CAAuE;;;;wBAEvF,qBAAM,IAAI,CAAC,OAAO,CAAC,WAAW,CAAC;gCACpC,WAAW,EAAE,OAAO,CAAC,WAAW;gCAChC,QAAQ,UAAA;gCACR,qBAAqB,EAAE,OAAO,CAAC,qBAAqB;gCACpD,WAAW,aAAA;6BACZ,CAAC,EAAA;4BALF,sBAAO,SAKL,EAAC;;;wBAEH,IAAI,CAAC,SAAS,CAAC;4BACb,IAAI,EAAE,aAAa,CAAC,OAAO;4BAC3B,OAAO,EAAE,GAAC,CAAC,OAAO;yBACnB,CAAC,CAAC;wBACH,MAAM,GAAC,CAAC;;wBAER,IAAI,CAAC,GAAG,EAAE,CAAC;;;;;;KAEd;IAED;;;;;;;;;;;;;;;;;;;;;;;;;;OA0BG;IACU,qCAAW,GAAxB,UACE,IAAqB,EACrB,MAAc,EACd,aAAqB,EACrB,OAAoC;QAApC,wBAAA,EAAA,YAAoC;;;;;;wBAE9B,KAAwB,UAAU,CAAC,6BAA6B,EAAE,OAAO,CAAC,cAAc,CAAC,EAAvF,IAAI,UAAA,EAAE,WAAW,iBAAA,CAAuE;;;;wBAE9F,IAAI,MAAM,GAAG,CAAC,EAAE;4BACd,MAAM,IAAI,UAAU,CAAC,qBAAqB,CAAC,CAAC;yBAC7C;wBAED,IAAI,aAAa,IAAI,CAAC,IAAI,aAAa,GAAG,yBAAyB,EAAE;4BACnE,MAAM,IAAI,UAAU,CAAC,sCAAoC,yBAAyB,WAAQ,CAAC,CAAC;yBAC7F;wBAED,IAAI,aAAa,GAAG,yBAAyB,EAAE;4BAC7C,MAAM,IAAI,UAAU,CAAC,sBAAoB,yBAAyB,WAAQ,CAAC,CAAC;yBAC7E;wBAEM,qBAAM,IAAI,CAAC,OAAO,CAAC,WAAW,CACnC,aAAa,CAAC,EAAE,KAAK,EAAE,aAAa,EAAE,MAAM,QAAA,EAAE,CAAC,EAC/C,QAAQ,EACR,aAAa,EACb;gCACE,WAAW,EAAE,OAAO,CAAC,WAAW;gCAChC,UAAU,EAAE,OAAO,CAAC,UAAU;gCAC9B,gBAAgB,EAAE,OAAO,CAAC,UAAU;gCACpC,IAAI,EAAE,IAAI;gCACV,WAAW,aAAA;gCACX,qBAAqB,EAAE,OAAO,CAAC,qBAAqB;6BACrD,CACF,EAAA;4BAZD,sBAAO,SAYN,EAAC;;;wBAEF,IAAI,CAAC,SAAS,CAAC;4BACb,IAAI,EAAE,aAAa,CAAC,OAAO;4BAC3B,OAAO,EAAE,IAAC,CAAC,OAAO;yBACnB,CAAC,CAAC;wBACH,MAAM,IAAC,CAAC;;wBAER,IAAI,CAAC,GAAG,EAAE,CAAC;;;;;;KAEd;IAED;;;;;;;;;;;OAWG;IACU,4CAAkB,GAA/B,UACE,SAAiB,EACjB,YAAoB,EACpB,UAAkB,EAClB,KAAa,EACb,OAA2C;QAA3C,wBAAA,EAAA,YAA2C;;;;;;wBAErC,KAAwB,UAAU,CACtC,oCAAoC,EACpC,OAAO,CAAC,cAAc,CACvB,EAHO,IAAI,UAAA,EAAE,WAAW,iBAAA,CAGvB;;;;wBAEA,IAAI,YAAY,GAAG,CAAC,IAAI,UAAU,GAAG,CAAC,EAAE;4BACtC,MAAM,IAAI,UAAU,CAAC,0CAA0C,CAAC,CAAC;yBAClE;wBAED,IAAI,KAAK,IAAI,CAAC,IAAI,KAAK,GAAG,yBAAyB,EAAE;4BACnD,MAAM,IAAI,UAAU,CAAC,8BAA4B,yBAAyB,WAAQ,CAAC,CAAC;yBACrF;wBAEM,qBAAM,IAAI,CAAC,OAAO,CAAC,kBAAkB,CAC1C,aAAa,CAAC,EAAE,MAAM,EAAE,UAAU,EAAE,KAAK,OAAA,EAAE,CAAC,EAC5C,SAAS,EACT,CAAC,sBAEC,WAAW,EAAE,OAAO,CAAC,WAAW,EAChC,WAAW,EAAE,aAAa,CAAC,EAAE,MAAM,EAAE,YAAY,EAAE,KAAK,OAAA,EAAE,CAAC,EAC3D,8BAA8B,EAAE,OAAO,CAAC,gBAAgB,IACrD,OAAO,KACV,WAAW,aAAA,IAEd,EAAA;4BAXD,sBAAO,SAWN,EAAC;;;wBAEF,IAAI,CAAC,SAAS,CAAC;4BACb,IAAI,EAAE,aAAa,CAAC,OAAO;4BAC3B,OAAO,EAAE,IAAC,CAAC,OAAO;yBACnB,CAAC,CAAC;wBACH,MAAM,IAAC,CAAC;;wBAER,IAAI,CAAC,GAAG,EAAE,CAAC;;;;;;KAEd;IACD;;;;;;;;;OASG;IACU,oCAAU,GAAvB,UACE,MAAc,EACd,aAAqB,EACrB,OAAmC;QAAnC,wBAAA,EAAA,YAAmC;;;;;;wBAE7B,KAAwB,UAAU,CAAC,4BAA4B,EAAE,OAAO,CAAC,cAAc,CAAC,EAAtF,IAAI,UAAA,EAAE,WAAW,iBAAA,CAAsE;;;;wBAE7F,IAAI,MAAM,GAAG,CAAC,IAAI,aAAa,IAAI,CAAC,EAAE;4BACpC,MAAM,IAAI,UAAU,CAAC,gDAAgD,CAAC,CAAC;yBACxE;wBAEM,qBAAM,IAAI,CAAC,OAAO,CAAC,WAAW,CACnC,aAAa,CAAC,EAAE,KAAK,EAAE,aAAa,EAAE,MAAM,QAAA,EAAE,CAAC,EAC/C,OAAO,EACP,CAAC,EACD;gCACE,WAAW,EAAE,OAAO,CAAC,WAAW;gCAChC,WAAW,aAAA;gCACX,qBAAqB,EAAE,OAAO,CAAC,qBAAqB;6BACrD,CACF,EAAA;4BATD,sBAAO,SASN,EAAC;;;wBAEF,IAAI,CAAC,SAAS,CAAC;4BACb,IAAI,EAAE,aAAa,CAAC,OAAO;4BAC3B,OAAO,EAAE,IAAC,CAAC,OAAO;yBACnB,CAAC,CAAC;wBACH,MAAM,IAAC,CAAC;;wBAER,IAAI,CAAC,GAAG,EAAE,CAAC;;;;;;KAEd;IAED;;;;;;OAMG;IACU,sCAAY,GAAzB,UACE,OAAqC;QAArC,wBAAA,EAAA,YAAqC;;;;;;wBAE/B,KAAwB,UAAU,CACtC,8BAA8B,EAC9B,OAAO,CAAC,cAAc,CACvB,EAHO,IAAI,UAAA,EAAE,WAAW,iBAAA,CAGvB;;;;wBAEyB,qBAAM,IAAI,CAAC,OAAO,CAAC,YAAY,CAAC;gCACvD,WAAW,EAAE,OAAO,CAAC,WAAW;gCAChC,KAAK,EAAE,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC,aAAa,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,SAAS;gCAC/D,qBAAqB,EAAE,OAAO,CAAC,qBAAqB;gCACpD,WAAW,aAAA;6BACZ,CAAC,EAAA;;wBALI,gBAAgB,GAAG,SAKvB;wBACF,sBAAO;gCACL,SAAS,EAAE,gBAAgB,CAAC,SAAS;gCACrC,IAAI,EAAE,gBAAgB,CAAC,IAAI;gCAC3B,IAAI,EAAE,gBAAgB,CAAC,IAAI;gCAC3B,SAAS,EAAE,gBAAgB,CAAC,SAAS;gCACrC,iBAAiB,EAAE,gBAAgB,CAAC,iBAAiB;gCACrD,YAAY,EAAE,gBAAgB,CAAC,YAAY;gCAC3C,SAAS,EAAE,gBAAgB,CAAC,MAAM,CAAC;oCACjC,OAAO,IAAI,CAAC;gCACd,CAAC,CAAC;gCACF,SAAS,EAAE,gBAAgB,CAAC,SAAS;gCACrC,OAAO,EAAE,gBAAgB,CAAC,OAAO;6BAClC,EAAC;;;wBAEF,IAAI,CAAC,SAAS,CAAC;4BACb,IAAI,EAAE,aAAa,CAAC,OAAO;4BAC3B,OAAO,EAAE,IAAC,CAAC,OAAO;yBACnB,CAAC,CAAC;wBACH,MAAM,IAAC,CAAC;;wBAER,IAAI,CAAC,GAAG,EAAE,CAAC;;;;;;KAEd;IAED;;;;;;;;;;;;;OAaG;IACU,0CAAgB,GAA7B,UACE,UAAkB,EAClB,OAAkC;QAAlC,wBAAA,EAAA,YAAkC;;;;;;wBAE5B,KAAwB,UAAU,CACtC,kCAAkC,EAClC,OAAO,CAAC,cAAc,CACvB,EAHO,IAAI,UAAA,EAAE,WAAW,iBAAA,CAGvB;;;;wBAEO,qBAAM,IAAI,CAAC,OAAO,CAAC,SAAS,CAAC,UAAU,EAAE;gCAC9C,WAAW,EAAE,OAAO,CAAC,WAAW;gCAChC,QAAQ,EAAE,OAAO,CAAC,QAAQ;gCAC1B,qBAAqB,EAAE,OAAO,CAAC,qBAAqB;gCACpD,cAAc,EAAE,OAAO,CAAC,cAAc;gCACtC,iBAAiB,EAAE,OAAO,CAAC,iBAAiB;gCAC5C,eAAe,EAAE,OAAO,CAAC,eAAe;gCACxC,WAAW,aAAA;6BACZ,CAAC,EAAA;4BARF,sBAAO,SAQL,EAAC;;;wBAEH,IAAI,CAAC,SAAS,CAAC;4BACb,IAAI,EAAE,aAAa,CAAC,OAAO;4BAC3B,OAAO,EAAE,IAAC,CAAC,OAAO;yBACnB,CAAC,CAAC;wBACH,MAAM,IAAC,CAAC;;wBAER,IAAI,CAAC,GAAG,EAAE,CAAC;;;;;;KAEd;IAED;;;;;;;;;OASG;IACU,0CAAgB,GAA7B,UACE,MAAc,EACd,OAAyC;QAAzC,wBAAA,EAAA,YAAyC;;;;;;wBAEnC,KAAwB,UAAU,CACtC,kCAAkC,EAClC,OAAO,CAAC,cAAc,CACvB,EAHO,IAAI,UAAA,EAAE,WAAW,iBAAA,CAGvB;;;;wBAEO,qBAAM,IAAI,CAAC,OAAO,CAAC,SAAS,CAAC,MAAM,EAAE;gCAC1C,WAAW,EAAE,OAAO,CAAC,WAAW;gCAChC,qBAAqB,EAAE,OAAO,CAAC,qBAAqB;gCACpD,WAAW,aAAA;6BACZ,CAAC,EAAA;4BAJF,sBAAO,SAIL,EAAC;;;wBAEH,IAAI,CAAC,SAAS,CAAC;4BACb,IAAI,EAAE,aAAa,CAAC,OAAO;4BAC3B,OAAO,EAAE,IAAC,CAAC,OAAO;yBACnB,CAAC,CAAC;wBACH,MAAM,IAAC,CAAC;;wBAER,IAAI,CAAC,GAAG,EAAE,CAAC;;;;;;KAEd;IAED,uBAAuB;IAEvB;;;;;;OAMG;IACU,oCAAU,GAAvB,UACE,IAAmD,EACnD,OAAuC;QAAvC,wBAAA,EAAA,YAAuC;;;;gBAEjC,KAAwB,UAAU,CAAC,4BAA4B,EAAE,OAAO,CAAC,cAAc,CAAC,EAAtF,IAAI,UAAA,EAAE,WAAW,iBAAA,CAAsE;gBAC/F,IAAI;oBACF,IAAI,MAAM,IAAI,IAAI,YAAY,MAAM,EAAE;wBACpC,sBAAO,IAAI,CAAC,YAAY,CACtB,UAAC,MAAM,EAAE,KAAK,IAAK,OAAA,IAAI,CAAC,KAAK,CAAC,MAAM,EAAE,MAAM,GAAG,KAAK,CAAC,EAAlC,CAAkC,EACrD,IAAI,CAAC,UAAU,wBAEV,OAAO,KACV,cAAc,wBAAO,OAAQ,CAAC,cAAc,KAAE,WAAW,aAAA,OAE5D,EAAC;qBACH;yBAAM;wBACC,gBAAc,IAAI,IAAI,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC;wBACrC,sBAAO,IAAI,CAAC,kBAAkB,CAC5B,UAAC,MAAc,EAAE,IAAY;gCAC3B,OAAO,aAAW,CAAC,KAAK,CAAC,MAAM,EAAE,MAAM,GAAG,IAAI,CAAC,CAAC;4BAClD,CAAC,EACD,aAAW,CAAC,IAAI,wBACX,OAAO,KAAE,cAAc,wBAAO,OAAQ,CAAC,cAAc,KAAE,WAAW,aAAA,OACxE,EAAC;qBACH;iBACF;gBAAC,OAAO,CAAC,EAAE;oBACV,IAAI,CAAC,SAAS,CAAC;wBACb,IAAI,EAAE,aAAa,CAAC,OAAO;wBAC3B,OAAO,EAAE,CAAC,CAAC,OAAO;qBACnB,CAAC,CAAC;oBACH,MAAM,CAAC,CAAC;iBACT;wBAAS;oBACR,IAAI,CAAC,GAAG,EAAE,CAAC;iBACZ;;;;KACF;IAED;;;;;;;;;;OAUG;IACG,4CAAkB,GAAxB,UACE,WAAmD,EACnD,IAAY,EACZ,OAAuC;QAAvC,wBAAA,EAAA,YAAuC;;;;;;;wBAEjC,KAAwB,UAAU,CACtC,oCAAoC,EACpC,OAAO,CAAC,cAAc,CACvB,EAHO,IAAI,UAAA,EAAE,WAAW,iBAAA,CAGvB;;;;wBAEA,IAAI,CAAC,OAAO,CAAC,SAAS,EAAE;4BACtB,OAAO,CAAC,SAAS,GAAG,yBAAyB,CAAC;yBAC/C;wBACD,IAAI,OAAO,CAAC,SAAS,GAAG,CAAC,IAAI,OAAO,CAAC,SAAS,GAAG,yBAAyB,EAAE;4BAC1E,MAAM,IAAI,UAAU,CAAC,0CAAwC,yBAA2B,CAAC,CAAC;yBAC3F;wBAED,IAAI,CAAC,OAAO,CAAC,eAAe,EAAE;4BAC5B,OAAO,CAAC,eAAe,GAAG,EAAE,CAAC;yBAC9B;wBAED,IAAI,CAAC,OAAO,CAAC,WAAW,EAAE;4BACxB,OAAO,CAAC,WAAW,GAAG,8BAA8B,CAAC;yBACtD;wBACD,IAAI,OAAO,CAAC,WAAW,GAAG,CAAC,EAAE;4BAC3B,MAAM,IAAI,UAAU,CAAC,yCAAyC,CAAC,CAAC;yBACjE;wBAED,kBAAkB;wBAClB,qBAAM,IAAI,CAAC,MAAM,CAAC,IAAI,EAAE;gCACtB,WAAW,EAAE,OAAO,CAAC,WAAW;gCAChC,eAAe,EAAE,OAAO,CAAC,eAAe;gCACxC,QAAQ,EAAE,OAAO,CAAC,QAAQ;gCAC1B,qBAAqB,EAAE,OAAO,CAAC,qBAAqB;gCACpD,cAAc,wBAAO,OAAQ,CAAC,cAAc,KAAE,WAAW,aAAA,GAAE;6BAC5D,CAAC,EAAA;;wBAPF,kBAAkB;wBAClB,SAME,CAAC;wBAEG,cAAoB,IAAI,CAAC,KAAK,CAAC,CAAC,IAAI,GAAG,CAAC,CAAC,GAAG,OAAO,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC;wBACrE,qBAA2B,CAAC,CAAC;wBAE3B,KAAK,GAAG,IAAI,KAAK,CAAC,OAAO,CAAC,WAAW,CAAC,CAAC;4CACpC,CAAC;4BACR,KAAK,CAAC,YAAY,CAChB;;;;;4CACQ,KAAK,GAAG,OAAO,CAAC,SAAU,GAAG,CAAC,CAAC;4CAC/B,GAAG,GAAG,CAAC,KAAK,WAAS,GAAG,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,KAAK,GAAG,OAAO,CAAC,SAAU,CAAC;4CAC9D,aAAa,GAAG,GAAG,GAAG,KAAK,CAAC;4CAClC,qBAAM,IAAI,CAAC,WAAW,CAAC,WAAW,CAAC,KAAK,EAAE,aAAa,CAAC,EAAE,KAAK,EAAE,aAAa,EAAE;oDAC9E,WAAW,EAAE,OAAO,CAAC,WAAW;oDAChC,qBAAqB,EAAE,OAAO,CAAC,qBAAqB;oDACpD,cAAc,wBAAO,OAAQ,CAAC,cAAc,KAAE,WAAW,aAAA,GAAE;iDAC5D,CAAC,EAAA;;4CAJF,SAIE,CAAC;4CACH,0FAA0F;4CAC1F,kEAAkE;4CAClE,kBAAgB,IAAI,aAAa,CAAC;4CAClC,IAAI,OAAO,CAAC,UAAU,EAAE;gDACtB,OAAO,CAAC,UAAU,CAAC,EAAE,WAAW,EAAE,kBAAgB,EAAE,CAAC,CAAC;6CACvD;;;;iCACF,CACF,CAAC;;wBAlBJ,KAAS,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,WAAS,EAAE,CAAC,EAAE;oCAAzB,CAAC;yBAmBT;wBACM,qBAAM,KAAK,CAAC,EAAE,EAAE,EAAA;4BAAvB,sBAAO,SAAgB,EAAC;;;wBAExB,IAAI,CAAC,SAAS,CAAC;4BACb,IAAI,EAAE,aAAa,CAAC,OAAO;4BAC3B,OAAO,EAAE,IAAC,CAAC,OAAO;yBACnB,CAAC,CAAC;wBACH,MAAM,IAAC,CAAC;;wBAER,IAAI,CAAC,GAAG,EAAE,CAAC;;;;;;KAEd;IAED;;;;;;;;;OASG;IACU,oCAAU,GAAvB,UACE,QAAgB,EAChB,OAAuC;QAAvC,wBAAA,EAAA,YAAuC;;;;;;wBAEjC,KAAwB,UAAU,CAAC,4BAA4B,EAAE,OAAO,CAAC,cAAc,CAAC,EAAtF,IAAI,UAAA,EAAE,WAAW,iBAAA,CAAsE;;;;wBAE/E,qBAAM,MAAM,CAAC,QAAQ,CAAC,EAAA;;wBAA9B,IAAI,GAAG,CAAC,SAAsB,CAAC,CAAC,IAAI;wBACnC,qBAAM,IAAI,CAAC,qBAAqB,CACrC,UAAC,MAAM,EAAE,KAAK;gCACZ,OAAA,kBAAkB,CAAC,QAAQ,EAAE;oCAC3B,SAAS,EAAE,IAAI;oCACf,GAAG,EAAE,KAAK,CAAC,CAAC,CAAC,MAAM,GAAG,KAAK,GAAG,CAAC,CAAC,CAAC,CAAC,QAAQ;oCAC1C,KAAK,EAAE,MAAM;iCACd,CAAC;4BAJF,CAIE,EACJ,IAAI,wBACC,OAAO,KAAE,cAAc,wBAAO,OAAQ,CAAC,cAAc,KAAE,WAAW,aAAA,OACxE,EAAA;4BATD,sBAAO,SASN,EAAC;;;wBAEF,IAAI,CAAC,SAAS,CAAC;4BACb,IAAI,EAAE,aAAa,CAAC,OAAO;4BAC3B,OAAO,EAAE,IAAC,CAAC,OAAO;yBACnB,CAAC,CAAC;wBACH,MAAM,IAAC,CAAC;;wBAER,IAAI,CAAC,GAAG,EAAE,CAAC;;;;;;KAEd;IAED;;;;;;;;;;;;;;OAcG;IACG,+CAAqB,GAA3B,UACE,aAAwE,EACxE,IAAY,EACZ,OAAuC;QAAvC,wBAAA,EAAA,YAAuC;;;;;;;wBAEjC,KAAwB,UAAU,CACtC,uCAAuC,EACvC,OAAO,CAAC,cAAc,CACvB,EAHO,IAAI,UAAA,EAAE,WAAW,iBAAA,CAGvB;;;;wBAEA,IAAI,CAAC,OAAO,CAAC,SAAS,EAAE;4BACtB,OAAO,CAAC,SAAS,GAAG,yBAAyB,CAAC;yBAC/C;wBACD,IAAI,OAAO,CAAC,SAAS,GAAG,CAAC,IAAI,OAAO,CAAC,SAAS,GAAG,yBAAyB,EAAE;4BAC1E,MAAM,IAAI,UAAU,CAAC,0CAAwC,yBAA2B,CAAC,CAAC;yBAC3F;wBAED,IAAI,CAAC,OAAO,CAAC,eAAe,EAAE;4BAC5B,OAAO,CAAC,eAAe,GAAG,EAAE,CAAC;yBAC9B;wBAED,IAAI,CAAC,OAAO,CAAC,WAAW,EAAE;4BACxB,OAAO,CAAC,WAAW,GAAG,8BAA8B,CAAC;yBACtD;wBACD,IAAI,OAAO,CAAC,WAAW,GAAG,CAAC,EAAE;4BAC3B,MAAM,IAAI,UAAU,CAAC,yCAAyC,CAAC,CAAC;yBACjE;wBAED,kBAAkB;wBAClB,qBAAM,IAAI,CAAC,MAAM,CAAC,IAAI,EAAE;gCACtB,WAAW,EAAE,OAAO,CAAC,WAAW;gCAChC,eAAe,EAAE,OAAO,CAAC,eAAe;gCACxC,QAAQ,EAAE,OAAO,CAAC,QAAQ;gCAC1B,qBAAqB,EAAE,OAAO,CAAC,qBAAqB;gCACpD,cAAc,wBAAO,OAAQ,CAAC,cAAc,KAAE,WAAW,aAAA,GAAE;6BAC5D,CAAC,EAAA;;wBAPF,kBAAkB;wBAClB,SAME,CAAC;wBAEG,cAAoB,IAAI,CAAC,KAAK,CAAC,CAAC,IAAI,GAAG,CAAC,CAAC,GAAG,OAAO,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC;wBACrE,qBAA2B,CAAC,CAAC;wBAC3B,KAAK,GAAG,IAAI,KAAK,CAAC,OAAO,CAAC,WAAW,CAAC,CAAC;4CAEpC,CAAC;4BACR,KAAK,CAAC,YAAY,CAChB;;;;;4CACQ,KAAK,GAAG,OAAO,CAAC,SAAU,GAAG,CAAC,CAAC;4CAC/B,GAAG,GAAG,CAAC,KAAK,WAAS,GAAG,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,KAAK,GAAG,OAAO,CAAC,SAAU,CAAC;4CAC9D,aAAa,GAAG,GAAG,GAAG,KAAK,CAAC;4CAClC,qBAAM,IAAI,CAAC,WAAW,CACpB,cAAM,OAAA,aAAa,CAAC,KAAK,EAAE,aAAa,CAAC,EAAnC,CAAmC,EACzC,KAAK,EACL,aAAa,EACb;oDACE,WAAW,EAAE,OAAO,CAAC,WAAW;oDAChC,qBAAqB,EAAE,OAAO,CAAC,qBAAqB;oDACpD,cAAc,wBAAO,OAAQ,CAAC,cAAc,KAAE,WAAW,aAAA,GAAE;iDAC5D,CACF,EAAA;;4CATD,SASC,CAAC;4CACF,0FAA0F;4CAC1F,kBAAgB,IAAI,aAAa,CAAC;4CAClC,IAAI,OAAO,CAAC,UAAU,EAAE;gDACtB,OAAO,CAAC,UAAU,CAAC,EAAE,WAAW,EAAE,kBAAgB,EAAE,CAAC,CAAC;6CACvD;;;;iCACF,CACF,CAAC;;wBAtBJ,KAAS,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,WAAS,EAAE,CAAC,EAAE;oCAAzB,CAAC;yBAuBT;wBACM,qBAAM,KAAK,CAAC,EAAE,EAAE,EAAA;4BAAvB,sBAAO,SAAgB,EAAC;;;wBAExB,IAAI,CAAC,SAAS,CAAC;4BACb,IAAI,EAAE,aAAa,CAAC,OAAO;4BAC3B,OAAO,EAAE,IAAC,CAAC,OAAO;yBACnB,CAAC,CAAC;wBACH,MAAM,IAAC,CAAC;;wBAER,IAAI,CAAC,GAAG,EAAE,CAAC;;;;;;KAEd;IAED;;;;;;;;;;OAUG;IACW,sCAAY,GAA1B,UACE,WAAsD,EACtD,IAAY,EACZ,OAAuC;QAAvC,wBAAA,EAAA,YAAuC;;;;;;;wBAEjC,KAAwB,UAAU,CACtC,8BAA8B,EAC9B,OAAO,CAAC,cAAc,CACvB,EAHO,IAAI,UAAA,EAAE,WAAW,iBAAA,CAGvB;;;;wBAEA,IAAI,CAAC,OAAO,CAAC,SAAS,EAAE;4BACtB,OAAO,CAAC,SAAS,GAAG,yBAAyB,CAAC;yBAC/C;wBACD,IAAI,OAAO,CAAC,SAAS,GAAG,CAAC,IAAI,OAAO,CAAC,SAAS,GAAG,yBAAyB,EAAE;4BAC1E,MAAM,IAAI,UAAU,CAAC,0CAAwC,yBAA2B,CAAC,CAAC;yBAC3F;wBAED,IAAI,CAAC,OAAO,CAAC,eAAe,EAAE;4BAC5B,OAAO,CAAC,eAAe,GAAG,EAAE,CAAC;yBAC9B;wBAED,IAAI,CAAC,OAAO,CAAC,WAAW,EAAE;4BACxB,OAAO,CAAC,WAAW,GAAG,8BAA8B,CAAC;yBACtD;wBACD,IAAI,OAAO,CAAC,WAAW,GAAG,CAAC,EAAE;4BAC3B,MAAM,IAAI,UAAU,CAAC,yCAAyC,CAAC,CAAC;yBACjE;wBAED,kBAAkB;wBAClB,qBAAM,IAAI,CAAC,MAAM,CAAC,IAAI,EAAE;gCACtB,WAAW,EAAE,OAAO,CAAC,WAAW;gCAChC,eAAe,EAAE,OAAO,CAAC,eAAe;gCACxC,QAAQ,EAAE,OAAO,CAAC,QAAQ;gCAC1B,qBAAqB,EAAE,OAAO,CAAC,qBAAqB;gCACpD,cAAc,wBAAO,OAAQ,CAAC,cAAc,KAAE,WAAW,aAAA,GAAE;6BAC5D,CAAC,EAAA;;wBAPF,kBAAkB;wBAClB,SAME,CAAC;wBAEG,cAAoB,IAAI,CAAC,KAAK,CAAC,CAAC,IAAI,GAAG,CAAC,CAAC,GAAG,OAAO,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC;wBACrE,qBAA2B,CAAC,CAAC;wBAC3B,KAAK,GAAG,IAAI,KAAK,CAAC,OAAO,CAAC,WAAW,CAAC,CAAC;4CAEpC,CAAC;4BACR,KAAK,CAAC,YAAY,CAChB;;;;;4CACQ,KAAK,GAAG,OAAO,CAAC,SAAU,GAAG,CAAC,CAAC;4CAC/B,GAAG,GAAG,CAAC,KAAK,WAAS,GAAG,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,KAAK,GAAG,OAAO,CAAC,SAAU,CAAC;4CAC9D,aAAa,GAAG,GAAG,GAAG,KAAK,CAAC;4CAClC,qBAAM,IAAI,CAAC,WAAW,CAAC,WAAW,CAAC,KAAK,EAAE,aAAa,CAAC,EAAE,KAAK,EAAE,aAAa,EAAE;oDAC9E,WAAW,EAAE,OAAO,CAAC,WAAW;oDAChC,qBAAqB,EAAE,OAAO,CAAC,qBAAqB;oDACpD,cAAc,wBAAO,OAAQ,CAAC,cAAc,KAAE,WAAW,aAAA,GAAE;iDAC5D,CAAC,EAAA;;4CAJF,SAIE,CAAC;4CACH,0FAA0F;4CAC1F,kBAAgB,IAAI,aAAa,CAAC;4CAClC,IAAI,OAAO,CAAC,UAAU,EAAE;gDACtB,OAAO,CAAC,UAAU,CAAC,EAAE,WAAW,EAAE,kBAAgB,EAAE,CAAC,CAAC;6CACvD;;;;iCACF,CACF,CAAC;;wBAjBJ,KAAS,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,WAAS,EAAE,CAAC,EAAE;oCAAzB,CAAC;yBAkBT;wBACM,qBAAM,KAAK,CAAC,EAAE,EAAE,EAAA;4BAAvB,sBAAO,SAAgB,EAAC;;;wBAExB,IAAI,CAAC,SAAS,CAAC;4BACb,IAAI,EAAE,aAAa,CAAC,OAAO;4BAC3B,OAAO,EAAE,IAAC,CAAC,OAAO;yBACnB,CAAC,CAAC;wBACH,MAAM,IAAC,CAAC;;wBAER,IAAI,CAAC,GAAG,EAAE,CAAC;;;;;;KAEd;IA8CY,0CAAgB,GAA7B,UACE,cAAgC,EAChC,aAAsB,EACtB,cAAqD,EACrD,UAA4C;QAA5C,2BAAA,EAAA,eAA4C;;;;;;;wBAExC,MAAM,GAAuB,SAAS,CAAC;wBAGvC,OAAO,GAAgC,UAAU,CAAC;wBAEtD,IAAI,cAAc,YAAY,MAAM,EAAE;4BACpC,MAAM,GAAG,cAAc,CAAC;4BACxB,MAAM,GAAG,aAAa,IAAI,CAAC,CAAC;4BAC5B,KAAK,GAAG,OAAO,cAAc,KAAK,QAAQ,CAAC,CAAC,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC,CAAC;yBACjE;6BAAM;4BACL,MAAM,GAAG,OAAO,cAAc,KAAK,QAAQ,CAAC,CAAC,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC,CAAC;4BACjE,KAAK,GAAG,OAAO,aAAa,KAAK,QAAQ,CAAC,CAAC,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC,CAAC;4BAC9D,OAAO,GAAI,cAA8C,IAAI,EAAE,CAAC;yBACjE;wBAEK,KAAwB,UAAU,CACtC,kCAAkC,EAClC,OAAO,CAAC,cAAc,CACvB,EAHO,IAAI,UAAA,EAAE,WAAW,iBAAA,CAGvB;;;;wBAGA,IAAI,CAAC,OAAO,CAAC,SAAS,EAAE;4BACtB,OAAO,CAAC,SAAS,GAAG,yBAAyB,CAAC;yBAC/C;wBACD,IAAI,OAAO,CAAC,SAAS,GAAG,CAAC,EAAE;4BACzB,MAAM,IAAI,UAAU,CAAC,8BAA8B,CAAC,CAAC;yBACtD;wBAED,IAAI,MAAM,GAAG,CAAC,EAAE;4BACd,MAAM,IAAI,UAAU,CAAC,4BAA4B,CAAC,CAAC;yBACpD;wBAED,IAAI,KAAK,IAAI,KAAK,IAAI,CAAC,EAAE;4BACvB,MAAM,IAAI,UAAU,CAAC,0BAA0B,CAAC,CAAC;yBAClD;wBAED,IAAI,CAAC,OAAO,CAAC,WAAW,EAAE;4BACxB,OAAO,CAAC,WAAW,GAAG,8BAA8B,CAAC;yBACtD;wBACD,IAAI,OAAO,CAAC,WAAW,GAAG,CAAC,EAAE;4BAC3B,MAAM,IAAI,UAAU,CAAC,yCAAyC,CAAC,CAAC;yBACjE;6BAGG,CAAC,KAAK,EAAN,wBAAM;wBACS,qBAAM,IAAI,CAAC,aAAa,CAAC;gCACxC,WAAW,EAAE,OAAO,CAAC,WAAW;gCAChC,qBAAqB,EAAE,OAAO,CAAC,qBAAqB;gCACpD,cAAc,wBAAO,OAAQ,CAAC,cAAc,KAAE,WAAW,aAAA,GAAE;6BAC5D,CAAC,EAAA;;wBAJI,QAAQ,GAAG,SAIf;wBACF,KAAK,GAAG,QAAQ,CAAC,aAAc,GAAG,MAAM,CAAC;wBACzC,IAAI,KAAK,GAAG,CAAC,EAAE;4BACb,MAAM,IAAI,UAAU,CAClB,YAAU,MAAM,4CAAuC,QAAQ,CAAC,aAAgB,CACjF,CAAC;yBACH;;;wBAGH,IAAI,CAAC,MAAM,EAAE;4BACX,IAAI;gCACF,MAAM,GAAG,MAAM,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;6BAC9B;4BAAC,OAAO,KAAK,EAAE;gCACd,MAAM,IAAI,KAAK,CACb,0CAAwC,KAAK,mDAAgD;oCAC3F,8FAA8F;qCAC9F,QAAM,KAAK,CAAC,OAAS,CAAA,CACxB,CAAC;6BACH;yBACF;wBAED,IAAI,MAAM,CAAC,MAAM,GAAG,KAAK,EAAE;4BACzB,MAAM,IAAI,UAAU,CAClB,qFAAmF,KAAO,CAC3F,CAAC;yBACH;wBAEG,qBAA2B,CAAC,CAAC;wBAC3B,KAAK,GAAG,IAAI,KAAK,CAAC,OAAO,CAAC,WAAW,CAAC,CAAC;4CACpC,GAAG;4BACV,KAAK,CAAC,YAAY,CAAC;;;;;4CAEb,QAAQ,GAAG,MAAM,GAAG,KAAM,CAAC;4CAC/B,IAAI,GAAG,GAAG,OAAO,CAAC,SAAU,GAAG,QAAQ,EAAE;gDACvC,QAAQ,GAAG,GAAG,GAAG,OAAO,CAAC,SAAU,CAAC;6CACrC;4CACgB,qBAAM,IAAI,CAAC,QAAQ,CAAC,GAAG,EAAE,QAAQ,GAAG,GAAG,EAAE;oDACxD,WAAW,EAAE,OAAO,CAAC,WAAW;oDAChC,gBAAgB,EAAE,OAAO,CAAC,wBAAwB;oDAClD,qBAAqB,EAAE,OAAO,CAAC,qBAAqB;oDACpD,cAAc,wBAAO,OAAQ,CAAC,cAAc,KAAE,WAAW,aAAA,GAAE;iDAC5D,CAAC,EAAA;;4CALI,QAAQ,GAAG,SAKf;4CACI,MAAM,GAAG,QAAQ,CAAC,kBAAmB,CAAC;4CAC5C,qBAAM,cAAc,CAAC,MAAM,EAAE,MAAO,EAAE,GAAG,GAAG,MAAM,EAAE,QAAQ,GAAG,MAAM,CAAC,EAAA;;4CAAtE,SAAsE,CAAC;4CACvE,qEAAqE;4CACrE,sEAAsE;4CACtE,oDAAoD;4CACpD,kBAAgB,IAAI,QAAQ,GAAG,GAAG,CAAC;4CACnC,IAAI,OAAO,CAAC,UAAU,EAAE;gDACtB,OAAO,CAAC,UAAU,CAAC,EAAE,WAAW,EAAE,kBAAgB,EAAE,CAAC,CAAC;6CACvD;;;;iCACF,CAAC,CAAC;;wBAtBL,KAAS,GAAG,GAAG,MAAM,EAAE,GAAG,GAAG,MAAM,GAAG,KAAK,EAAE,GAAG,GAAG,GAAG,GAAG,OAAO,CAAC,SAAS;oCAAjE,GAAG;yBAuBX;wBACD,qBAAM,KAAK,CAAC,EAAE,EAAE,EAAA;;wBAAhB,SAAgB,CAAC;wBACjB,sBAAO,MAAM,EAAC;;;wBAEd,IAAI,CAAC,SAAS,CAAC;4BACb,IAAI,EAAE,aAAa,CAAC,OAAO;4BAC3B,OAAO,EAAE,IAAC,CAAC,OAAO;yBACnB,CAAC,CAAC;wBACH,MAAM,IAAC,CAAC;;wBAER,IAAI,CAAC,GAAG,EAAE,CAAC;;;;;;KAEd;IAED;;;;;;;;;;;;;;;;;;;;;OAqBG;IACU,sCAAY,GAAzB,UACE,MAAgB,EAChB,IAAY,EACZ,UAAkB,EAClB,UAAkB,EAClB,OAAqC;QAArC,wBAAA,EAAA,YAAqC;;;;;;;wBAE/B,KAAwB,UAAU,CACtC,8BAA8B,EAC9B,OAAO,CAAC,cAAc,CACvB,EAHO,IAAI,UAAA,EAAE,WAAW,iBAAA,CAGvB;;;;wBAEA,IAAI,CAAC,OAAO,CAAC,eAAe,EAAE;4BAC5B,OAAO,CAAC,eAAe,GAAG,EAAE,CAAC;yBAC9B;wBAED,IAAI,UAAU,IAAI,CAAC,IAAI,UAAU,GAAG,yBAAyB,EAAE;4BAC7D,MAAM,IAAI,UAAU,CAAC,mCAAiC,yBAA2B,CAAC,CAAC;yBACpF;wBAED,IAAI,UAAU,GAAG,CAAC,EAAE;4BAClB,MAAM,IAAI,UAAU,CAAC,yBAAyB,CAAC,CAAC;yBACjD;wBAED,kBAAkB;wBAClB,qBAAM,IAAI,CAAC,MAAM,CAAC,IAAI,EAAE;gCACtB,WAAW,EAAE,OAAO,CAAC,WAAW;gCAChC,eAAe,EAAE,OAAO,CAAC,eAAe;gCACxC,QAAQ,EAAE,OAAO,CAAC,QAAQ;gCAC1B,qBAAqB,EAAE,OAAO,CAAC,qBAAqB;gCACpD,cAAc,wBAAO,OAAQ,CAAC,cAAc,KAAE,WAAW,aAAA,GAAE;6BAC5D,CAAC,EAAA;;wBAPF,kBAAkB;wBAClB,SAME,CAAC;wBAEC,qBAA2B,CAAC,CAAC;wBAC3B,SAAS,GAAG,IAAI,eAAe,CACnC,MAAM,EACN,UAAU,EACV,UAAU,EACV,UAAO,MAAc,EAAE,MAAe;;;;wCACpC,IAAI,kBAAgB,GAAG,MAAM,CAAC,MAAM,GAAG,IAAI,EAAE;4CAC3C,MAAM,IAAI,UAAU,CAClB,0CAAwC,IAAI,+BAA4B;gDACtE,iEAAiE,CACpE,CAAC;yCACH;wCAED,qBAAM,IAAI,CAAC,WAAW,CAAC,MAAM,EAAE,MAAO,EAAE,MAAM,CAAC,MAAM,EAAE;gDACrD,WAAW,EAAE,OAAO,CAAC,WAAW;gDAChC,qBAAqB,EAAE,OAAO,CAAC,qBAAqB;gDACpD,cAAc,wBAAO,OAAQ,CAAC,cAAc,KAAE,WAAW,aAAA,GAAE;6CAC5D,CAAC,EAAA;;wCAJF,SAIE,CAAC;wCAEH,0FAA0F;wCAC1F,kBAAgB,IAAI,MAAM,CAAC,MAAM,CAAC;wCAClC,IAAI,OAAO,CAAC,UAAU,EAAE;4CACtB,OAAO,CAAC,UAAU,CAAC,EAAE,WAAW,EAAE,kBAAgB,EAAE,CAAC,CAAC;yCACvD;;;;6BACF;wBACD,8EAA8E;wBAC9E,2EAA2E;wBAC3E,iDAAiD;wBACjD,qCAAqC;wBACrC,IAAI,CAAC,IAAI,CAAC,CAAC,UAAU,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,CAChC,CAAC;wBACK,qBAAM,SAAS,CAAC,EAAE,EAAE,EAAA;4BAA3B,sBAAO,SAAoB,EAAC;;;wBAE5B,IAAI,CAAC,SAAS,CAAC;4BACb,IAAI,EAAE,aAAa,CAAC,OAAO;4BAC3B,OAAO,EAAE,IAAC,CAAC,OAAO;yBACnB,CAAC,CAAC;wBACH,MAAM,IAAC,CAAC;;wBAER,IAAI,CAAC,GAAG,EAAE,CAAC;;;;;;KAEd;IAED;;;;;;;;;;;;;;;;OAgBG;IACU,wCAAc,GAA3B,UACE,QAAgB,EAChB,MAAkB,EAClB,KAAc,EACd,OAAiC;QAFjC,uBAAA,EAAA,UAAkB;QAElB,wBAAA,EAAA,YAAiC;;;;;;wBAE3B,KAAwB,UAAU,CACtC,gCAAgC,EAChC,OAAO,CAAC,cAAc,CACvB,EAHO,IAAI,UAAA,EAAE,WAAW,iBAAA,CAGvB;;;;wBAEiB,qBAAM,IAAI,CAAC,QAAQ,CAAC,MAAM,EAAE,KAAK,wBAC7C,OAAO,KACV,cAAc,wBAAO,OAAQ,CAAC,cAAc,KAAE,WAAW,aAAA,OACzD,EAAA;;wBAHI,QAAQ,GAAG,SAGf;6BACE,QAAQ,CAAC,kBAAkB,EAA3B,wBAA2B;wBAC7B,qBAAM,qBAAqB,CAAC,QAAQ,CAAC,kBAAkB,EAAE,QAAQ,CAAC,EAAA;;wBAAlE,SAAkE,CAAC;;;wBAGrE,iEAAiE;wBAChE,QAAgB,CAAC,kBAAkB,GAAG,SAAS,CAAC;wBACjD,sBAAO,QAAQ,EAAC;;;wBAEhB,IAAI,CAAC,SAAS,CAAC;4BACb,IAAI,EAAE,aAAa,CAAC,OAAO;4BAC3B,OAAO,EAAE,IAAC,CAAC,OAAO;yBACnB,CAAC,CAAC;wBACH,MAAM,IAAC,CAAC;;wBAER,IAAI,CAAC,GAAG,EAAE,CAAC;;;;;;KAEd;IAED;;;;;;;;;;;;OAYG;IACW,4CAAkB,GAAhC,UACE,MAAe,EACf,OAA2C;QAA3C,wBAAA,EAAA,YAA2C;;;;;;wBAErC,KAAwB,UAAU,CACtC,oCAAoC,EACpC,OAAO,CAAC,cAAc,CACvB,EAHO,IAAI,UAAA,EAAE,WAAW,iBAAA,CAGvB;;;;wBAEA,MAAM,GAAG,MAAM,KAAK,EAAE,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,MAAM,CAAC;wBAC3B,qBAAM,IAAI,CAAC,OAAO,CAAC,WAAW,qBAC7C,WAAW,EAAE,OAAO,CAAC,WAAW,EAChC,MAAM,QAAA,IACH,OAAO,KACV,WAAW,aAAA,IACX,EAAA;;wBALI,QAAQ,GAAG,SAKf;wBAEF,sEAAsE;wBACtE,yCAAyC;wBACzC,IAAK,QAAQ,CAAC,UAAkB,KAAK,EAAE,EAAE;4BACvC,QAAQ,CAAC,UAAU,GAAG,SAAS,CAAC;yBACjC;wBACD,sBAAO,QAAQ,EAAC;;;wBAEhB,IAAI,CAAC,SAAS,CAAC;4BACb,IAAI,EAAE,aAAa,CAAC,OAAO;4BAC3B,OAAO,EAAE,IAAC,CAAC,OAAO;yBACnB,CAAC,CAAC;wBACH,MAAM,IAAC,CAAC;;wBAER,IAAI,CAAC,GAAG,EAAE,CAAC;;;;;;KAEd;IAED;;;;;;;;;;;;OAYG;IACY,+CAAqB,GAApC,UACE,MAAe,EACf,OAA2C;QAA3C,wBAAA,EAAA,YAA2C;;;;;;6BAGvC,CAAA,CAAC,CAAC,MAAM,IAAI,MAAM,KAAK,SAAS,CAAA,EAAhC,wBAAgC;;4BAEV,6BAAM,IAAI,CAAC,kBAAkB,CAAC,MAAM,EAAE,OAAO,CAAC,GAAA;;wBAApE,mBAAmB,GAAG,SAA8C,CAAC;wBACrE,MAAM,GAAG,mBAAmB,CAAC,iBAAiB,CAAC;qDACzC,mBAAmB;4BAAzB,gCAAyB;;wBAAzB,SAAyB,CAAC;;;4BACnB,MAAM;;;;;;KAElB;IAED;;;;;;;OAOG;IACY,yCAAe,GAA9B,UACE,OAA2C;QAA3C,wBAAA,EAAA,YAA2C;;;;;;;;wBAGH,KAAA,cAAA,IAAI,CAAC,qBAAqB,CAAC,MAAM,EAAE,OAAO,CAAC,CAAA;;;;;wBAAlE,mBAAmB,WAAA,CAAA;6BAC9B,mBAAmB,CAAC,UAAU,EAA9B,wBAA8B;8BACmB,EAA9B,KAAA,mBAAmB,CAAC,UAAU;;;6BAA9B,CAAA,cAA8B,CAAA;wBAAxC,MAAM;qDACT,MAAM;4BAAZ,gCAAY;;wBAAZ,SAAY,CAAC;;;wBADM,IAA8B,CAAA;;;;;;;;;;;;;;;;;;;;;;;;KAKxD;IAED;;;;;;;;;;OAUG;IACI,qCAAW,GAAlB,UACE,OAAoC;;QADtC,iBA4BC;QA3BC,wBAAA,EAAA,YAAoC;QAEpC,mDAAmD;QACnD,IAAM,IAAI,GAAG,IAAI,CAAC,eAAe,CAAC,OAAO,CAAC,CAAC;QAC3C;gBACE;;mBAEG;gBACG,IAAI;;;4BACR,sBAAO,IAAI,CAAC,IAAI,EAAE,EAAC;;;iBACpB;;YACD;;eAEG;YACH,GAAC,MAAM,CAAC,aAAa,IAArB;gBACE,OAAO,IAAI,CAAC;YACd,CAAC;YACD;;eAEG;YACH,SAAM,GAAE,UAAC,QAA2B;gBAA3B,yBAAA,EAAA,aAA2B;gBAClC,OAAO,KAAI,CAAC,qBAAqB,CAAC,QAAQ,CAAC,iBAAiB,aAC1D,WAAW,EAAE,QAAQ,CAAC,WAAW,IAC9B,OAAO,EACV,CAAC;YACL,CAAC;eACD;IACJ,CAAC;IAED;;;;;;;;;;;;OAYG;IACW,kDAAwB,GAAtC,UACE,MAAe,EACf,OAA0C;QAA1C,wBAAA,EAAA,YAA0C;;;;;;wBAEpC,KAAwB,UAAU,CACtC,0CAA0C,EAC1C,OAAO,CAAC,cAAc,CACvB,EAHO,IAAI,UAAA,EAAE,WAAW,iBAAA,CAGvB;;;;wBAEA,MAAM,GAAG,MAAM,KAAK,EAAE,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,MAAM,CAAC;wBACxB,qBAAM,IAAI,CAAC,OAAO,CAAC,iBAAiB,CAAC,GAAG,EAAE;gCAC5D,WAAW,EAAE,OAAO,CAAC,WAAW;gCAChC,MAAM,QAAA;gCACN,WAAW,aAAA;6BACZ,CAAC,EAAA;;wBAJI,WAAW,GAAG,SAIlB;wBACI,QAAQ,GAAG,WAA4C,CAAC;wBAC9D,QAAQ,CAAC,kBAAkB,GAAG,WAAW,CAAC,qBAAqB,IAAI,CAAC,CAAC;wBACrE,QAAQ,CAAC,iBAAiB,GAAG,WAAW,CAAC,4BAA4B,IAAI,CAAC,CAAC;wBAC3E,sBAAO,QAAQ,EAAC;;;wBAEhB,IAAI,CAAC,SAAS,CAAC;4BACb,IAAI,EAAE,aAAa,CAAC,OAAO;4BAC3B,OAAO,EAAE,IAAC,CAAC,OAAO;yBACnB,CAAC,CAAC;wBACH,MAAM,IAAC,CAAC;;wBAER,IAAI,CAAC,GAAG,EAAE,CAAC;;;;;;KAEd;IAED;;;;;;;OAOG;IACU,8CAAoB,GAAjC,UACE,OAA0C;QAA1C,wBAAA,EAAA,YAA0C;;;;;;wBAEpC,KAAwB,UAAU,CACtC,sCAAsC,EACtC,OAAO,CAAC,cAAc,CACvB,EAHO,IAAI,UAAA,EAAE,WAAW,iBAAA,CAGvB;;;;wBAEI,aAAa,GAAG,CAAC,CAAC;wBAClB,4BAA4B,GAAG,CAAC,CAAC;wBACjC,MAAM,GAAuB,EAAE,CAAC;;4BAGc,qBAAM,IAAI,CAAC,wBAAwB,CACjF,MAAM,EACN,EAAE,cAAc,wBAAO,OAAQ,CAAC,cAAc,KAAE,WAAW,aAAA,GAAE,EAAE,CAChE,EAAA;;wBAHK,QAAQ,GAAkC,SAG/C;wBACD,MAAM,GAAG,QAAQ,CAAC,MAAM,CAAC;wBACzB,QAAQ,CAAC,kBAAkB,IAAI,CAAC,aAAa,IAAI,QAAQ,CAAC,kBAAkB,CAAC,CAAC;wBAC9E,QAAQ,CAAC,iBAAiB,IAAI,CAAC,4BAA4B,IAAI,QAAQ,CAAC,iBAAiB,CAAC,CAAC;;;4BACpF,MAAM;;4BAEf,sBAAO;4BACL,kBAAkB,EAAE,aAAa;4BACjC,iBAAiB,EAAE,4BAA4B;yBAChD,EAAC;;;wBAEF,IAAI,CAAC,SAAS,CAAC;4BACb,IAAI,EAAE,aAAa,CAAC,OAAO;4BAC3B,OAAO,EAAE,IAAC,CAAC,OAAO;yBACnB,CAAC,CAAC;wBACH,MAAM,IAAC,CAAC;;wBAER,IAAI,CAAC,GAAG,EAAE,CAAC;;;;;;KAEd;IAED;;;;;;;;;OASG;IACU,0CAAgB,GAA7B,UACE,QAAgB,EAChB,OAA0C;QAA1C,wBAAA,EAAA,YAA0C;;;;;;wBAEpC,KAAwB,UAAU,CACtC,kCAAkC,EAClC,OAAO,CAAC,cAAc,CACvB,EAHO,IAAI,UAAA,EAAE,WAAW,iBAAA,CAGvB;;;;wBAEA,IAAI,QAAQ,KAAK,GAAG,EAAE;4BACpB,MAAM,IAAI,UAAU,CAClB,0GAA0G,CAC3G,CAAC;yBACH;wBAEmB,qBAAM,IAAI,CAAC,OAAO,CAAC,iBAAiB,CAAC,QAAQ,EAAE;gCACjE,WAAW,EAAE,OAAO,CAAC,WAAW;gCAChC,WAAW,aAAA;6BACZ,CAAC,EAAA;;wBAHI,WAAW,GAAG,SAGlB;wBACI,QAAQ,GAAG,WAA4C,CAAC;wBAC9D,QAAQ,CAAC,kBAAkB,GAAG,WAAW,CAAC,qBAAqB,IAAI,CAAC,CAAC;wBACrE,QAAQ,CAAC,iBAAiB,GAAG,WAAW,CAAC,4BAA4B,IAAI,CAAC,CAAC;wBAC3E,sBAAO,QAAQ,EAAC;;;wBAEhB,IAAI,CAAC,SAAS,CAAC;4BACb,IAAI,EAAE,aAAa,CAAC,OAAO;4BAC3B,OAAO,EAAE,IAAC,CAAC,OAAO;yBACnB,CAAC,CAAC;wBACH,MAAM,IAAC,CAAC;;wBAER,IAAI,CAAC,GAAG,EAAE,CAAC;;;;;;KAEd;IAED;;;;;;OAMG;IACI,6CAAmB,GAA1B,UAA2B,cAAuB;QAChD,OAAO,IAAI,gBAAgB,CAAC,IAAI,EAAE,cAAc,CAAC,CAAC;IACpD,CAAC;IACH,sBAAC;AAAD,CAAC,AAv1DD,CAAqC,aAAa,GAu1DjD;;AAyED;;;;;GAKG;AACH;IA0BE;;;;;OAKG;IACH,0BAAY,MAAuB,EAAE,OAAgB;QACnD,IAAM,aAAa,GAAG,IAAI,oBAAoB,CAC5C,eAAe,EACf,MAAM,CAAC,GAAG,EACT,MAAc,CAAC,QAAQ,CAAC,sBAAsB,EAAE,CAClD,CAAC;QACF,IAAI,CAAC,KAAK,GAAG,IAAI,IAAI,CAAC,aAAa,CAAC,CAAC;QAErC,IAAI,CAAC,IAAI,GAAG,MAAM,CAAC,GAAG,CAAC;QAEvB,IAAI,CAAC,OAAO,EAAE;YACZ,OAAO,GAAG,YAAY,EAAE,CAAC;SAC1B;QACD,IAAI,CAAC,QAAQ,GAAG,OAAO,CAAC;IAC1B,CAAC;IAnCD,sBAAW,qCAAO;QAPlB;;;;;;WAMG;aACH;YACE,OAAO,IAAI,CAAC,QAAQ,CAAC;QACvB,CAAC;;;OAAA;IASD,sBAAW,iCAAG;QAPd;;;;;;WAMG;aACH;YACE,OAAO,IAAI,CAAC,IAAI,CAAC;QACnB,CAAC;;;OAAA;IAwBD;;;;;;;OAOG;IACU,uCAAY,GAAzB,UACE,QAAa,EACb,OAAmC;QADnC,yBAAA,EAAA,YAAY,CAAC;QACb,wBAAA,EAAA,YAAmC;;;;;;wBAE7B,KAAwB,UAAU,CACtC,+BAA+B,EAC/B,OAAO,CAAC,cAAc,CACvB,EAHO,IAAI,UAAA,EAAE,WAAW,iBAAA,CAGvB;;;;wBAEO,qBAAM,IAAI,CAAC,KAAK,CAAC,YAAY,CAAC;gCACnC,WAAW,EAAE,OAAO,CAAC,WAAW;gCAChC,QAAQ,UAAA;gCACR,eAAe,EAAE,IAAI,CAAC,QAAQ;gCAC9B,WAAW,aAAA;6BACZ,CAAC,EAAA;4BALF,sBAAO,SAKL,EAAC;;;wBAEH,IAAI,CAAC,SAAS,CAAC;4BACb,IAAI,EAAE,aAAa,CAAC,OAAO;4BAC3B,OAAO,EAAE,IAAC,CAAC,OAAO;yBACnB,CAAC,CAAC;wBACH,MAAM,IAAC,CAAC;;wBAER,IAAI,CAAC,GAAG,EAAE,CAAC;;;;;;KAEd;IAED;;;;;;;OAOG;IACU,sCAAW,GAAxB,UACE,eAAuB,EACvB,OAAmC;QAAnC,wBAAA,EAAA,YAAmC;;;;;;wBAE7B,KAAwB,UAAU,CACtC,8BAA8B,EAC9B,OAAO,CAAC,cAAc,CACvB,EAHO,IAAI,UAAA,EAAE,WAAW,iBAAA,CAGvB;;;;wBAEiB,qBAAM,IAAI,CAAC,KAAK,CAAC,WAAW,CAAC,IAAI,CAAC,QAAQ,EAAE;gCAC3D,eAAe,iBAAA;gCACf,WAAW,EAAE,OAAO,CAAC,WAAW;gCAChC,WAAW,aAAA;6BACZ,CAAC,EAAA;;wBAJI,QAAQ,GAAG,SAIf;wBACF,IAAI,CAAC,QAAQ,GAAG,eAAe,CAAC;wBAChC,sBAAO,QAAQ,EAAC;;;wBAEhB,IAAI,CAAC,SAAS,CAAC;4BACb,IAAI,EAAE,aAAa,CAAC,OAAO;4BAC3B,OAAO,EAAE,IAAC,CAAC,OAAO;yBACnB,CAAC,CAAC;wBACH,MAAM,IAAC,CAAC;;wBAER,IAAI,CAAC,GAAG,EAAE,CAAC;;;;;;KAEd;IAED;;;;;;;OAOG;IACU,uCAAY,GAAzB,UAA0B,OAAmC;QAAnC,wBAAA,EAAA,YAAmC;;;;;;wBACrD,KAAwB,UAAU,CACtC,+BAA+B,EAC/B,OAAO,CAAC,cAAc,CACvB,EAHO,IAAI,UAAA,EAAE,WAAW,iBAAA,CAGvB;;;;wBAEO,qBAAM,IAAI,CAAC,KAAK,CAAC,YAAY,CAAC,IAAI,CAAC,QAAQ,EAAE;gCAClD,WAAW,EAAE,OAAO,CAAC,WAAW;gCAChC,WAAW,aAAA;6BACZ,CAAC,EAAA;4BAHF,sBAAO,SAGL,EAAC;;;wBAEH,IAAI,CAAC,SAAS,CAAC;4BACb,IAAI,EAAE,aAAa,CAAC,OAAO;4BAC3B,OAAO,EAAE,IAAC,CAAC,OAAO;yBACnB,CAAC,CAAC;wBACH,MAAM,IAAC,CAAC;;wBAER,IAAI,CAAC,GAAG,EAAE,CAAC;;;;;;KAEd;IAED;;;;;;OAMG;IACU,qCAAU,GAAvB,UAAwB,OAAmC;QAAnC,wBAAA,EAAA,YAAmC;;;;;;wBACnD,KAAwB,UAAU,CAAC,6BAA6B,EAAE,OAAO,CAAC,cAAc,CAAC,EAAvF,IAAI,UAAA,EAAE,WAAW,iBAAA,CAAuE;;;;wBAEvF,qBAAM,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC;gCACjC,WAAW,EAAE,OAAO,CAAC,WAAW;gCAChC,WAAW,aAAA;6BACZ,CAAC,EAAA;4BAHF,sBAAO,SAGL,EAAC;;;wBAEH,IAAI,CAAC,SAAS,CAAC;4BACb,IAAI,EAAE,aAAa,CAAC,OAAO;4BAC3B,OAAO,EAAE,IAAC,CAAC,OAAO;yBACnB,CAAC,CAAC;wBACH,MAAM,IAAC,CAAC;;wBAER,IAAI,CAAC,GAAG,EAAE,CAAC;;;;;;KAEd;IACH,uBAAC;AAAD,CAAC,AA1KD,IA0KC","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { HttpRequestBody, HttpResponse, isNode, TransferProgressEvent } from \"@azure/core-http\";\nimport { CanonicalCode } from \"@opentelemetry/api\";\nimport { AbortSignalLike } from \"@azure/abort-controller\";\nimport { FileDownloadResponse } from \"./FileDownloadResponse\";\nimport {\n  FileAbortCopyResponse,\n  FileCreateResponse,\n  FileDeleteResponse,\n  FileDownloadOptionalParams,\n  FileDownloadResponseModel,\n  FileGetPropertiesResponse,\n  FileGetRangeListHeaders,\n  FileListHandlesResponse,\n  FileSetHTTPHeadersResponse,\n  FileSetMetadataResponse,\n  FileStartCopyResponse,\n  SourceModifiedAccessConditions,\n  FileUploadRangeFromURLResponse,\n  FileUploadRangeResponse,\n  HandleItem,\n  RangeModel,\n  FileForceCloseHandlesHeaders,\n  CopyFileSmbInfo,\n  LeaseAccessConditions\n} from \"./generatedModels\";\nimport { File } from \"./generated/src/operations\";\nimport { Range, rangeToString } from \"./Range\";\nimport {\n  FileHttpHeaders,\n  Metadata,\n  FileAndDirectoryCreateCommonOptions,\n  FileAndDirectorySetPropertiesCommonOptions,\n  fileAttributesToString,\n  fileCreationTimeToString,\n  fileLastWriteTimeToString,\n  validateAndSetDefaultsForFileAndDirectoryCreateCommonOptions,\n  validateAndSetDefaultsForFileAndDirectorySetPropertiesCommonOptions,\n  CloseHandlesInfo\n} from \"./models\";\nimport { newPipeline, StoragePipelineOptions, Pipeline } from \"./Pipeline\";\nimport { StorageClient, CommonOptions } from \"./StorageClient\";\nimport {\n  DEFAULT_MAX_DOWNLOAD_RETRY_REQUESTS,\n  FILE_MAX_SIZE_BYTES,\n  FILE_RANGE_MAX_SIZE_BYTES,\n  DEFAULT_HIGH_LEVEL_CONCURRENCY\n} from \"./utils/constants\";\nimport \"@azure/core-paging\";\nimport { PageSettings, PagedAsyncIterableIterator } from \"@azure/core-paging\";\nimport { Credential } from \"./credentials/Credential\";\nimport { Batch } from \"./utils/Batch\";\nimport { BufferScheduler } from \"./utils/BufferScheduler\";\nimport { Readable } from \"stream\";\nimport { AnonymousCredential } from \"./credentials/AnonymousCredential\";\nimport {\n  readStreamToLocalFile,\n  streamToBuffer,\n  fsStat,\n  fsCreateReadStream\n} from \"./utils/utils.node\";\nimport { FileSystemAttributes } from \"./FileSystemAttributes\";\nimport { getShareNameAndPathFromUrl } from \"./utils/utils.common\";\nimport { createSpan } from \"./utils/tracing\";\nimport { StorageClientContext } from \"./generated/src/storageClientContext\";\nimport { SERVICE_VERSION } from \"./utils/constants\";\nimport { generateUuid } from \"@azure/core-http\";\n\n/**\n * Options to configure the {@link ShareFileClient.create} operation.\n *\n * @export\n * @interface FileCreateOptions\n */\nexport interface FileCreateOptions extends FileAndDirectoryCreateCommonOptions, CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   *\n   * @type {AbortSignalLike}\n   * @memberof FileCreateOptions\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * File HTTP headers like Content-Type.\n   *\n   * @type {FileHttpHeaders}\n   * @memberof FileCreateOptions\n   */\n  fileHttpHeaders?: FileHttpHeaders;\n\n  /**\n   * A collection of key-value string pair to associate with the file storage object.\n   *\n   * @type {Metadata}\n   * @memberof FileCreateOptions\n   */\n  metadata?: Metadata;\n  /**\n   * Lease access conditions.\n   *\n   * @type {LeaseAccessConditions}\n   * @memberof FileCreateOptions\n   */\n  leaseAccessConditions?: LeaseAccessConditions;\n}\n\nexport interface FileProperties extends FileAndDirectorySetPropertiesCommonOptions, CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   *\n   * @type {AbortSignalLike}\n   * @memberof FileProperties\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * File HTTP headers like Content-Type.\n   *\n   * @type {FileHttpHeaders}\n   * @memberof FileProperties\n   */\n  fileHttpHeaders?: FileHttpHeaders;\n  /**\n   * Lease access conditions.\n   *\n   * @type {LeaseAccessConditions}\n   * @memberof FileProperties\n   */\n  leaseAccessConditions?: LeaseAccessConditions;\n}\n\nexport interface SetPropertiesResponse extends FileSetHTTPHeadersResponse {}\n\n/**\n * Options to configure the {@link ShareFileClient.delete} operation.\n *\n * @export\n * @interface FileDeleteOptions\n */\nexport interface FileDeleteOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   *\n   * @type {AbortSignalLike}\n   * @memberof FileDeleteOptions\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * Lease access conditions.\n   *\n   * @type {LeaseAccessConditions}\n   * @memberof FileDeleteOptions\n   */\n  leaseAccessConditions?: LeaseAccessConditions;\n}\n\n/**\n * Options to configure File - Download operations.\n *\n * See:\n * - {@link ShareFileClient.download}\n * - {@link ShareFileClient.downloadToFile}\n *\n * @export\n * @interface FileDownloadOptions\n */\nexport interface FileDownloadOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   *\n   * @type {AbortSignalLike}\n   * @memberof FileDownloadOptions\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * Optional. ONLY AVAILABLE IN NODE.JS.\n   *\n   * How many retries will perform when original body download stream unexpected ends.\n   * Above kind of ends will not trigger retry policy defined in a pipeline,\n   * because they doesn't emit network errors.\n   *\n   * With this option, every additional retry means an additional ShareFileClient.download() request will be made\n   * from the broken point, until the requested range has been successfully downloaded or maxRetryRequests is reached.\n   *\n   * Default value is 5, please set a larger value when loading large files in poor network.\n   *\n   * @type {number}\n   * @memberof FileDownloadOptions\n   */\n  maxRetryRequests?: number;\n\n  /**\n   * When this header is set to true and\n   * specified together with the Range header, the service returns the MD5 hash\n   * for the range, as long as the range is less than or equal to 4 MB in size.\n   *\n   * @type {boolean}\n   * @memberof FileDownloadOptions\n   */\n  rangeGetContentMD5?: boolean;\n\n  /**\n   * Download progress updating event handler.\n   *\n   * @memberof FileDownloadOptions\n   */\n  onProgress?: (progress: TransferProgressEvent) => void;\n  /**\n   * Lease access conditions.\n   *\n   * @type {LeaseAccessConditions}\n   * @memberof FileDownloadOptions\n   */\n  leaseAccessConditions?: LeaseAccessConditions;\n}\n\n/**\n * Options to configure the {@link ShareFileClient.uploadRange} operation.\n *\n * @export\n * @interface FileUploadRangeOptions\n */\nexport interface FileUploadRangeOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   *\n   * @type {AbortSignalLike}\n   * @memberof FileUploadRangeOptions\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * An MD5 hash of the content. This hash is\n   * used to verify the integrity of the data during transport. When the\n   * Content-MD5 header is specified, the File service compares the hash of the\n   * content that has arrived with the header value that was sent. If the two\n   * hashes do not match, the operation will fail with error code 400 (Bad\n   * Request).\n   *\n   * @type {Uint8Array}\n   * @memberof FileUploadRangeOptions\n   */\n  contentMD5?: Uint8Array;\n\n  /**\n   * Progress updating event handler.\n   *\n   * @memberof FileUploadRangeOptions\n   */\n  onProgress?: (progress: TransferProgressEvent) => void;\n  /**\n   * Lease access conditions.\n   *\n   * @type {LeaseAccessConditions}\n   * @memberof FileUploadRangeOptions\n   */\n  leaseAccessConditions?: LeaseAccessConditions;\n}\n\n/**\n * Options to configure the {@link ShareFileClient.uploadRangeFromURL} operation.\n *\n * @export\n * @interface FileUploadRangeFromURLOptions\n */\nexport interface FileUploadRangeFromURLOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   *\n   * @type {AbortSignalLike}\n   * @memberof FileUploadRangeFromURLOptions\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * The timeout parameter is expressed in seconds. For more information, see <a\n   * href=\"https://docs.microsoft.com/en-us/rest/api/storageservices/Setting-Timeouts-for-File-Service-Operations?redirectedfrom=MSDN\">Setting\n   * Timeouts for File Service Operations.</a>\n   */\n  timeoutInSeconds?: number;\n  /**\n   * Specify the crc64 calculated for the range of bytes that must be read from the copy source.\n   */\n  sourceContentCrc64?: Uint8Array;\n  /**\n   * Additional parameters for the operation\n   */\n  sourceConditions?: SourceModifiedAccessConditions;\n  /**\n   * Lease access conditions.\n   *\n   * @type {LeaseAccessConditions}\n   * @memberof FileUploadRangeFromURLOptions\n   */\n  leaseAccessConditions?: LeaseAccessConditions;\n}\n\n/**\n * The option is defined as parity to REST definition.\n * While it's not ready to be used now, considering Crc64 of source content is\n * not accessible.\n */\n// export interface IFileUploadRangeFromURLOptions extends CommonOptions {\n//   /**\n//    * Crc64 of the source content.\n//    *\n//    * @type {Uint8Array}\n//    * @memberof IFileUploadRangeFromURLOptions\n//    */\n//   sourceContentCrc64?: Uint8Array;\n\n//   /**\n//    * Source modified access condition.\n//    *\n//    * @type {SourceModifiedAccessConditions}\n//    * @memberof IFileUploadRangeFromURLOptions\n//    */\n//   sourceModifiedAccessConditions?: SourceModifiedAccessConditions;\n// }\n\n/**\n * Options to configure the {@link ShareFileClient.getRangeList} operation.\n *\n * @export\n * @interface FileGetRangeListOptions\n */\nexport interface FileGetRangeListOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   *\n   * @type {AbortSignalLike}\n   * @memberof FileGetRangeListOptions\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * Optional. Specifies the range of bytes over which to list ranges, inclusively.\n   *\n   * @type {Range}\n   * @memberof FileGetRangeListOptions\n   */\n  range?: Range;\n  /**\n   * Lease access conditions.\n   *\n   * @type {LeaseAccessConditions}\n   * @memberof FileGetRangeListOptions\n   */\n  leaseAccessConditions?: LeaseAccessConditions;\n}\n\n/**\n * Options to configure the {@link ShareFileClient.exists} operation.\n *\n * @export\n * @interface FileExistsOptions\n */\nexport interface FileExistsOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   *\n   * @type {AbortSignalLike}\n   * @memberof FileExistsOptions\n   */\n  abortSignal?: AbortSignalLike;\n}\n\n/**\n * Options to configure the {@link ShareFileClient.getProperties} operation.\n *\n * @export\n * @interface FileGetPropertiesOptions\n */\nexport interface FileGetPropertiesOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   *\n   * @type {AbortSignalLike}\n   * @memberof FileGetPropertiesOptions\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * Lease access conditions.\n   *\n   * @type {LeaseAccessConditions}\n   * @memberof FileGetPropertiesOptions\n   */\n  leaseAccessConditions?: LeaseAccessConditions;\n}\n\n/**\n * Contains response data for the {@link ShareFileClient.getRangeList} operation.\n */\nexport type FileGetRangeListResponse = FileGetRangeListHeaders & {\n  /**\n   * Range list for an Azure file.\n   *\n   * @type {RangeModel[]}\n   */\n  rangeList: RangeModel[];\n\n  /**\n   * The underlying HTTP response.\n   */\n  _response: HttpResponse & {\n    /**\n     * The parsed HTTP response headers.\n     */\n    parsedHeaders: FileGetRangeListHeaders;\n    /**\n     * The response body as text (string format)\n     */\n    bodyAsText: string;\n    /**\n     * The response body as parsed JSON or XML\n     */\n    parsedBody: RangeModel[];\n  };\n};\n\n/**\n * Options to configure the {@link ShareFileClient.startCopyFromURL} operation.\n *\n * @export\n * @interface FileStartCopyOptions\n */\nexport interface FileStartCopyOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   *\n   * @type {AbortSignalLike}\n   * @memberof FileStartCopyOptions\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * A collection of key-value string pair to associate with the file storage object.\n   *\n   * @type {Metadata}\n   * @memberof FileStartCopyOptions\n   */\n  metadata?: Metadata;\n  /**\n   * Lease access conditions.\n   *\n   * @type {LeaseAccessConditions}\n   * @memberof FileStartCopyOptions\n   */\n  leaseAccessConditions?: LeaseAccessConditions;\n  /**\n   * If specified the permission (security descriptor) shall be set for the directory/file. This\n   * header can be used if Permission size is <= 8KB, else x-ms-file-permission-key header shall be\n   * used. Default value: Inherit. If SDDL is specified as input, it must have owner, group and\n   * dacl. Note: Only one of the x-ms-file-permission or x-ms-file-permission-key should be\n   * specified.\n   *\n   * @type {string}\n   * @memberof FileStartCopyOptions\n   */\n  filePermission?: string;\n  /**\n   * Key of the permission to be set for the directory/file. Note: Only one of the\n   * x-ms-file-permission or x-ms-file-permission-key should be specified.\n   *\n   * @type {string}\n   * @memberof FileStartCopyOptions\n   */\n  filePermissionKey?: string;\n  /**\n   * SMB info.\n   *\n   * @type {CopyFileSmbInfo}\n   * @memberof FileStartCopyOptions\n   */\n  copyFileSmbInfo?: CopyFileSmbInfo;\n}\n\n/**\n * Options to configure the {@link ShareFileClient.setMetadata} operation.\n *\n * @export\n * @interface FileSetMetadataOptions\n */\nexport interface FileSetMetadataOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   *\n   * @type {AbortSignalLike}\n   * @memberof FileSetMetadataOptions\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * Lease access conditions.\n   *\n   * @type {LeaseAccessConditions}\n   * @memberof FileSetMetadataOptions\n   */\n  leaseAccessConditions?: LeaseAccessConditions;\n}\n\n/**\n * Options to configure the {@link ShareFileClient.setHttpHeaders} operation.\n *\n * @export\n * @interface FileSetHttpHeadersOptions\n */\nexport interface FileSetHttpHeadersOptions\n  extends FileAndDirectorySetPropertiesCommonOptions,\n    CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   *\n   * @type {AbortSignalLike}\n   * @memberof FileSetHttpHeadersOptions\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * Lease access conditions.\n   *\n   * @type {LeaseAccessConditions}\n   * @memberof FileSetHttpHeadersOptions\n   */\n  leaseAccessConditions?: LeaseAccessConditions;\n}\n\n/**\n * Options to configure the {@link ShareFileClient.abortCopyFromURL} operation.\n *\n * @export\n * @interface FileAbortCopyFromURLOptions\n */\nexport interface FileAbortCopyFromURLOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   *\n   * @type {AbortSignalLike}\n   * @memberof FileAbortCopyFromURLOptions\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * Lease access conditions.\n   *\n   * @type {LeaseAccessConditions}\n   * @memberof FileAbortCopyFromURLOptions\n   */\n  leaseAccessConditions?: LeaseAccessConditions;\n}\n\n/**\n * Options to configure the {@link ShareFileClient.resize} operation.\n *\n * @export\n * @interface FileResizeOptions\n */\nexport interface FileResizeOptions\n  extends FileAndDirectorySetPropertiesCommonOptions,\n    CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   *\n   * @type {AbortSignalLike}\n   * @memberof FileResizeOptions\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * Lease access conditions.\n   *\n   * @type {LeaseAccessConditions}\n   * @memberof FileResizeOptions\n   */\n  leaseAccessConditions?: LeaseAccessConditions;\n}\n\n/**\n * Options to configure the {@link ShareFileClient.clearRange} operation.\n *\n * @export\n * @interface FileClearRangeOptions\n */\nexport interface FileClearRangeOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   *\n   * @type {AbortSignalLike}\n   * @memberof FileClearRangeOptions\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * Lease access conditions.\n   *\n   * @type {LeaseAccessConditions}\n   * @memberof FileClearRangeOptions\n   */\n  leaseAccessConditions?: LeaseAccessConditions;\n}\n\n/**\n * Options to configure File - List Handles Segment operations.\n *\n * See:\n * - {@link ShareFileClient.listHandlesSegment}\n * - {@link ShareFileClient.iterateHandleSegments}\n * - {@link ShareFileClient.listHandleItems}\n *\n * @export\n * @interface FileListHandlesSegmentOptions\n */\nexport interface FileListHandlesSegmentOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   *\n   * @type {AbortSignalLike}\n   * @memberof FileClearRangeOptions\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * Specifies the maximum number of entries to return. If the request does not specify maxResults,\n   * or specifies a value greater than 5,000, the server will return up to 5,000 items.\n   *\n   * @type {number}\n   * @memberof FileListHandlesSegmentOptions\n   */\n  maxPageSize?: number;\n}\n\nexport interface FileListHandlesOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   *\n   * @type {AbortSignalLike}\n   * @memberof FileClearRangeOptions\n   */\n  abortSignal?: AbortSignalLike;\n}\n\n/**\n * Options to configure File - Force Close Handles operations.\n *\n * See:\n * - {@link ShareFileClient.forceCloseHandlesSegment}\n * - {@link ShareFileClient.forceCloseAllHandles}\n * - {@link ShareFileClient.forceCloseHandle}\n *\n * @export\n * @interface FileForceCloseHandlesOptions\n */\nexport interface FileForceCloseHandlesOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   *\n   * @type {AbortSignalLike}\n   * @memberof FileForceCloseHandlesOptions\n   */\n  abortSignal?: AbortSignalLike;\n}\n\n/**\n * Additional response header values for close handles request.\n */\nexport interface FileCloseHandlesHeaders {\n  /**\n   * This header uniquely identifies the request that was made and can be used for troubleshooting\n   * the request.\n   */\n  requestId?: string;\n  /**\n   * Indicates the version of the File service used to execute the request.\n   */\n  version?: string;\n  /**\n   * A UTC date/time value generated by the service that indicates the time at which the response\n   * was initiated.\n   */\n  date?: Date;\n  /**\n   * A string describing next handle to be closed. It is returned when more handles need to be\n   * closed to complete the request.\n   */\n  marker?: string;\n}\n\n/**\n * Response type for {@link ShareFileClient.forceCloseHandle}.\n */\nexport type FileForceCloseHandlesResponse = CloseHandlesInfo &\n  FileCloseHandlesHeaders & {\n    /**\n     * The underlying HTTP response.\n     */\n    _response: HttpResponse & {\n      /**\n       * The parsed HTTP response headers.\n       */\n      parsedHeaders: FileForceCloseHandlesHeaders;\n    };\n  };\n\n/**\n * Option interface for ShareFileClient.uploadStream().\n *\n * @export\n * @interface FileUploadStreamOptions\n */\nexport interface FileUploadStreamOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   *\n   * @type {AbortSignalLike}\n   * @memberof FileUploadStreamOptions\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * Azure File HTTP Headers.\n   *\n   * @type {FileHttpHeaders}\n   * @memberof FileUploadStreamOptions\n   */\n  fileHttpHeaders?: FileHttpHeaders;\n\n  /**\n   * Metadata of the Azure file.\n   *\n   * @type {Metadata}\n   * @memberof FileUploadStreamOptions\n   */\n  metadata?: Metadata;\n\n  /**\n   * Progress updater.\n   *\n   * @memberof FileUploadStreamOptions\n   */\n  onProgress?: (progress: TransferProgressEvent) => void;\n  /**\n   * Lease access conditions.\n   *\n   * @type {LeaseAccessConditions}\n   * @memberof FileUploadStreamOptions\n   */\n  leaseAccessConditions?: LeaseAccessConditions;\n}\n\n/**\n * Option interface for File - Upload operations\n *\n * See:\n * - {@link ShareFileClient.uploadFile}\n * - {@link ShareFileClient.uploadSeekableStream}\n *\n * @export\n * @interface FileParallelUploadOptions\n */\nexport interface FileParallelUploadOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   *\n   * @type {AbortSignalLike}\n   * @memberof FileParallelUploadOptions\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * RangeSize specifies the range size to use in each parallel upload,\n   * the default (and maximum size) is FILE_RANGE_MAX_SIZE_BYTES.\n   *\n   * @type {number}\n   * @memberof FileParallelUploadOptions\n   */\n  rangeSize?: number;\n\n  /**\n   * Progress updater.\n   *\n   * @memberof FileParallelUploadOptions\n   */\n  onProgress?: (progress: TransferProgressEvent) => void;\n\n  /**\n   * File HTTP Headers.\n   *\n   * @type {FileHttpHeaders}\n   * @memberof FileParallelUploadOptions\n   */\n  fileHttpHeaders?: FileHttpHeaders;\n\n  /**\n   * Metadata of an Azure file.\n   *\n   * @type {Metadata}\n   * @memberof FileParallelUploadOptions\n   */\n  metadata?: Metadata;\n\n  /**\n   * Concurrency indicates the maximum number of ranges to upload in parallel.\n   * If not provided, 5 concurrency will be used by default.\n   *\n   * @type {number}\n   * @memberof FileParallelUploadOptions\n   */\n  concurrency?: number;\n  /**\n   * Lease access conditions.\n   *\n   * @type {LeaseAccessConditions}\n   * @memberof FileParallelUploadOptions\n   */\n  leaseAccessConditions?: LeaseAccessConditions;\n}\n\n/**\n * Option interface for the {@link ShareFileClient.downloadToBuffer} operation.\n *\n * @export\n * @interface FileDownloadToBufferOptions\n */\nexport interface FileDownloadToBufferOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   *\n   * @type {AbortSignalLike}\n   * @memberof FileDownloadToBufferOptions\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * When downloading Azure files, download method will try to split large file into small ranges.\n   * Every small range will be downloaded via a separate request.\n   * This option defines size data every small request trying to download.\n   * Must be > 0, will use the default value if undefined,\n   *\n   * @type {number}\n   * @memberof FileDownloadToBufferOptions\n   */\n  rangeSize?: number;\n\n  /**\n   * Optional. ONLY AVAILABLE IN NODE.JS.\n   *\n   * How many retries will perform when original range download stream unexpected ends.\n   * Above kind of ends will not trigger retry policy defined in a pipeline,\n   * because they doesn't emit network errors.\n   *\n   * With this option, every additional retry means an additional ShareFileClient.download() request will be made\n   * from the broken point, until the requested range has been successfully downloaded or\n   * maxRetryRequestsPerRange is reached.\n   *\n   * Default value is 5, please set a larger value when in poor network.\n   *\n   * @type {number}\n   * @memberof FileDownloadToBufferOptions\n   */\n  maxRetryRequestsPerRange?: number;\n\n  /**\n   * Progress updater.\n   *\n   * @memberof FileDownloadToBufferOptions\n   */\n  onProgress?: (progress: TransferProgressEvent) => void;\n\n  /**\n   * Concurrency indicates the maximum number of ranges to download in parallel.\n   * If not provided, 5 concurrency will be used by default.\n   *\n   * @type {number}\n   * @memberof FileDownloadToBufferOptions\n   */\n  concurrency?: number;\n  /**\n   * Lease access conditions.\n   *\n   * @type {LeaseAccessConditions}\n   * @memberof FileDownloadToBufferOptions\n   */\n  leaseAccessConditions?: LeaseAccessConditions;\n}\n\n/**\n * Contains response data for the {@link ShareFileClient.deleteIfExists} operation.\n *\n * @export\n * @interface FileDeleteIfExistsResponse\n */\nexport interface FileDeleteIfExistsResponse extends FileDeleteResponse {\n  /**\n   * Indicate whether the file is successfully deleted. Is false if the file does not exist in the first place.\n   *\n   * @type {boolean}\n   * @memberof FileDeleteIfExistsResponse\n   */\n  succeeded: boolean;\n}\n\n/**\n * A ShareFileClient represents a URL to an Azure Storage file.\n *\n * @export\n * @class ShareFileClient\n */\nexport class ShareFileClient extends StorageClient {\n  /**\n   * context provided by protocol layer.\n   *\n   * @private\n   * @type {File}\n   * @memberof ShareFileClient\n   */\n  private context: File;\n\n  private _shareName: string;\n  private _path: string;\n  private _name: string;\n\n  /**\n   * The share name corresponding to this file client\n   *\n   * @type {string}\n   * @memberof ShareFileClient\n   */\n  public get shareName(): string {\n    return this._shareName;\n  }\n\n  /**\n   * The full path of the file\n   *\n   * @type {string}\n   * @memberof ShareFileClient\n   */\n  public get path(): string {\n    return this._path;\n  }\n\n  /**\n   * The name of the file\n   *\n   * @type {string}\n   * @memberof ShareFileClient\n   */\n  public get name(): string {\n    return this._name;\n  }\n\n  /**\n   * Creates an instance of ShareFileClient.\n   *\n   * @param {string} url A URL string pointing to Azure Storage file, such as\n   *                     \"https://myaccount.file.core.windows.net/myshare/mydirectory/file\". You can\n   *                     append a SAS if using AnonymousCredential, such as\n   *                     \"https://myaccount.file.core.windows.net/myshare/mydirectory/file?sasString\".\n   *                     This method accepts an encoded URL or non-encoded URL pointing to a file.\n   *                     Encoded URL string will NOT be escaped twice, only special characters in URL path will be escaped.\n   *                     However, if a file or directory name includes %, file or directory name must be encoded in the URL.\n   *                     Such as a file named \"myfile%\", the URL should be \"https://myaccount.file.core.windows.net/myshare/mydirectory/myfile%25\".\n   * @param {Credential} [credential] Such as AnonymousCredential or StorageSharedKeyCredential.\n   *                                  If not specified, AnonymousCredential is used.\n   * @param {StoragePipelineOptions} [options] Optional. Options to configure the HTTP pipeline.\n   * @memberof ShareFileClient\n   */\n  constructor(url: string, credential?: Credential, options?: StoragePipelineOptions);\n  /**\n   * Creates an instance of ShareFileClient.\n   *\n   * @param {string} url A URL string pointing to Azure Storage file, such as\n   *                     \"https://myaccount.file.core.windows.net/myshare/mydirectory/file\". You can\n   *                     append a SAS if using AnonymousCredential, such as\n   *                     \"https://myaccount.file.core.windows.net/myshare/mydirectory/file?sasString\".\n   *                     This method accepts an encoded URL or non-encoded URL pointing to a file.\n   *                     Encoded URL string will NOT be escaped twice, only special characters in URL path will be escaped.\n   *                     However, if a file or directory name includes %, file or directory name must be encoded in the URL.\n   *                     Such as a file named \"myfile%\", the URL should be \"https://myaccount.file.core.windows.net/myshare/mydirectory/myfile%25\".\n   * @param {Pipeline} pipeline Call newPipeline() to create a default\n   *                            pipeline, or provide a customized pipeline.\n   * @memberof ShareFileClient\n   */\n  constructor(url: string, pipeline: Pipeline);\n  constructor(\n    url: string,\n    credentialOrPipeline?: Credential | Pipeline,\n    options?: StoragePipelineOptions\n  ) {\n    let pipeline: Pipeline;\n    if (credentialOrPipeline instanceof Pipeline) {\n      pipeline = credentialOrPipeline;\n    } else if (credentialOrPipeline instanceof Credential) {\n      pipeline = newPipeline(credentialOrPipeline, options);\n    } else {\n      // The second parameter is undefined. Use anonymous credential.\n      pipeline = newPipeline(new AnonymousCredential(), options);\n    }\n\n    super(url, pipeline);\n    ({\n      baseName: this._name,\n      shareName: this._shareName,\n      path: this._path\n    } = getShareNameAndPathFromUrl(this.url));\n    this.context = new File(this.storageClientContext);\n  }\n\n  /**\n   * Creates a new file or replaces a file. Note it only initializes the file with no content.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-file\n   *\n   * @param {number} size Specifies the maximum size in bytes for the file, up to 1 TB.\n   * @param {FileCreateOptions} [options] Options to File Create operation.\n   * @returns {Promise<FileCreateResponse>} Response data for the File Create  operation.\n   * @memberof ShareFileClient\n   *\n   * Example usage:\n   *\n   * ```js\n   * const content = \"Hello world!\";\n   *\n   * // Create the file\n   * await fileClient.create(content.length);\n   * console.log(\"Created file successfully!\");\n   *\n   * // Then upload data to the file\n   * await fileClient.uploadRange(content, 0, content.length);\n   * console.log(\"Updated file successfully!\")\n   * ```\n   */\n  public async create(size: number, options: FileCreateOptions = {}): Promise<FileCreateResponse> {\n    const { span, spanOptions } = createSpan(\"ShareFileClient-create\", options.tracingOptions);\n    try {\n      if (size < 0 || size > FILE_MAX_SIZE_BYTES) {\n        throw new RangeError(`File size must >= 0 and < ${FILE_MAX_SIZE_BYTES}.`);\n      }\n      options = validateAndSetDefaultsForFileAndDirectoryCreateCommonOptions(options);\n\n      if (!options.fileAttributes) {\n        // Note: It would be Archive in service side if None is set.\n        const attributes: FileSystemAttributes = new FileSystemAttributes();\n        attributes.none = true;\n        options.fileAttributes = attributes;\n      }\n\n      options.fileHttpHeaders = options.fileHttpHeaders || {};\n\n      return await this.context.create(\n        size,\n        fileAttributesToString(options.fileAttributes!),\n        fileCreationTimeToString(options.creationTime!),\n        fileLastWriteTimeToString(options.lastWriteTime!),\n        {\n          abortSignal: options.abortSignal,\n          fileHttpHeaders: options.fileHttpHeaders,\n          metadata: options.metadata,\n          filePermission: options.filePermission,\n          filePermissionKey: options.filePermissionKey,\n          leaseAccessConditions: options.leaseAccessConditions,\n          spanOptions\n        }\n      );\n    } catch (e) {\n      span.setStatus({\n        code: CanonicalCode.UNKNOWN,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Reads or downloads a file from the system, including its metadata and properties.\n   *\n   * * In Node.js, data returns in a Readable stream `readableStreamBody`\n   * * In browsers, data returns in a promise `contentAsBlob`\n   *\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-file\n   *\n   * @param {number} [offset] From which position of the file to download, >= 0\n   * @param {number} [count] How much data to be downloaded, > 0. Will download to the end when undefined\n   * @param {FileDownloadOptions} [options] Options to File Download operation.\n   * @returns {Promise<FileDownloadResponse>} Response data for the File Download operation.\n   * @memberof ShareFileClient\n   *\n   * Example usage (Node.js):\n   *\n   * ```js\n   * // Download a file to a string\n   * const downloadFileResponse = await fileClient.download();\n   * console.log(\n   *   \"Downloaded file content:\",\n   *   (await streamToBuffer(downloadFileResponse.readableStreamBody)).toString()}\n   * );\n   *\n   * // A helper method used to read a Node.js readable stream into string\n   * async function streamToBuffer(readableStream) {\n   *   return new Promise((resolve, reject) => {\n   *     const chunks = [];\n   *     readableStream.on(\"data\", (data) => {\n   *       chunks.push(data instanceof Buffer ? data : Buffer.from(data));\n   *     });\n   *     readableStream.on(\"end\", () => {\n   *       resolve(Buffer.concat(chunks));\n   *     });\n   *     readableStream.on(\"error\", reject);\n   *   });\n   * }\n   * ```\n   *\n   * Example usage (browsers):\n   *\n   * ```js\n   * // Download a file to a string\n   * const downloadFileResponse = await fileClient.download(0);\n   * console.log(\n   *   \"Downloaded file content:\",\n   *   await blobToString(await downloadFileResponse.blobBody)}\n   * );\n   *\n   * // A helper method used to convert a browser Blob into string.\n   * export async function blobToString(blob: Blob): Promise<string> {\n   *   const fileReader = new FileReader();\n   *   return new Promise<string>((resolve, reject) => {\n   *     fileReader.onloadend = (ev: any) => {\n   *       resolve(ev.target!.result);\n   *     };\n   *     fileReader.onerror = reject;\n   *     fileReader.readAsText(blob);\n   *   });\n   * }\n   * ```\n   */\n  public async download(\n    offset: number = 0,\n    count?: number,\n    options: FileDownloadOptions = {}\n  ): Promise<FileDownloadResponseModel> {\n    const { span, spanOptions } = createSpan(\"ShareFileClient-download\", options.tracingOptions);\n    try {\n      if (options.rangeGetContentMD5 && offset === 0 && count === undefined) {\n        throw new RangeError(`rangeGetContentMD5 only works with partial data downloading`);\n      }\n\n      const downloadFullFile = offset === 0 && !count;\n      const res = await this.context.download({\n        abortSignal: options.abortSignal,\n        onDownloadProgress: isNode ? undefined : options.onProgress, // for Node.js, progress is reported by RetriableReadableStream\n        range: downloadFullFile ? undefined : rangeToString({ offset, count }),\n        rangeGetContentMD5: options.rangeGetContentMD5,\n        leaseAccessConditions: options.leaseAccessConditions,\n        spanOptions\n      });\n\n      // Return browser response immediately\n      if (!isNode) {\n        return res;\n      }\n\n      // We support retrying when download stream unexpected ends in Node.js runtime\n      // Following code shouldn't be bundled into browser build, however some\n      // bundlers may try to bundle following code and \"FileReadResponse.ts\".\n      // In this case, \"FileDownloadResponse.browser.ts\" will be used as a shim of \"FileDownloadResponse.ts\"\n      // The config is in package.json \"browser\" field\n      if (options.maxRetryRequests === undefined || options.maxRetryRequests < 0) {\n        // TODO: Default value or make it a required parameter?\n        options.maxRetryRequests = DEFAULT_MAX_DOWNLOAD_RETRY_REQUESTS;\n      }\n\n      if (res.contentLength === undefined) {\n        throw new RangeError(`File download response doesn't contain valid content length header`);\n      }\n\n      return new FileDownloadResponse(\n        res,\n        async (start: number): Promise<NodeJS.ReadableStream> => {\n          const updatedOptions: FileDownloadOptionalParams = {\n            range: rangeToString({\n              count: offset + res.contentLength! - start,\n              offset: start\n            })\n          };\n\n          // Debug purpose only\n          // console.log(\n          //   `Read from internal stream, range: ${\n          //     updatedOptions.range\n          //   }, options: ${JSON.stringify(updatedOptions)}`\n          // );\n\n          return (\n            await this.context.download({\n              abortSignal: options.abortSignal,\n              leaseAccessConditions: options.leaseAccessConditions,\n              ...updatedOptions,\n              spanOptions\n            })\n          ).readableStreamBody!;\n        },\n        offset,\n        res.contentLength!,\n        {\n          abortSignal: options.abortSignal,\n          maxRetryRequests: options.maxRetryRequests,\n          onProgress: options.onProgress\n        }\n      );\n    } catch (e) {\n      span.setStatus({\n        code: CanonicalCode.UNKNOWN,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Returns true if the specified file exists; false otherwise.\n   *\n   * NOTE: use this function with care since an existing file might be deleted by other clients or\n   * applications. Vice versa new files might be added by other clients or applications after this\n   * function completes.\n   *\n   * @param {FileExistsOptions} [options] options to Exists operation.\n   * @returns {Promise<boolean>}\n   * @memberof ShareFileClient\n   */\n  public async exists(options: FileExistsOptions = {}): Promise<boolean> {\n    const { span, spanOptions } = createSpan(\"ShareFileClient-exists\", options.tracingOptions);\n    try {\n      await this.getProperties({\n        abortSignal: options.abortSignal,\n        tracingOptions: {\n          ...options.tracingOptions,\n          spanOptions\n        }\n      });\n      return true;\n    } catch (e) {\n      if (e.statusCode === 404) {\n        span.setStatus({\n          code: CanonicalCode.NOT_FOUND,\n          message: \"Expected exception when checking file existence\"\n        });\n        return false;\n      }\n      span.setStatus({\n        code: CanonicalCode.UNKNOWN,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Returns all user-defined metadata, standard HTTP properties, and system properties\n   * for the file. It does not return the content of the file.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-file-properties\n   *\n   * @param {FileGetPropertiesOptions} [options] Options to File Get Properties operation.\n   * @returns {Promise<FileGetPropertiesResponse>} Response data for the File Get Properties operation.\n   * @memberof ShareFileClient\n   */\n  public async getProperties(\n    options: FileGetPropertiesOptions = {}\n  ): Promise<FileGetPropertiesResponse> {\n    const { span, spanOptions } = createSpan(\n      \"ShareFileClient-getProperties\",\n      options.tracingOptions\n    );\n    try {\n      return this.context.getProperties({\n        abortSignal: options.abortSignal,\n        leaseAccessConditions: options.leaseAccessConditions,\n        spanOptions\n      });\n    } catch (e) {\n      span.setStatus({\n        code: CanonicalCode.UNKNOWN,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Sets properties on the file.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-file-properties\n   *\n   * @param {FileProperties} [properties] File properties. For file HTTP headers(e.g. Content-Type),\n   *                                       if no values are provided, existing HTTP headers will be removed.\n   *                                       For other file properties(e.g. fileAttributes), if no values are provided,\n   *                                       existing values will be preserved.\n   * @returns {Promise<SetPropertiesResponse>}\n   * @memberof ShareFileClient\n   */\n  public async setProperties(properties: FileProperties = {}): Promise<SetPropertiesResponse> {\n    const { span, spanOptions } = createSpan(\n      \"ShareFileClient-setProperties\",\n      properties.tracingOptions\n    );\n    try {\n      properties = validateAndSetDefaultsForFileAndDirectorySetPropertiesCommonOptions(properties);\n\n      properties.fileHttpHeaders = properties.fileHttpHeaders || {};\n\n      return await this.context.setHTTPHeaders(\n        fileAttributesToString(properties.fileAttributes!),\n        fileCreationTimeToString(properties.creationTime!),\n        fileLastWriteTimeToString(properties.lastWriteTime!),\n        {\n          abortSignal: properties.abortSignal,\n          fileHttpHeaders: properties.fileHttpHeaders,\n          filePermission: properties.filePermission,\n          filePermissionKey: properties.filePermissionKey,\n          leaseAccessConditions: properties.leaseAccessConditions,\n          spanOptions\n        }\n      );\n    } catch (e) {\n      span.setStatus({\n        code: CanonicalCode.UNKNOWN,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Removes the file from the storage account.\n   * When a file is successfully deleted, it is immediately removed from the storage\n   * account's index and is no longer accessible to clients. The file's data is later\n   * removed from the service during garbage collection.\n   *\n   * Delete File will fail with status code 409 (Conflict) and error code SharingViolation\n   * if the file is open on an SMB client.\n   *\n   * Delete File is not supported on a share snapshot, which is a read-only copy of\n   * a share. An attempt to perform this operation on a share snapshot will fail with 400 (InvalidQueryParameterValue)\n   *\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-file2\n   *\n   * @param {FileDeleteOptions} [options] Options to File Delete operation.\n   * @returns {Promise<FileDeleteResponse>} Response data for the File Delete operation.\n   * @memberof ShareFileClient\n   */\n  public async delete(options: FileDeleteOptions = {}): Promise<FileDeleteResponse> {\n    const { span, spanOptions } = createSpan(\"ShareFileClient-delete\", options.tracingOptions);\n    try {\n      return await this.context.deleteMethod({\n        abortSignal: options.abortSignal,\n        leaseAccessConditions: options.leaseAccessConditions,\n        spanOptions\n      });\n    } catch (e) {\n      span.setStatus({\n        code: CanonicalCode.UNKNOWN,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Removes the file from the storage account if it exists.\n   * When a file is successfully deleted, it is immediately removed from the storage\n   * account's index and is no longer accessible to clients. The file's data is later\n   * removed from the service during garbage collection.\n   *\n   * Delete File will fail with status code 409 (Conflict) and error code SharingViolation\n   * if the file is open on an SMB client.\n   *\n   * Delete File is not supported on a share snapshot, which is a read-only copy of\n   * a share. An attempt to perform this operation on a share snapshot will fail with 400 (InvalidQueryParameterValue)\n   *\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-file2\n   *\n   * @param {FileDeleteOptions} [options]\n   * @returns {Promise<FileDeleteIfExistsResponse>}\n   * @memberof ShareFileClient\n   */\n  public async deleteIfExists(\n    options: FileDeleteOptions = {}\n  ): Promise<FileDeleteIfExistsResponse> {\n    const { span, spanOptions } = createSpan(\n      \"ShareFileClient-deleteIfExists\",\n      options.tracingOptions\n    );\n    try {\n      const res = await this.delete({\n        ...options,\n        tracingOptions: { ...options!.tracingOptions, spanOptions }\n      });\n      return {\n        succeeded: true,\n        ...res\n      };\n    } catch (e) {\n      if (e.details?.errorCode === \"ResourceNotFound\") {\n        span.setStatus({\n          code: CanonicalCode.NOT_FOUND,\n          message: \"Expected exception when deleting a file only if it exists.\"\n        });\n        return {\n          succeeded: false,\n          ...e.response?.parsedHeaders,\n          _response: e.response\n        };\n      }\n      span.setStatus({\n        code: CanonicalCode.UNKNOWN,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Sets HTTP headers on the file.\n   *\n   * If no option provided, or no value provided for the file HTTP headers in the options,\n   * these file HTTP headers without a value will be cleared.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-file-properties\n   *\n   * @param {fileHttpHeaders} [FileHttpHeaders] File HTTP headers like Content-Type.\n   *                                             Provide undefined will remove existing HTTP headers.\n   * @param {FileSetHttpHeadersOptions} [options] Options to File Set HTTP Headers operation.\n   * @returns {Promise<FileSetHTTPHeadersResponse>} Response data for the File Set HTTP Headers operation.\n   * @memberof ShareFileClient\n   */\n  public async setHttpHeaders(\n    fileHttpHeaders: FileHttpHeaders = {},\n    options: FileSetHttpHeadersOptions = {}\n  ): Promise<FileSetHTTPHeadersResponse> {\n    const { span, spanOptions } = createSpan(\n      \"ShareFileClient-setHTTPHeaders\",\n      options.tracingOptions\n    );\n    try {\n      // FileAttributes, filePermission, createTime, lastWriteTime will all be preserved\n      options = validateAndSetDefaultsForFileAndDirectorySetPropertiesCommonOptions(options);\n      return await this.context.setHTTPHeaders(\n        fileAttributesToString(options.fileAttributes!),\n        fileCreationTimeToString(options.creationTime!),\n        fileLastWriteTimeToString(options.lastWriteTime!),\n        {\n          abortSignal: options.abortSignal,\n          fileHttpHeaders,\n          filePermission: options.filePermission,\n          filePermissionKey: options.filePermissionKey,\n          leaseAccessConditions: options.leaseAccessConditions,\n          spanOptions\n        }\n      );\n    } catch (e) {\n      span.setStatus({\n        code: CanonicalCode.UNKNOWN,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Resize file.\n   *\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-file-properties\n   *\n   * @param {number} length Resizes a file to the specified size in bytes.\n   *                        If the specified byte value is less than the current size of the file,\n   *                        then all ranges above the specified byte value are cleared.\n   * @param {FileResizeOptions} [options] Options to File Resize operation.\n   * @returns {Promise<FileSetHTTPHeadersResponse>} Response data for the File Set HTTP Headers operation.\n   * @memberof ShareFileClient\n   */\n  public async resize(\n    length: number,\n    options: FileResizeOptions = {}\n  ): Promise<FileSetHTTPHeadersResponse> {\n    const { span, spanOptions } = createSpan(\"ShareFileClient-resize\", options.tracingOptions);\n    try {\n      if (length < 0) {\n        throw new RangeError(`Size cannot less than 0 when resizing file.`);\n      }\n      // FileAttributes, filePermission, createTime, lastWriteTime will all be preserved.\n      options = validateAndSetDefaultsForFileAndDirectorySetPropertiesCommonOptions(options);\n\n      return await this.context.setHTTPHeaders(\n        fileAttributesToString(options.fileAttributes!),\n        fileCreationTimeToString(options.creationTime!),\n        fileLastWriteTimeToString(options.lastWriteTime!),\n        {\n          abortSignal: options.abortSignal,\n          fileContentLength: length,\n          filePermission: options.filePermission,\n          filePermissionKey: options.filePermissionKey,\n          leaseAccessConditions: options.leaseAccessConditions,\n          spanOptions\n        }\n      );\n    } catch (e) {\n      span.setStatus({\n        code: CanonicalCode.UNKNOWN,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Updates user-defined metadata for the specified file.\n   *\n   * If no metadata defined in the option parameter, the file\n   * metadata will be removed.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-file-metadata\n   *\n   * @param {Metadata} [metadata] If no metadata provided, all existing directory metadata will be removed\n   * @param {FileSetMetadataOptions} [options] Options to File Set Metadata operation.\n   * @returns {Promise<FileSetMetadataResponse>} Response data for the File Set Metadata operation.\n   * @memberof ShareFileClient\n   */\n  public async setMetadata(\n    metadata: Metadata = {},\n    options: FileSetMetadataOptions = {}\n  ): Promise<FileSetMetadataResponse> {\n    const { span, spanOptions } = createSpan(\"ShareFileClient-setMetadata\", options.tracingOptions);\n    try {\n      return await this.context.setMetadata({\n        abortSignal: options.abortSignal,\n        metadata,\n        leaseAccessConditions: options.leaseAccessConditions,\n        spanOptions\n      });\n    } catch (e) {\n      span.setStatus({\n        code: CanonicalCode.UNKNOWN,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Upload a range of bytes to a file. Both the start and count of the\n   * range must be specified. The range can be up to 4 MB in size.\n   *\n   * @param {HttpRequestBody} body Blob, string, ArrayBuffer, ArrayBufferView or a function\n   *                               which returns a new Readable stream whose offset is from data source beginning.\n   * @param {number} offset Offset position of the destination Azure File to upload.\n   * @param {number} contentLength Length of body in bytes. Use Buffer.byteLength() to calculate body length for a\n   *                               string including non non-Base64/Hex-encoded characters.\n   * @param {FileUploadRangeOptions} [options={}] Options to File Upload Range operation.\n   * @returns {Promise<FileUploadRangeResponse>} Response data for the File Upload Range operation.\n   * @memberof ShareFileClient\n   *\n   * Example usage:\n   *\n   * ```js\n   * const content = \"Hello world!\";\n   *\n   * // Create the file\n   * await fileClient.create(content.length);\n   * console.log(\"Created file successfully!\");\n   *\n   * // Then upload data to the file\n   * await fileClient.uploadRange(content, 0, content.length);\n   * console.log(\"Updated file successfully!\")\n   * ```\n   */\n  public async uploadRange(\n    body: HttpRequestBody,\n    offset: number,\n    contentLength: number,\n    options: FileUploadRangeOptions = {}\n  ): Promise<FileUploadRangeResponse> {\n    const { span, spanOptions } = createSpan(\"ShareFileClient-uploadRange\", options.tracingOptions);\n    try {\n      if (offset < 0) {\n        throw new RangeError(`offset must be >= 0`);\n      }\n\n      if (contentLength <= 0 || contentLength > FILE_RANGE_MAX_SIZE_BYTES) {\n        throw new RangeError(`contentLength must be > 0 and <= ${FILE_RANGE_MAX_SIZE_BYTES} bytes`);\n      }\n\n      if (contentLength > FILE_RANGE_MAX_SIZE_BYTES) {\n        throw new RangeError(`offset must be < ${FILE_RANGE_MAX_SIZE_BYTES} bytes`);\n      }\n\n      return await this.context.uploadRange(\n        rangeToString({ count: contentLength, offset }),\n        \"update\",\n        contentLength,\n        {\n          abortSignal: options.abortSignal,\n          contentMD5: options.contentMD5,\n          onUploadProgress: options.onProgress,\n          body: body,\n          spanOptions,\n          leaseAccessConditions: options.leaseAccessConditions\n        }\n      );\n    } catch (e) {\n      span.setStatus({\n        code: CanonicalCode.UNKNOWN,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Upload a range of bytes to a file where the contents are read from a another file's URL.\n   * The range can be up to 4 MB in size.\n   *\n   * @param {string} sourceURL Specify a URL to the copy source, Shared Access Signature(SAS) maybe needed for authentication.\n   * @param {number} sourceOffset The source offset to copy from. Pass 0 to copy from the beginning of source file.\n   * @param {number} destOffset Offset of destination file.\n   * @param {number} count Number of bytes to be uploaded from source file.\n   * @param {FileUploadRangeFromURLOptions} [options={}] Options to configure File - Upload Range from URL operation.\n   * @returns {Promise<FileUploadRangeFromURLResponse>}\n   * @memberof FileURL\n   */\n  public async uploadRangeFromURL(\n    sourceURL: string,\n    sourceOffset: number,\n    destOffset: number,\n    count: number,\n    options: FileUploadRangeFromURLOptions = {}\n  ): Promise<FileUploadRangeFromURLResponse> {\n    const { span, spanOptions } = createSpan(\n      \"ShareFileClient-uploadRangeFromURL\",\n      options.tracingOptions\n    );\n    try {\n      if (sourceOffset < 0 || destOffset < 0) {\n        throw new RangeError(`sourceOffset and destOffset must be >= 0`);\n      }\n\n      if (count <= 0 || count > FILE_RANGE_MAX_SIZE_BYTES) {\n        throw new RangeError(`count must be > 0 and <= ${FILE_RANGE_MAX_SIZE_BYTES} bytes`);\n      }\n\n      return await this.context.uploadRangeFromURL(\n        rangeToString({ offset: destOffset, count }),\n        sourceURL,\n        0,\n        {\n          abortSignal: options.abortSignal,\n          sourceRange: rangeToString({ offset: sourceOffset, count }),\n          sourceModifiedAccessConditions: options.sourceConditions,\n          ...options,\n          spanOptions\n        }\n      );\n    } catch (e) {\n      span.setStatus({\n        code: CanonicalCode.UNKNOWN,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n  /**\n   * Clears the specified range and\n   * releases the space used in storage for that range.\n   *\n   * @param {number} offset\n   * @param {number} contentLength\n   * @param {FileClearRangeOptions} [options] Options to File Clear Range operation.\n   * @returns {Promise<FileUploadRangeResponse>}\n   * @memberof ShareFileClient\n   */\n  public async clearRange(\n    offset: number,\n    contentLength: number,\n    options: FileClearRangeOptions = {}\n  ): Promise<FileUploadRangeResponse> {\n    const { span, spanOptions } = createSpan(\"ShareFileClient-clearRange\", options.tracingOptions);\n    try {\n      if (offset < 0 || contentLength <= 0) {\n        throw new RangeError(`offset must >= 0 and contentLength must be > 0`);\n      }\n\n      return await this.context.uploadRange(\n        rangeToString({ count: contentLength, offset }),\n        \"clear\",\n        0,\n        {\n          abortSignal: options.abortSignal,\n          spanOptions,\n          leaseAccessConditions: options.leaseAccessConditions\n        }\n      );\n    } catch (e) {\n      span.setStatus({\n        code: CanonicalCode.UNKNOWN,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Returns the list of valid ranges for a file.\n   *\n   * @param {FileGetRangeListOptions} [options] Options to File Get range List operation.\n   * @returns {Promise<FileGetRangeListResponse>}\n   * @memberof ShareFileClient\n   */\n  public async getRangeList(\n    options: FileGetRangeListOptions = {}\n  ): Promise<FileGetRangeListResponse> {\n    const { span, spanOptions } = createSpan(\n      \"ShareFileClient-getRangeList\",\n      options.tracingOptions\n    );\n    try {\n      const originalResponse = await this.context.getRangeList({\n        abortSignal: options.abortSignal,\n        range: options.range ? rangeToString(options.range) : undefined,\n        leaseAccessConditions: options.leaseAccessConditions,\n        spanOptions\n      });\n      return {\n        _response: originalResponse._response,\n        date: originalResponse.date,\n        etag: originalResponse.etag,\n        errorCode: originalResponse.errorCode,\n        fileContentLength: originalResponse.fileContentLength,\n        lastModified: originalResponse.lastModified,\n        rangeList: originalResponse.filter(() => {\n          return true;\n        }),\n        requestId: originalResponse.requestId,\n        version: originalResponse.version\n      };\n    } catch (e) {\n      span.setStatus({\n        code: CanonicalCode.UNKNOWN,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Copies a blob or file to a destination file within the storage account.\n   *\n   * @param {string} copySource Specifies the URL of the source file or blob, up to 2 KB in length.\n   * To copy a file to another file within the same storage account, you may use Shared Key to\n   * authenticate the source file. If you are copying a file from another storage account, or if you\n   * are copying a blob from the same storage account or another storage account, then you must\n   * authenticate the source file or blob using a shared access signature. If the source is a public\n   * blob, no authentication is required to perform the copy operation. A file in a share snapshot\n   * can also be specified as a copy source.\n   * @param {FileStartCopyOptions} [options] Options to File Start Copy operation.\n   * @returns {Promise<FileStartCopyResponse>}\n   * @memberof ShareFileClient\n   */\n  public async startCopyFromURL(\n    copySource: string,\n    options: FileStartCopyOptions = {}\n  ): Promise<FileStartCopyResponse> {\n    const { span, spanOptions } = createSpan(\n      \"ShareFileClient-startCopyFromURL\",\n      options.tracingOptions\n    );\n    try {\n      return await this.context.startCopy(copySource, {\n        abortSignal: options.abortSignal,\n        metadata: options.metadata,\n        leaseAccessConditions: options.leaseAccessConditions,\n        filePermission: options.filePermission,\n        filePermissionKey: options.filePermissionKey,\n        copyFileSmbInfo: options.copyFileSmbInfo,\n        spanOptions\n      });\n    } catch (e) {\n      span.setStatus({\n        code: CanonicalCode.UNKNOWN,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Aborts a pending Copy File operation, and leaves a destination file with zero length and full\n   * metadata.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/abort-copy-file\n   *\n   * @param {string} copyId Id of the Copy File operation to abort.\n   * @param {FileAbortCopyFromURLOptions} [options] Options to File Abort Copy From URL operation.\n   * @returns {Promise<FileAbortCopyResponse>}\n   * @memberof ShareFileClient\n   */\n  public async abortCopyFromURL(\n    copyId: string,\n    options: FileAbortCopyFromURLOptions = {}\n  ): Promise<FileAbortCopyResponse> {\n    const { span, spanOptions } = createSpan(\n      \"ShareFileClient-abortCopyFromURL\",\n      options.tracingOptions\n    );\n    try {\n      return await this.context.abortCopy(copyId, {\n        abortSignal: options.abortSignal,\n        leaseAccessConditions: options.leaseAccessConditions,\n        spanOptions\n      });\n    } catch (e) {\n      span.setStatus({\n        code: CanonicalCode.UNKNOWN,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  // High Level functions\n\n  /**\n   * Uploads a Buffer(Node)/Blob/ArrayBuffer/ArrayBufferView to an Azure File.\n   *\n   * @param {Buffer | Blob | ArrayBuffer | ArrayBufferView} data Buffer(Node), Blob, ArrayBuffer or ArrayBufferView\n   * @param {FileParallelUploadOptions} [options]\n   * @returns {Promise<void>}\n   */\n  public async uploadData(\n    data: Buffer | Blob | ArrayBuffer | ArrayBufferView,\n    options: FileParallelUploadOptions = {}\n  ): Promise<void> {\n    const { span, spanOptions } = createSpan(\"ShareFileClient-uploadData\", options.tracingOptions);\n    try {\n      if (isNode && data instanceof Buffer) {\n        return this.uploadBuffer(\n          (offset, count) => data.slice(offset, offset + count),\n          data.byteLength,\n          {\n            ...options,\n            tracingOptions: { ...options!.tracingOptions, spanOptions }\n          }\n        );\n      } else {\n        const browserBlob = new Blob([data]);\n        return this.uploadSeekableBlob(\n          (offset: number, size: number): Blob => {\n            return browserBlob.slice(offset, offset + size);\n          },\n          browserBlob.size,\n          { ...options, tracingOptions: { ...options!.tracingOptions, spanOptions } }\n        );\n      }\n    } catch (e) {\n      span.setStatus({\n        code: CanonicalCode.UNKNOWN,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * ONLY AVAILABLE IN BROWSERS.\n   *\n   * Uploads a browser Blob object to an Azure file. Requires a blobFactory as the data source,\n   * which need to return a Blob object with the offset and size provided.\n   *\n   * @param {(offset: number, size: number) => Blob} blobFactory\n   * @param {number} size\n   * @param {FileParallelUploadOptions} [options]\n   * @returns {Promise<void>}\n   */\n  async uploadSeekableBlob(\n    blobFactory: (offset: number, size: number) => Blob,\n    size: number,\n    options: FileParallelUploadOptions = {}\n  ): Promise<void> {\n    const { span, spanOptions } = createSpan(\n      \"ShareFileClient-UploadSeekableBlob\",\n      options.tracingOptions\n    );\n    try {\n      if (!options.rangeSize) {\n        options.rangeSize = FILE_RANGE_MAX_SIZE_BYTES;\n      }\n      if (options.rangeSize < 0 || options.rangeSize > FILE_RANGE_MAX_SIZE_BYTES) {\n        throw new RangeError(`options.rangeSize must be > 0 and <= ${FILE_RANGE_MAX_SIZE_BYTES}`);\n      }\n\n      if (!options.fileHttpHeaders) {\n        options.fileHttpHeaders = {};\n      }\n\n      if (!options.concurrency) {\n        options.concurrency = DEFAULT_HIGH_LEVEL_CONCURRENCY;\n      }\n      if (options.concurrency < 0) {\n        throw new RangeError(`options.concurrency cannot less than 0.`);\n      }\n\n      // Create the file\n      await this.create(size, {\n        abortSignal: options.abortSignal,\n        fileHttpHeaders: options.fileHttpHeaders,\n        metadata: options.metadata,\n        leaseAccessConditions: options.leaseAccessConditions,\n        tracingOptions: { ...options!.tracingOptions, spanOptions }\n      });\n\n      const numBlocks: number = Math.floor((size - 1) / options.rangeSize) + 1;\n      let transferProgress: number = 0;\n\n      const batch = new Batch(options.concurrency);\n      for (let i = 0; i < numBlocks; i++) {\n        batch.addOperation(\n          async (): Promise<any> => {\n            const start = options.rangeSize! * i;\n            const end = i === numBlocks - 1 ? size : start + options.rangeSize!;\n            const contentLength = end - start;\n            await this.uploadRange(blobFactory(start, contentLength), start, contentLength, {\n              abortSignal: options.abortSignal,\n              leaseAccessConditions: options.leaseAccessConditions,\n              tracingOptions: { ...options!.tracingOptions, spanOptions }\n            });\n            // Update progress after block is successfully uploaded to server, in case of block trying\n            // TODO: Hook with convenience layer progress event in finer level\n            transferProgress += contentLength;\n            if (options.onProgress) {\n              options.onProgress({ loadedBytes: transferProgress });\n            }\n          }\n        );\n      }\n      return await batch.do();\n    } catch (e) {\n      span.setStatus({\n        code: CanonicalCode.UNKNOWN,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * ONLY AVAILABLE IN NODE.JS RUNTIME.\n   *\n   * Uploads a local file to an Azure file.\n   *\n   * @param {string} filePath Full path of local file\n   * @param {ShareFileClient} fileClient ShareFileClient\n   * @param {FileParallelUploadOptions} [options]\n   * @returns {(Promise<void>)}\n   */\n  public async uploadFile(\n    filePath: string,\n    options: FileParallelUploadOptions = {}\n  ): Promise<void> {\n    const { span, spanOptions } = createSpan(\"ShareFileClient-uploadFile\", options.tracingOptions);\n    try {\n      const size = (await fsStat(filePath)).size;\n      return await this.uploadResetableStream(\n        (offset, count) =>\n          fsCreateReadStream(filePath, {\n            autoClose: true,\n            end: count ? offset + count - 1 : Infinity,\n            start: offset\n          }),\n        size,\n        { ...options, tracingOptions: { ...options!.tracingOptions, spanOptions } }\n      );\n    } catch (e) {\n      span.setStatus({\n        code: CanonicalCode.UNKNOWN,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * ONLY AVAILABLE IN NODE.JS RUNTIME.\n   *\n   * Accepts a Node.js Readable stream factory, and uploads in blocks to an Azure File.\n   * The Readable stream factory must returns a Node.js Readable stream starting from the offset defined. The offset\n   * is the offset in the Azure file to be uploaded.\n   *\n   * @export\n   * @param {(offset: number) => NodeJS.ReadableStream} streamFactory Returns a Node.js Readable stream starting\n   *                                                                  from the offset defined\n   * @param {number} size Size of the Azure file\n   * @param {ShareFileClient} fileClient ShareFileClient\n   * @param {FileParallelUploadOptions} [options]\n   * @returns {(Promise<void>)}\n   */\n  async uploadResetableStream(\n    streamFactory: (offset: number, count?: number) => NodeJS.ReadableStream,\n    size: number,\n    options: FileParallelUploadOptions = {}\n  ): Promise<void> {\n    const { span, spanOptions } = createSpan(\n      \"ShareFileClient-uploadResetableStream\",\n      options.tracingOptions\n    );\n    try {\n      if (!options.rangeSize) {\n        options.rangeSize = FILE_RANGE_MAX_SIZE_BYTES;\n      }\n      if (options.rangeSize < 0 || options.rangeSize > FILE_RANGE_MAX_SIZE_BYTES) {\n        throw new RangeError(`options.rangeSize must be > 0 and <= ${FILE_RANGE_MAX_SIZE_BYTES}`);\n      }\n\n      if (!options.fileHttpHeaders) {\n        options.fileHttpHeaders = {};\n      }\n\n      if (!options.concurrency) {\n        options.concurrency = DEFAULT_HIGH_LEVEL_CONCURRENCY;\n      }\n      if (options.concurrency < 0) {\n        throw new RangeError(`options.concurrency cannot less than 0.`);\n      }\n\n      // Create the file\n      await this.create(size, {\n        abortSignal: options.abortSignal,\n        fileHttpHeaders: options.fileHttpHeaders,\n        metadata: options.metadata,\n        leaseAccessConditions: options.leaseAccessConditions,\n        tracingOptions: { ...options!.tracingOptions, spanOptions }\n      });\n\n      const numBlocks: number = Math.floor((size - 1) / options.rangeSize) + 1;\n      let transferProgress: number = 0;\n      const batch = new Batch(options.concurrency);\n\n      for (let i = 0; i < numBlocks; i++) {\n        batch.addOperation(\n          async (): Promise<any> => {\n            const start = options.rangeSize! * i;\n            const end = i === numBlocks - 1 ? size : start + options.rangeSize!;\n            const contentLength = end - start;\n            await this.uploadRange(\n              () => streamFactory(start, contentLength),\n              start,\n              contentLength,\n              {\n                abortSignal: options.abortSignal,\n                leaseAccessConditions: options.leaseAccessConditions,\n                tracingOptions: { ...options!.tracingOptions, spanOptions }\n              }\n            );\n            // Update progress after block is successfully uploaded to server, in case of block trying\n            transferProgress += contentLength;\n            if (options.onProgress) {\n              options.onProgress({ loadedBytes: transferProgress });\n            }\n          }\n        );\n      }\n      return await batch.do();\n    } catch (e) {\n      span.setStatus({\n        code: CanonicalCode.UNKNOWN,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * ONLY AVAILABLE IN NODE.JS RUNTIME.\n   *\n   * @export\n   * @param {(offset: number, count: number) => Buffer} bufferChunk Returns a Node.js Buffer chunk starting\n   *                                                                  from the offset defined till the count\n   * @param {number} size Size of the Azure file\n   * @param {ShareFileClient} fileClient ShareFileClient\n   * @param {FileParallelUploadOptions} [options]\n   * @returns {(Promise<void>)}\n   */\n  private async uploadBuffer(\n    bufferChunk: (offset: number, count: number) => Buffer,\n    size: number,\n    options: FileParallelUploadOptions = {}\n  ): Promise<void> {\n    const { span, spanOptions } = createSpan(\n      \"ShareFileClient-uploadBuffer\",\n      options.tracingOptions\n    );\n    try {\n      if (!options.rangeSize) {\n        options.rangeSize = FILE_RANGE_MAX_SIZE_BYTES;\n      }\n      if (options.rangeSize < 0 || options.rangeSize > FILE_RANGE_MAX_SIZE_BYTES) {\n        throw new RangeError(`options.rangeSize must be > 0 and <= ${FILE_RANGE_MAX_SIZE_BYTES}`);\n      }\n\n      if (!options.fileHttpHeaders) {\n        options.fileHttpHeaders = {};\n      }\n\n      if (!options.concurrency) {\n        options.concurrency = DEFAULT_HIGH_LEVEL_CONCURRENCY;\n      }\n      if (options.concurrency < 0) {\n        throw new RangeError(`options.concurrency cannot less than 0.`);\n      }\n\n      // Create the file\n      await this.create(size, {\n        abortSignal: options.abortSignal,\n        fileHttpHeaders: options.fileHttpHeaders,\n        metadata: options.metadata,\n        leaseAccessConditions: options.leaseAccessConditions,\n        tracingOptions: { ...options!.tracingOptions, spanOptions }\n      });\n\n      const numBlocks: number = Math.floor((size - 1) / options.rangeSize) + 1;\n      let transferProgress: number = 0;\n      const batch = new Batch(options.concurrency);\n\n      for (let i = 0; i < numBlocks; i++) {\n        batch.addOperation(\n          async (): Promise<any> => {\n            const start = options.rangeSize! * i;\n            const end = i === numBlocks - 1 ? size : start + options.rangeSize!;\n            const contentLength = end - start;\n            await this.uploadRange(bufferChunk(start, contentLength), start, contentLength, {\n              abortSignal: options.abortSignal,\n              leaseAccessConditions: options.leaseAccessConditions,\n              tracingOptions: { ...options!.tracingOptions, spanOptions }\n            });\n            // Update progress after block is successfully uploaded to server, in case of block trying\n            transferProgress += contentLength;\n            if (options.onProgress) {\n              options.onProgress({ loadedBytes: transferProgress });\n            }\n          }\n        );\n      }\n      return await batch.do();\n    } catch (e) {\n      span.setStatus({\n        code: CanonicalCode.UNKNOWN,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * ONLY AVAILABLE IN NODE.JS RUNTIME.\n   *\n   * Downloads an Azure file in parallel to a buffer.\n   * Offset and count are optional, pass 0 for both to download the entire file.\n   *\n   * Warning: Buffers can only support files up to about one gigabyte on 32-bit systems or about two\n   * gigabytes on 64-bit systems due to limitations of Node.js/V8. For files larger than this size,\n   * consider {@link downloadToFile}.\n   *\n   * @param {Buffer} buffer Buffer to be fill, must have length larger than count\n   * @param {number} offset From which position of the Azure File to download\n   * @param {number} [count] How much data to be downloaded. Will download to the end when passing undefined\n   * @param {FileDownloadToBufferOptions} [options]\n   * @returns {Promise<Buffer>}\n   */\n  public async downloadToBuffer(\n    buffer: Buffer,\n    offset?: number,\n    count?: number,\n    options?: FileDownloadToBufferOptions\n  ): Promise<Buffer>;\n\n  /**\n   * ONLY AVAILABLE IN NODE.JS RUNTIME\n   *\n   * Downloads an Azure file in parallel to a buffer.\n   * Offset and count are optional, pass 0 for both to download the entire file\n   *\n   * Warning: Buffers can only support files up to about one gigabyte on 32-bit systems or about two\n   * gigabytes on 64-bit systems due to limitations of Node.js/V8. For files larger than this size,\n   * consider {@link downloadToFile}.\n   *\n   * @param {number} offset From which position of the Azure file to download\n   * @param {number} [count] How much data to be downloaded. Will download to the end when passing undefined\n   * @param {FileDownloadToBufferOptions} [options]\n   * @returns {Promise<Buffer>}\n   */\n  public async downloadToBuffer(\n    offset?: number,\n    count?: number,\n    options?: FileDownloadToBufferOptions\n  ): Promise<Buffer>;\n\n  public async downloadToBuffer(\n    bufferOrOffset?: Buffer | number,\n    offsetOrCount?: number,\n    countOrOptions?: FileDownloadToBufferOptions | number,\n    optOptions: FileDownloadToBufferOptions = {}\n  ): Promise<Buffer> {\n    let buffer: Buffer | undefined = undefined;\n    let offset: number;\n    let count: number;\n    let options: FileDownloadToBufferOptions = optOptions;\n\n    if (bufferOrOffset instanceof Buffer) {\n      buffer = bufferOrOffset;\n      offset = offsetOrCount || 0;\n      count = typeof countOrOptions === \"number\" ? countOrOptions : 0;\n    } else {\n      offset = typeof bufferOrOffset === \"number\" ? bufferOrOffset : 0;\n      count = typeof offsetOrCount === \"number\" ? offsetOrCount : 0;\n      options = (countOrOptions as FileDownloadToBufferOptions) || {};\n    }\n\n    const { span, spanOptions } = createSpan(\n      \"ShareFileClient-downloadToBuffer\",\n      options.tracingOptions\n    );\n\n    try {\n      if (!options.rangeSize) {\n        options.rangeSize = FILE_RANGE_MAX_SIZE_BYTES;\n      }\n      if (options.rangeSize < 0) {\n        throw new RangeError(\"rangeSize option must be > 0\");\n      }\n\n      if (offset < 0) {\n        throw new RangeError(\"offset option must be >= 0\");\n      }\n\n      if (count && count <= 0) {\n        throw new RangeError(\"count option must be > 0\");\n      }\n\n      if (!options.concurrency) {\n        options.concurrency = DEFAULT_HIGH_LEVEL_CONCURRENCY;\n      }\n      if (options.concurrency < 0) {\n        throw new RangeError(`options.concurrency cannot less than 0.`);\n      }\n\n      // Customer doesn't specify length, get it\n      if (!count) {\n        const response = await this.getProperties({\n          abortSignal: options.abortSignal,\n          leaseAccessConditions: options.leaseAccessConditions,\n          tracingOptions: { ...options!.tracingOptions, spanOptions }\n        });\n        count = response.contentLength! - offset;\n        if (count < 0) {\n          throw new RangeError(\n            `offset ${offset} shouldn't be larger than file size ${response.contentLength!}`\n          );\n        }\n      }\n\n      if (!buffer) {\n        try {\n          buffer = Buffer.alloc(count);\n        } catch (error) {\n          throw new Error(\n            `Unable to allocate a buffer of size: ${count} bytes. Please try passing your own Buffer to ` +\n              'the \"downloadToBuffer method or try using other methods like \"download\" or \"downloadToFile\".' +\n              `\\t ${error.message}`\n          );\n        }\n      }\n\n      if (buffer.length < count) {\n        throw new RangeError(\n          `The buffer's size should be equal to or larger than the request count of bytes: ${count}`\n        );\n      }\n\n      let transferProgress: number = 0;\n      const batch = new Batch(options.concurrency);\n      for (let off = offset; off < offset + count; off = off + options.rangeSize) {\n        batch.addOperation(async () => {\n          // Exclusive chunk end position\n          let chunkEnd = offset + count!;\n          if (off + options.rangeSize! < chunkEnd) {\n            chunkEnd = off + options.rangeSize!;\n          }\n          const response = await this.download(off, chunkEnd - off, {\n            abortSignal: options.abortSignal,\n            maxRetryRequests: options.maxRetryRequestsPerRange,\n            leaseAccessConditions: options.leaseAccessConditions,\n            tracingOptions: { ...options!.tracingOptions, spanOptions }\n          });\n          const stream = response.readableStreamBody!;\n          await streamToBuffer(stream, buffer!, off - offset, chunkEnd - offset);\n          // Update progress after block is downloaded, in case of block trying\n          // Could provide finer grained progress updating inside HTTP requests,\n          // only if convenience layer download try is enabled\n          transferProgress += chunkEnd - off;\n          if (options.onProgress) {\n            options.onProgress({ loadedBytes: transferProgress });\n          }\n        });\n      }\n      await batch.do();\n      return buffer;\n    } catch (e) {\n      span.setStatus({\n        code: CanonicalCode.UNKNOWN,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * ONLY AVAILABLE IN NODE.JS RUNTIME.\n   *\n   * Uploads a Node.js Readable stream into an Azure file.\n   * This method will try to create an Azure, then starts uploading chunk by chunk.\n   * Size of chunk is defined by `bufferSize` parameter.\n   * Please make sure potential size of stream doesn't exceed file size.\n   *\n   * PERFORMANCE IMPROVEMENT TIPS:\n   * * Input stream highWaterMark is better to set a same value with bufferSize\n   *   parameter, which will avoid Buffer.concat() operations.\n   *\n   * @param {Readable} stream Node.js Readable stream. Must be less or equal than file size.\n   * @param {number} size Size of file to be created. Maximum size allowed is 1TB.\n   *                      If this value is larger than stream size, there will be empty bytes in file tail.\n   * @param {number} bufferSize Size of every buffer allocated in bytes, also the chunk/range size during\n   *                            the uploaded file. Size must be > 0 and <= 4 * 1024 * 1024 (4MB)\n   * @param {number} maxBuffers Max buffers will allocate during uploading, positive correlation\n   *                            with max uploading concurrency\n   * @param {FileUploadStreamOptions} [options]\n   * @returns {Promise<void>}\n   */\n  public async uploadStream(\n    stream: Readable,\n    size: number,\n    bufferSize: number,\n    maxBuffers: number,\n    options: FileUploadStreamOptions = {}\n  ): Promise<void> {\n    const { span, spanOptions } = createSpan(\n      \"ShareFileClient-uploadStream\",\n      options.tracingOptions\n    );\n    try {\n      if (!options.fileHttpHeaders) {\n        options.fileHttpHeaders = {};\n      }\n\n      if (bufferSize <= 0 || bufferSize > FILE_RANGE_MAX_SIZE_BYTES) {\n        throw new RangeError(`bufferSize must be > 0 and <= ${FILE_RANGE_MAX_SIZE_BYTES}`);\n      }\n\n      if (maxBuffers < 0) {\n        throw new RangeError(`maxBuffers must be > 0.`);\n      }\n\n      // Create the file\n      await this.create(size, {\n        abortSignal: options.abortSignal,\n        fileHttpHeaders: options.fileHttpHeaders,\n        metadata: options.metadata,\n        leaseAccessConditions: options.leaseAccessConditions,\n        tracingOptions: { ...options!.tracingOptions, spanOptions }\n      });\n\n      let transferProgress: number = 0;\n      const scheduler = new BufferScheduler(\n        stream,\n        bufferSize,\n        maxBuffers,\n        async (buffer: Buffer, offset?: number) => {\n          if (transferProgress + buffer.length > size) {\n            throw new RangeError(\n              `Stream size is larger than file size ${size} bytes, uploading failed. ` +\n                `Please make sure stream length is less or equal than file size.`\n            );\n          }\n\n          await this.uploadRange(buffer, offset!, buffer.length, {\n            abortSignal: options.abortSignal,\n            leaseAccessConditions: options.leaseAccessConditions,\n            tracingOptions: { ...options!.tracingOptions, spanOptions }\n          });\n\n          // Update progress after block is successfully uploaded to server, in case of block trying\n          transferProgress += buffer.length;\n          if (options.onProgress) {\n            options.onProgress({ loadedBytes: transferProgress });\n          }\n        },\n        // Concurrency should set a smaller value than maxBuffers, which is helpful to\n        // reduce the possibility when a outgoing handler waits for stream data, in\n        // this situation, outgoing handlers are blocked.\n        // Outgoing queue shouldn't be empty.\n        Math.ceil((maxBuffers / 4) * 3)\n      );\n      return await scheduler.do();\n    } catch (e) {\n      span.setStatus({\n        code: CanonicalCode.UNKNOWN,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * ONLY AVAILABLE IN NODE.JS RUNTIME.\n   *\n   * Downloads an Azure Blob to a local file.\n   * Fails if the the given file path already exits.\n   * Offset and count are optional, pass 0 and undefined respectively to download the entire blob.\n   *\n   * @param {string} filePath\n   * @param {number} [offset] From which position of the block blob to download.\n   * @param {number} [count] How much data to be downloaded. Will download to the end when passing undefined.\n   * @param {BlobDownloadOptions} [options] Options to Blob download options.\n   * @returns {Promise<FileDownloadResponse>} The response data for blob download operation,\n   *                                                 but with readableStreamBody set to undefined since its\n   *                                                 content is already read and written into a local file\n   *                                                 at the specified path.\n   * @memberof BlobClient\n   */\n  public async downloadToFile(\n    filePath: string,\n    offset: number = 0,\n    count?: number,\n    options: FileDownloadOptions = {}\n  ): Promise<FileDownloadResponseModel> {\n    const { span, spanOptions } = createSpan(\n      \"ShareFileClient-downloadToFile\",\n      options.tracingOptions\n    );\n    try {\n      const response = await this.download(offset, count, {\n        ...options,\n        tracingOptions: { ...options!.tracingOptions, spanOptions }\n      });\n      if (response.readableStreamBody) {\n        await readStreamToLocalFile(response.readableStreamBody, filePath);\n      }\n\n      // The stream is no longer accessible so setting it to undefined.\n      (response as any).fileDownloadStream = undefined;\n      return response;\n    } catch (e) {\n      span.setStatus({\n        code: CanonicalCode.UNKNOWN,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Lists handles for a file.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/list-handles\n   *\n   * @param {string} [marker] Optional. A string value that identifies the portion of the list to be\n   *                          returned with the next list handles operation. The operation returns a\n   *                          marker value within the response body if the list returned was not complete.\n   *                          The marker value may then be used in a subsequent call to request the next\n   *                          set of list items.\n   * @param {FileListHandlesSegmentOptions} [options={}]\n   * @returns {Promise<FileListHandlesResponse>}\n   * @memberof FileURL\n   */\n  private async listHandlesSegment(\n    marker?: string,\n    options: FileListHandlesSegmentOptions = {}\n  ): Promise<FileListHandlesResponse> {\n    const { span, spanOptions } = createSpan(\n      \"ShareFileClient-listHandlesSegment\",\n      options.tracingOptions\n    );\n    try {\n      marker = marker === \"\" ? undefined : marker;\n      const response = await this.context.listHandles({\n        abortSignal: options.abortSignal,\n        marker,\n        ...options,\n        spanOptions\n      });\n\n      // TODO: Protocol layer issue that when handle list is in returned XML\n      // response.handleList is an empty string\n      if ((response.handleList as any) === \"\") {\n        response.handleList = undefined;\n      }\n      return response;\n    } catch (e) {\n      span.setStatus({\n        code: CanonicalCode.UNKNOWN,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Returns an AsyncIterableIterator for FileListHandlesResponse\n   *\n   * @private\n   * @param {string} [marker] A string value that identifies the portion of the list to be\n   *                          returned with the next list handles operation. The operation returns a\n   *                          marker value within the response body if the list returned was not complete.\n   *                          The marker value may then be used in a subsequent call to request the next\n   *                          set of list items.\n   * @param {FileListHandlesSegmentOptions} [options] Options to list handles operation.\n   * @returns {AsyncIterableIterator<FileListHandlesResponse>}\n   * @memberof ShareFileClient\n   */\n  private async *iterateHandleSegments(\n    marker?: string,\n    options: FileListHandlesSegmentOptions = {}\n  ): AsyncIterableIterator<FileListHandlesResponse> {\n    let listHandlesResponse;\n    if (!!marker || marker === undefined) {\n      do {\n        listHandlesResponse = await this.listHandlesSegment(marker, options);\n        marker = listHandlesResponse.continuationToken;\n        yield listHandlesResponse;\n      } while (marker);\n    }\n  }\n\n  /**\n   * Returns an AsyncIterableIterator for handles\n   *\n   * @private\n   * @param {FileListHandlesSegmentOptions} [options] Options to list handles operation.\n   * @returns {AsyncIterableIterator<HandleItem>}\n   * @memberof ShareFileClient\n   */\n  private async *listHandleItems(\n    options: FileListHandlesSegmentOptions = {}\n  ): AsyncIterableIterator<HandleItem> {\n    let marker: string | undefined;\n    for await (const listHandlesResponse of this.iterateHandleSegments(marker, options)) {\n      if (listHandlesResponse.handleList) {\n        for (const handle of listHandlesResponse.handleList) {\n          yield handle;\n        }\n      }\n    }\n  }\n\n  /**\n   * Returns an async iterable iterator to list all the handles.\n   * under the specified account.\n   *\n   * .byPage() returns an async iterable iterator to list the handles in pages.\n   *\n   * @param {FileListHandlesOptions} [options] Options to list handles operation.\n   * @memberof ShareFileClient\n   * @returns {PagedAsyncIterableIterator<HandleItem, FileListHandlesResponse>}\n   * An asyncIterableIterator that supports paging.\n   */\n  public listHandles(\n    options: FileListHandlesOptions = {}\n  ): PagedAsyncIterableIterator<HandleItem, FileListHandlesResponse> {\n    // an AsyncIterableIterator to iterate over handles\n    const iter = this.listHandleItems(options);\n    return {\n      /**\n       * @member {Promise} [next] The next method, part of the iteration protocol\n       */\n      async next() {\n        return iter.next();\n      },\n      /**\n       * @member {Symbol} [asyncIterator] The connection to the async iterator, part of the iteration protocol\n       */\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n      /**\n       * @member {Function} [byPage] Return an AsyncIterableIterator that works a page at a time\n       */\n      byPage: (settings: PageSettings = {}) => {\n        return this.iterateHandleSegments(settings.continuationToken, {\n          maxPageSize: settings.maxPageSize,\n          ...options\n        });\n      }\n    };\n  }\n\n  /**\n   * Force close all handles for a file.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/force-close-handles\n   *\n   * @param {string} [marker] Optional. A string value that identifies the position of handles that will\n   *                          be closed with the next force close handles operation.\n   *                          The operation returns a marker value within the response\n   *                          body if there are more handles to close. The marker value\n   *                          may then be used in a subsequent call to close the next set of handles.\n   * @param {FileForceCloseHandlesOptions} [options] Options to force close handles operation.\n   * @returns {Promise<FileForceCloseHandlesResponse>}\n   * @memberof ShareFileClient\n   */\n  private async forceCloseHandlesSegment(\n    marker?: string,\n    options: FileForceCloseHandlesOptions = {}\n  ): Promise<FileForceCloseHandlesResponse> {\n    const { span, spanOptions } = createSpan(\n      \"ShareFileClient-forceCloseHandlesSegment\",\n      options.tracingOptions\n    );\n    try {\n      marker = marker === \"\" ? undefined : marker;\n      const rawResponse = await this.context.forceCloseHandles(\"*\", {\n        abortSignal: options.abortSignal,\n        marker,\n        spanOptions\n      });\n      const response = rawResponse as FileForceCloseHandlesResponse;\n      response.closedHandlesCount = rawResponse.numberOfHandlesClosed || 0;\n      response.closeFailureCount = rawResponse.numberOfHandlesFailedToClose || 0;\n      return response;\n    } catch (e) {\n      span.setStatus({\n        code: CanonicalCode.UNKNOWN,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Force close all handles for a file.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/force-close-handles\n   *\n   * @param {FileForceCloseHandlesOptions} [options] Options to force close handles operation.\n   * @returns {Promise<CloseHandlesInfo>}\n   * @memberof ShareFileClient\n   */\n  public async forceCloseAllHandles(\n    options: FileForceCloseHandlesOptions = {}\n  ): Promise<CloseHandlesInfo> {\n    const { span, spanOptions } = createSpan(\n      \"ShareFileClient-forceCloseAllHandles\",\n      options.tracingOptions\n    );\n    try {\n      let handlesClosed = 0;\n      let numberOfHandlesFailedToClose = 0;\n      let marker: string | undefined = \"\";\n\n      do {\n        const response: FileForceCloseHandlesResponse = await this.forceCloseHandlesSegment(\n          marker,\n          { tracingOptions: { ...options!.tracingOptions, spanOptions } }\n        );\n        marker = response.marker;\n        response.closedHandlesCount && (handlesClosed += response.closedHandlesCount);\n        response.closeFailureCount && (numberOfHandlesFailedToClose += response.closeFailureCount);\n      } while (marker);\n\n      return {\n        closedHandlesCount: handlesClosed,\n        closeFailureCount: numberOfHandlesFailedToClose\n      };\n    } catch (e) {\n      span.setStatus({\n        code: CanonicalCode.UNKNOWN,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Force close a specific handle for a file.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/force-close-handles\n   *\n   * @param {string} handleId Specific handle ID, cannot be asterisk \"*\".\n   *                          Use forceCloseAllHandles() to close all handles.\n   * @param FileForceCloseHandlesOptions} [options] Options to force close handles operation.\n   * @returns {Promise<FileForceCloseHandlesResponse>}\n   * @memberof ShareFileClient\n   */\n  public async forceCloseHandle(\n    handleId: string,\n    options: FileForceCloseHandlesOptions = {}\n  ): Promise<FileForceCloseHandlesResponse> {\n    const { span, spanOptions } = createSpan(\n      \"ShareFileClient-forceCloseHandle\",\n      options.tracingOptions\n    );\n    try {\n      if (handleId === \"*\") {\n        throw new RangeError(\n          `Parameter handleID should be a specified handle ID. Use forceCloseHandlesSegment() to close all handles.`\n        );\n      }\n\n      const rawResponse = await this.context.forceCloseHandles(handleId, {\n        abortSignal: options.abortSignal,\n        spanOptions\n      });\n      const response = rawResponse as FileForceCloseHandlesResponse;\n      response.closedHandlesCount = rawResponse.numberOfHandlesClosed || 0;\n      response.closeFailureCount = rawResponse.numberOfHandlesFailedToClose || 0;\n      return response;\n    } catch (e) {\n      span.setStatus({\n        code: CanonicalCode.UNKNOWN,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Get a {@link ShareLeaseClient} that manages leases on the file.\n   *\n   * @param {string} [proposeLeaseId] Initial proposed lease Id.\n   * @returns {ShareLeaseClient} A new ShareLeaseClient object for managing leases on the file.\n   * @memberof ShareFileClient\n   */\n  public getShareLeaseClient(proposeLeaseId?: string): ShareLeaseClient {\n    return new ShareLeaseClient(this, proposeLeaseId);\n  }\n}\n\n/**\n * The details of the response for a specific lease operation.\n */\nexport interface LeaseOperationResponseHeaders {\n  /**\n   * The ETag contains a value that you can use to perform operations conditionally. If the request\n   * version is 2011-08-18 or newer, the ETag value will be in quotes.\n   */\n  etag?: string;\n  /**\n   * Returns the date and time the file was last modified. Any operation that modifies the file,\n   * including an update of the file's metadata or properties, changes the last-modified time of\n   * the file.\n   */\n  lastModified?: Date;\n  /**\n   * Uniquely identifies a file's lease, won't be set when returned by releaseLease.\n   */\n  leaseId?: string;\n  /**\n   * This header uniquely identifies the request that was made and can be used for troubleshooting\n   * the request.\n   */\n  requestId?: string;\n  /**\n   * Indicates the version of the Blob service used to execute the request. This header is returned\n   * for requests made against version 2009-09-19 and above.\n   */\n  version?: string;\n  /**\n   * UTC date/time value generated by the service that indicates the time at which the response was\n   * initiated\n   */\n  date?: Date;\n  errorCode?: string;\n}\n\n/**\n * Contains the response data for operations that acquire, change, break or release a lease.\n *\n * See {@link ShareLeaseClient}.\n */\nexport type LeaseOperationResponse = LeaseOperationResponseHeaders & {\n  /**\n   * The underlying HTTP response.\n   */\n  _response: HttpResponse & {\n    /**\n     * The parsed HTTP response headers.\n     */\n    parsedHeaders: LeaseOperationResponseHeaders;\n  };\n};\n\n/**\n * lease operations options.\n *\n * @export\n * @interface LeaseOperationOptions\n */\nexport interface LeaseOperationOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   *\n   * @type {AbortSignalLike}\n   * @memberof LeaseOperationOptions\n   */\n  abortSignal?: AbortSignalLike;\n}\n\n/**\n * A client that manages leases for a {@link ShareFileClient}.\n *\n * @export\n * @class ShareLeaseClient\n */\nexport class ShareLeaseClient {\n  private _leaseId: string;\n  private _url: string;\n  private _file: File;\n  /**\n   * Gets the lease Id.\n   *\n   * @readonly\n   * @memberof ShareLeaseClient\n   * @type {string}\n   */\n  public get leaseId(): string {\n    return this._leaseId;\n  }\n\n  /**\n   * Gets the url.\n   *\n   * @readonly\n   * @memberof ShareLeaseClient\n   * @type {string}\n   */\n  public get url(): string {\n    return this._url;\n  }\n\n  /**\n   * Creates an instance of ShareLeaseClient.\n   * @param {ShareFileClient} client The client to make the lease operation requests.\n   * @param {string} leaseId Initial proposed lease id.\n   * @memberof ShareLeaseClient\n   */\n  constructor(client: ShareFileClient, leaseId?: string) {\n    const clientContext = new StorageClientContext(\n      SERVICE_VERSION,\n      client.url,\n      (client as any).pipeline.toServiceClientOptions()\n    );\n    this._file = new File(clientContext);\n\n    this._url = client.url;\n\n    if (!leaseId) {\n      leaseId = generateUuid();\n    }\n    this._leaseId = leaseId;\n  }\n\n  /**\n   * The Lease File operation establishes and manages a lock on a file for write and delete operations.\n   *\n   * @param {number} duration Specifies the duration of lease. The only allowed value is -1, for a lease that never expires.\n   * @param {LeaseOperationOptions} [options={}] Options for the lease management operation.\n   * @returns {Promise<LeaseOperationResponse>} Response data for acquire lease operation.\n   * @memberof ShareLeaseClient\n   */\n  public async acquireLease(\n    duration = -1,\n    options: LeaseOperationOptions = {}\n  ): Promise<LeaseOperationResponse> {\n    const { span, spanOptions } = createSpan(\n      \"ShareLeaseClient-acquireLease\",\n      options.tracingOptions\n    );\n    try {\n      return await this._file.acquireLease({\n        abortSignal: options.abortSignal,\n        duration,\n        proposedLeaseId: this._leaseId,\n        spanOptions\n      });\n    } catch (e) {\n      span.setStatus({\n        code: CanonicalCode.UNKNOWN,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * To change the ID of an existing lease.\n   *\n   * @param {string} proposedLeaseId the proposed new lease Id.\n   * @param {LeaseOperationOptions} [options={}] Options for the lease management operation.\n   * @returns {Promise<LeaseOperationResponse>} Response data for change lease operation.\n   * @memberof ShareLeaseClient\n   */\n  public async changeLease(\n    proposedLeaseId: string,\n    options: LeaseOperationOptions = {}\n  ): Promise<LeaseOperationResponse> {\n    const { span, spanOptions } = createSpan(\n      \"ShareLeaseClient-changeLease\",\n      options.tracingOptions\n    );\n    try {\n      const response = await this._file.changeLease(this._leaseId, {\n        proposedLeaseId,\n        abortSignal: options.abortSignal,\n        spanOptions\n      });\n      this._leaseId = proposedLeaseId;\n      return response;\n    } catch (e) {\n      span.setStatus({\n        code: CanonicalCode.UNKNOWN,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * To free the lease if it is no longer needed so that another client may\n   * immediately acquire a lease against the file.\n   *\n   * @param {LeaseOperationOptions} [options={}] Options for the lease management operation.\n   * @returns {Promise<LeaseOperationResponse>} Response data for release lease operation.\n   * @memberof ShareLeaseClient\n   */\n  public async releaseLease(options: LeaseOperationOptions = {}): Promise<LeaseOperationResponse> {\n    const { span, spanOptions } = createSpan(\n      \"ShareLeaseClient-releaseLease\",\n      options.tracingOptions\n    );\n    try {\n      return await this._file.releaseLease(this._leaseId, {\n        abortSignal: options.abortSignal,\n        spanOptions\n      });\n    } catch (e) {\n      span.setStatus({\n        code: CanonicalCode.UNKNOWN,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * To force end the lease.\n   *\n   * @param {LeaseOperationOptions} [options={}] Options for the lease management operation.\n   * @returns {Promise<LeaseOperationResponse>} Response data for break lease operation.\n   * @memberof ShareLeaseClient\n   */\n  public async breakLease(options: LeaseOperationOptions = {}): Promise<LeaseOperationResponse> {\n    const { span, spanOptions } = createSpan(\"ShareLeaseClient-breakLease\", options.tracingOptions);\n    try {\n      return await this._file.breakLease({\n        abortSignal: options.abortSignal,\n        spanOptions\n      });\n    } catch (e) {\n      span.setStatus({\n        code: CanonicalCode.UNKNOWN,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n}\n"]}
/// <reference types="node" />
import { AbortSignalLike } from '@azure/abort-controller';
import { BaseRequestPolicy } from '@azure/core-http';
import * as coreHttp from '@azure/core-http';
import { deserializationPolicy } from '@azure/core-http';
import { HttpHeaders } from '@azure/core-http';
import { HttpOperationResponse } from '@azure/core-http';
import { HttpRequestBody } from '@azure/core-http';
import { HttpResponse } from '@azure/core-http';
import { HttpClient as IHttpClient } from '@azure/core-http';
import { KeepAliveOptions } from '@azure/core-http';
import { OperationTracingOptions } from '@azure/core-tracing';
import { PagedAsyncIterableIterator } from '@azure/core-paging';
import { ProxyOptions } from '@azure/core-http';
import { Readable } from 'stream';
import { RequestPolicy } from '@azure/core-http';
import { RequestPolicyFactory } from '@azure/core-http';
import { RequestPolicyOptions } from '@azure/core-http';
import { RestError } from '@azure/core-http';
import { ServiceClientOptions } from '@azure/core-http';
import { TransferProgressEvent } from '@azure/core-http';
import { UserAgentOptions } from '@azure/core-http';
import { WebResource } from '@azure/core-http';
/**
 * An Access policy.
 */
export declare interface AccessPolicy {
    /**
     * The date-time the policy is active.
     * **NOTE: This entity will be treated as a string instead of a Date because the API can
     * potentially deal with a higher precision value than what is supported by JavaScript.**
     */
    startsOn?: string;
    /**
     * The date-time the policy expires.
     * **NOTE: This entity will be treated as a string instead of a Date because the API can
     * potentially deal with a higher precision value than what is supported by JavaScript.**
     */
    expiresOn?: string;
    /**
     * The permissions for the ACL policy.
     */
    permissions?: string;
}
/**
 * ONLY AVAILABLE IN NODE.JS RUNTIME.
 *
 * This is a helper class to construct a string representing the permissions granted by an AccountSAS. Setting a value
 * to true means that any SAS which uses these permissions will grant permissions for that operation. Once all the
 * values are set, this should be serialized with toString and set as the permissions field on an
 * {@link AccountSASSignatureValues} object. It is possible to construct the permissions string without this class, but
 * the order of the permissions is particular and this class guarantees correctness.
 *
 * @export
 * @class AccountSASPermissions
 */
export declare class AccountSASPermissions {
    /**
     * Parse initializes the AccountSASPermissions fields from a string.
     *
     * @static
     * @param {string} permissions
     * @returns {AccountSASPermissions}
     * @memberof AccountSASPermissions
     */
    static parse(permissions: string): AccountSASPermissions;
    /**
     * Permission to read resources and list queues and tables granted.
     *
     * @type {boolean}
     * @memberof AccountSASPermissions
     */
    read: boolean;
    /**
     * Permission to write resources granted.
     *
     * @type {boolean}
     * @memberof AccountSASPermissions
     */
    write: boolean;
    /**
     * Permission to delete blobs and files granted.
     *
     * @type {boolean}
     * @memberof AccountSASPermissions
     */
    delete: boolean;
    /**
     * Permission to list blob containers, blobs, shares, directories, and files granted.
     *
     * @type {boolean}
     * @memberof AccountSASPermissions
     */
    list: boolean;
    /**
     * Permission to add messages, table entities, and append to blobs granted.
     *
     * @type {boolean}
     * @memberof AccountSASPermissions
     */
    add: boolean;
    /**
     * Permission to create blobs and files granted.
     *
     * @type {boolean}
     * @memberof AccountSASPermissions
     */
    create: boolean;
    /**
     * Permissions to update messages and table entities granted.
     *
     * @type {boolean}
     * @memberof AccountSASPermissions
     */
    update: boolean;
    /**
     * Permission to get and delete messages granted.
     *
     * @type {boolean}
     * @memberof AccountSASPermissions
     */
    process: boolean;
    /**
     * Produces the SAS permissions string for an Azure Storage account.
     * Call this method to set AccountSASSignatureValues Permissions field.
     *
     * Using this method will guarantee the resource types are in
     * an order accepted by the service.
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/constructing-an-account-sas
     *
     * @returns {string}
     * @memberof AccountSASPermissions
     */
    toString(): string;
}
/**
 * ONLY AVAILABLE IN NODE.JS RUNTIME.
 *
 * This is a helper class to construct a string representing the resources accessible by an AccountSAS. Setting a value
 * to true means that any SAS which uses these permissions will grant access to that resource type. Once all the
 * values are set, this should be serialized with toString and set as the resources field on an
 * {@link AccountSASSignatureValues} object. It is possible to construct the resources string without this class, but
 * the order of the resources is particular and this class guarantees correctness.
 *
 * @export
 * @class AccountSASResourceTypes
 */
export declare class AccountSASResourceTypes {
    /**
     * Creates an {@link AccountSASResourceTypes} from the specified resource types string. This method will throw an
     * Error if it encounters a character that does not correspond to a valid resource type.
     *
     * @static
     * @param {string} resourceTypes
     * @returns {AccountSASResourceTypes}
     * @memberof AccountSASResourceTypes
     */
    static parse(resourceTypes: string): AccountSASResourceTypes;
    /**
     * Permission to access service level APIs granted.
     *
     * @type {boolean}
     * @memberof AccountSASResourceTypes
     */
    service: boolean;
    /**
     * Permission to access container level APIs (Blob Containers, Tables, Queues, File Shares) granted.
     *
     * @type {boolean}
     * @memberof AccountSASResourceTypes
     */
    container: boolean;
    /**
     * Permission to access object level APIs (Blobs, Table Entities, Queue Messages, Files) granted.
     *
     * @type {boolean}
     * @memberof AccountSASResourceTypes
     */
    object: boolean;
    /**
     * Converts the given resource types to a string.
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/constructing-an-account-sas
     *
     * @returns {string}
     * @memberof AccountSASResourceTypes
     */
    toString(): string;
}
/**
 * ONLY AVAILABLE IN NODE.JS RUNTIME.
 *
 * This is a helper class to construct a string representing the services accessible by an AccountSAS. Setting a value
 * to true means that any SAS which uses these permissions will grant access to that service. Once all the
 * values are set, this should be serialized with toString and set as the services field on an
 * {@link AccountSASSignatureValues} object. It is possible to construct the services string without this class, but
 * the order of the services is particular and this class guarantees correctness.
 *
 * @export
 * @class AccountSASServices
 */
export declare class AccountSASServices {
    /**
     * Creates an {@link AccountSASServices} from the specified services string. This method will throw an
     * Error if it encounters a character that does not correspond to a valid service.
     *
     * @static
     * @param {string} services
     * @returns {AccountSASServices}
     * @memberof AccountSASServices
     */
    static parse(services: string): AccountSASServices;
    /**
     * Permission to access blob resources granted.
     *
     * @type {boolean}
     * @memberof AccountSASServices
     */
    blob: boolean;
    /**
     * Permission to access file resources granted.
     *
     * @type {boolean}
     * @memberof AccountSASServices
     */
    file: boolean;
    /**
     * Permission to access queue resources granted.
     *
     * @type {boolean}
     * @memberof AccountSASServices
     */
    queue: boolean;
    /**
     * Permission to access table resources granted.
     *
     * @type {boolean}
     * @memberof AccountSASServices
     */
    table: boolean;
    /**
     * Converts the given services to a string.
     *
     * @returns {string}
     * @memberof AccountSASServices
     */
    toString(): string;
}
/**
 * ONLY AVAILABLE IN NODE.JS RUNTIME.
 *
 * AccountSASSignatureValues is used to generate a Shared Access Signature (SAS) for an Azure Storage account. Once
 * all the values here are set appropriately, call {@link generateAccountSASQueryParameters} to obtain a representation of the SAS
 * which can actually be applied to file urls. Note: that both this class and {@link SASQueryParameters} exist because
 * the former is mutable and a logical representation while the latter is immutable and used to generate actual REST
 * requests.
 *
 * @see https://docs.microsoft.com/en-us/azure/storage/common/storage-dotnet-shared-access-signature-part-1
 * for more conceptual information on SAS
 *
 * @see https://docs.microsoft.com/en-us/rest/api/storageservices/constructing-an-account-sas
 * for descriptions of the parameters, including which are required
 *
 * @export
 * @class AccountSASSignatureValues
 */
export declare interface AccountSASSignatureValues {
    /**
     * If not provided, this defaults to the service version targeted by this version of the library.
     *
     * @type {string}
     * @memberof AccountSASSignatureValues
     */
    version?: string;
    /**
     * Optional. SAS protocols allowed.
     *
     * @type {SASProtocol}
     * @memberof AccountSASSignatureValues
     */
    protocol?: SASProtocol;
    /**
     * Optional. When the SAS will take effect.
     *
     * @type {Date}
     * @memberof AccountSASSignatureValues
     */
    startsOn?: Date;
    /**
     * The time after which the SAS will no longer work.
     *
     * @type {Date}
     * @memberof AccountSASSignatureValues
     */
    expiresOn: Date;
    /**
     * Specifies which operations the SAS user may perform. Please refer to {@link AccountSASPermissions} for help
     * constructing the permissions string.
     *
     * @type {AccountSASPermissions}
     * @memberof AccountSASSignatureValues
     */
    permissions: AccountSASPermissions;
    /**
     * Optional. IP range allowed.
     *
     * @type {SasIPRange}
     * @memberof AccountSASSignatureValues
     */
    ipRange?: SasIPRange;
    /**
     * The values that indicate the services accessible with this SAS. Please refer to {@link AccountSASServices} to
     * construct this value.
     *
     * @type {string}
     * @memberof AccountSASSignatureValues
     */
    services: string;
    /**
     * The values that indicate the resource types accessible with this SAS. Please refer
     * to {@link AccountSASResourceTypes} to construct this value.
     *
     * @type {string}
     * @memberof AccountSASSignatureValues
     */
    resourceTypes: string;
}
/**
 * AnonymousCredential provides a credentialPolicyCreator member used to create
 * {@link AnonymousCredentialPolicy} objects. AnonymousCredentialPolicy is used with
 * HTTP(S) requests that read public resources or for use with Shared Access
 * Signatures (SAS).
 *
 * @export
 * @class AnonymousCredential
 * @extends {Credential}
 */
export declare class AnonymousCredential extends Credential {
    /**
     * Creates an {@link AnonymousCredentialPolicy} object.
     *
     * @param {RequestPolicy} nextPolicy
     * @param {RequestPolicyOptions} options
     * @returns {AnonymousCredentialPolicy}
     * @memberof AnonymousCredential
     */
    create(nextPolicy: RequestPolicy, options: RequestPolicyOptions): AnonymousCredentialPolicy;
}
/**
 * AnonymousCredentialPolicy is used with HTTP(S) requests that read public resources
 * or for use with Shared Access Signatures (SAS).
 *
 * @export
 * @class AnonymousCredentialPolicy
 * @extends {CredentialPolicy}
 */
export declare class AnonymousCredentialPolicy extends CredentialPolicy {
    /**
     * Creates an instance of AnonymousCredentialPolicy.
     * @param {RequestPolicy} nextPolicy
     * @param {RequestPolicyOptions} options
     * @memberof AnonymousCredentialPolicy
     */
    constructor(nextPolicy: RequestPolicy, options: RequestPolicyOptions);
}
export { BaseRequestPolicy };
/**
 * Close handles result information.
 *
 * @export
 * @interface CloseHandlesInfo
 */
export declare interface CloseHandlesInfo {
    closedHandlesCount: number;
    /**
     * Contains count of number of handles that failed to close.
     */
    closeFailureCount?: number;
}
/**
 * An interface for options common to every remote operation.
 */
export declare interface CommonOptions {
    tracingOptions?: OperationTracingOptions;
}
/**
 * Additional parameters for startCopy operation.
 */
export declare interface CopyFileSmbInfo {
    /**
     * Specifies the option to copy file security descriptor from source file or to set it using the
     * value which is defined by the header value of x-ms-file-permission or
     * x-ms-file-permission-key. Possible values include: 'source', 'override'
     */
    filePermissionCopyMode?: PermissionCopyModeType;
    /**
     * Specifies the option to overwrite the target file if it already exists and has read-only
     * attribute set.
     */
    ignoreReadOnly?: boolean;
    /**
     * Specifies either the option to copy file attributes from a source file(source) to a target
     * file or a list of attributes to set on a target file.
     */
    fileAttributes?: string;
    /**
     * Specifies either the option to copy file creation time from a source file(source) to a target
     * file or a time value in ISO 8601 format to set as creation time on a target file.
     */
    fileCreationTime?: string;
    /**
     * Specifies either the option to copy file last write time from a source file(source) to a
     * target file or a time value in ISO 8601 format to set as last write time on a target file.
     */
    fileLastWriteTime?: string;
    /**
     * Specifies the option to set archive attribute on a target file. True means archive attribute
     * will be set on a target file despite attribute overrides or a source file state.
     */
    setArchiveAttribute?: boolean;
}
/**
 * Defines values for CopyStatusType.
 * Possible values include: 'pending', 'success', 'aborted', 'failed'
 * @readonly
 * @enum {string}
 */
export declare type CopyStatusType = 'pending' | 'success' | 'aborted' | 'failed';
/**
 * CORS is an HTTP feature that enables a web application running under one domain to access
 * resources in another domain. Web browsers implement a security restriction known as same-origin
 * policy that prevents a web page from calling APIs in a different domain; CORS provides a secure
 * way to allow one domain (the origin domain) to call APIs in another domain.
 */
export declare interface CorsRule {
    /**
     * The origin domains that are permitted to make a request against the storage service via CORS.
     * The origin domain is the domain from which the request originates. Note that the origin must
     * be an exact case-sensitive match with the origin that the user age sends to the service. You
     * can also use the wildcard character '*' to allow all origin domains to make requests via CORS.
     */
    allowedOrigins: string;
    /**
     * The methods (HTTP request verbs) that the origin domain may use for a CORS request. (comma
     * separated)
     */
    allowedMethods: string;
    /**
     * The request headers that the origin domain may specify on the CORS request.
     */
    allowedHeaders: string;
    /**
     * The response headers that may be sent in the response to the CORS request and exposed by the
     * browser to the request issuer.
     */
    exposedHeaders: string;
    /**
     * The maximum amount time that a browser should cache the preflight OPTIONS request.
     */
    maxAgeInSeconds: number;
}
/**
 * Credential is an abstract class for Azure Storage HTTP requests signing. This
 * class will host an credentialPolicyCreator factory which generates CredentialPolicy.
 *
 * @export
 * @abstract
 * @class Credential
 */
export declare abstract class Credential implements RequestPolicyFactory {
    /**
     * Creates a RequestPolicy object.
     *
     * @param {RequestPolicy} _nextPolicy
     * @param {RequestPolicyOptions} _options
     * @returns {RequestPolicy}
     * @memberof Credential
     */
    create(_nextPolicy: RequestPolicy, _options: RequestPolicyOptions): RequestPolicy;
}
/**
 * Credential policy used to sign HTTP(S) requests before sending. This is an
 * abstract class.
 *
 * @export
 * @abstract
 * @class CredentialPolicy
 * @extends {BaseRequestPolicy}
 */
export declare abstract class CredentialPolicy extends BaseRequestPolicy {
    /**
     * Sends out request.
     *
     * @param {WebResource} request
     * @returns {Promise<HttpOperationResponse>}
     * @memberof CredentialPolicy
     */
    sendRequest(request: WebResource): Promise<HttpOperationResponse>;
    /**
     * Child classes must implement this method with request signing. This method
     * will be executed in {@link sendRequest}.
     *
     * @protected
     * @abstract
     * @param {WebResource} request
     * @returns {WebResource}
     * @memberof CredentialPolicy
     */
    protected signRequest(request: WebResource): WebResource;
}
/**
 * A factory function that creates a new CredentialPolicy that uses the provided nextPolicy.
 */
export declare type CredentialPolicyCreator = (nextPolicy: RequestPolicy, options: RequestPolicyOptions) => CredentialPolicy;
/**
 * Defines values for DeleteSnapshotsOptionType.
 * Possible values include: 'include'
 * @readonly
 * @enum {string}
 */
export declare type DeleteSnapshotsOptionType = 'include';
export { deserializationPolicy };
/**
 * Additional response header values for close handles request.
 */
export declare interface DirectoryCloseHandlesHeaders {
    /**
     * This header uniquely identifies the request that was made and can be used for troubleshooting
     * the request.
     */
    requestId?: string;
    /**
     * Indicates the version of the File service used to execute the request.
     */
    version?: string;
    /**
     * A UTC date/time value generated by the service that indicates the time at which the response
     * was initiated.
     */
    date?: Date;
    /**
     * A string describing next handle to be closed. It is returned when more handles need to be
     * closed to complete the request.
     */
    marker?: string;
}
/**
 * Defines headers for Create operation.
 */
export declare interface DirectoryCreateHeaders {
    /**
     * The ETag contains a value which represents the version of the directory, in quotes.
     */
    etag?: string;
    /**
     * Returns the date and time the share was last modified. Any operation that modifies the
     * directory or its properties updates the last modified time. Operations on files do not affect
     * the last modified time of the directory.
     */
    lastModified?: Date;
    /**
     * This header uniquely identifies the request that was made and can be used for troubleshooting
     * the request.
     */
    requestId?: string;
    /**
     * Indicates the version of the File service used to execute the request.
     */
    version?: string;
    /**
     * A UTC date/time value generated by the service that indicates the time at which the response
     * was initiated.
     */
    date?: Date;
    /**
     * The value of this header is set to true if the contents of the request are successfully
     * encrypted using the specified algorithm, and false otherwise.
     */
    isServerEncrypted?: boolean;
    /**
     * Key of the permission set for the directory.
     */
    filePermissionKey?: string;
    /**
     * Attributes set for the directory.
     */
    fileAttributes?: string;
    /**
     * Creation time for the directory.
     */
    fileCreatedOn?: Date;
    /**
     * Last write time for the directory.
     */
    fileLastWriteOn?: Date;
    /**
     * Change time for the directory.
     */
    fileChangeOn?: Date;
    /**
     * The fileId of the directory.
     */
    fileId?: string;
    /**
     * The parent fileId of the directory.
     */
    fileParentId?: string;
    errorCode?: string;
}
/**
 * Contains response data for the {@link DirectoryClient.createIfNotExists} operation.
 *
 * @export
 * @interface DirectoryCreateIfNotExistsResponse
 */
export declare interface DirectoryCreateIfNotExistsResponse extends DirectoryCreateResponse {
    /**
     * Indicate whether the directory is successfully created. Is false when the directory is not changed as it already exists.
     *
     * @type {boolean}
     * @memberof DirectoryCreateIfNotExistsResponse
     */
    succeeded: boolean;
}
/**
 * Options to configure {@link ShareDirectoryClient.create} operation.
 *
 * @export
 * @interface DirectoryCreateOptions
 */
export declare interface DirectoryCreateOptions extends FileAndDirectoryCreateCommonOptions, CommonOptions {
    /**
     * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.
     * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.
     *
     * @type {AbortSignalLike}
     * @memberof DirectoryCreateOptions
     */
    abortSignal?: AbortSignalLike;
    /**
     * A collection of key-value string pair to associate with the file storage object.
     *
     * @type {Metadata}
     * @memberof DirectoryCreateOptions
     */
    metadata?: Metadata;
}
/**
 * Contains response data for the create operation.
 */
export declare type DirectoryCreateResponse = DirectoryCreateHeaders & {
    /**
     * The underlying HTTP response.
     */
    _response: coreHttp.HttpResponse & {
        /**
         * The parsed HTTP response headers.
         */
        parsedHeaders: DirectoryCreateHeaders;
    };
};
/**
 * Defines headers for Delete operation.
 */
export declare interface DirectoryDeleteHeaders {
    /**
     * This header uniquely identifies the request that was made and can be used for troubleshooting
     * the request.
     */
    requestId?: string;
    /**
     * Indicates the version of the File service used to execute the request.
     */
    version?: string;
    /**
     * A UTC date/time value generated by the service that indicates the time at which the response
     * was initiated.
     */
    date?: Date;
    errorCode?: string;
}
/**
 * Contains response data for the {@link DirectoryClient.deleteIfExists} operation.
 *
 * @export
 * @interface DirectoryDeleteIfExistsResponse
 */
export declare interface DirectoryDeleteIfExistsResponse extends DirectoryDeleteResponse {
    /**
     * Indicate whether the directory is successfully deleted. Is false if the directory does not exist in the first place.
     *
     * @type {boolean}
     * @memberof DirectoryDeleteIfExistsResponse
     */
    succeeded: boolean;
}
/**
 * Options to configure the {@link ShareDirectoryClient.delete} operation.
 *
 * @export
 * @interface DirectoryDeleteOptions
 */
export declare interface DirectoryDeleteOptions extends CommonOptions {
    /**
     * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.
     * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.
     *
     * @type {AbortSignalLike}
     * @memberof DirectoryDeleteOptions
     */
    abortSignal?: AbortSignalLike;
}
/**
 * Contains response data for the deleteMethod operation.
 */
export declare type DirectoryDeleteResponse = DirectoryDeleteHeaders & {
    /**
     * The underlying HTTP response.
     */
    _response: coreHttp.HttpResponse & {
        /**
         * The parsed HTTP response headers.
         */
        parsedHeaders: DirectoryDeleteHeaders;
    };
};
/**
 * Options to configure the {@link ShareDirectoryClient.exists} operation.
 *
 * @export
 * @interface DirectoryExistsOptions
 */
export declare interface DirectoryExistsOptions extends CommonOptions {
    /**
     * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.
     * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.
     *
     * @type {AbortSignalLike}
     * @memberof DirectoryExistsOptions
     */
    abortSignal?: AbortSignalLike;
}
/**
 * Defines headers for ForceCloseHandles operation.
 */
export declare interface DirectoryForceCloseHandlesHeaders {
    /**
     * This header uniquely identifies the request that was made and can be used for troubleshooting
     * the request.
     */
    requestId?: string;
    /**
     * Indicates the version of the File service used to execute the request.
     */
    version?: string;
    /**
     * A UTC date/time value generated by the service that indicates the time at which the response
     * was initiated.
     */
    date?: Date;
    /**
     * A string describing next handle to be closed. It is returned when more handles need to be
     * closed to complete the request.
     */
    marker?: string;
    /**
     * Contains count of number of handles closed.
     */
    numberOfHandlesClosed?: number;
    /**
     * Contains count of number of handles that failed to close.
     */
    numberOfHandlesFailedToClose?: number;
    errorCode?: string;
}
/**
 * Options to configure {@link ShareDirectoryClient.forceCloseHandle}.
 *
 * @export
 * @interface DirectoryForceCloseHandlesOptions
 */
export declare interface DirectoryForceCloseHandlesOptions extends CommonOptions {
    /**
     * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.
     * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.
     *
     * @type {AbortSignalLike}
     * @memberof DirectoryForceCloseHandlesOptions
     */
    abortSignal?: AbortSignalLike;
}
/**
 * Response type for {@link ShareDirectoryClient.forceCloseHandle}.
 */
export declare type DirectoryForceCloseHandlesResponse = CloseHandlesInfo & DirectoryCloseHandlesHeaders & {
    /**
     * The underlying HTTP response.
     */
    _response: HttpResponse & {
        /**
         * The parsed HTTP response headers.
         */
        parsedHeaders: DirectoryForceCloseHandlesHeaders;
    };
};
/**
 * Options to configure Directory - Force Close Handles Segment operations.
 *
 * See:
 * - {@link ShareDirectoryClient.forceCloseHandlesSegment}
 * - {@link ShareDirectoryClient.forceCloseAllHandles}
 *
 * @export
 * @interface DirectoryForceCloseHandlesSegmentOptions
 */
export declare interface DirectoryForceCloseHandlesSegmentOptions extends CommonOptions {
    /**
     * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.
     * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.
     *
     * @type {AbortSignalLike}
     * @memberof DirectoryForceCloseHandlesSegmentOptions
     */
    abortSignal?: AbortSignalLike;
    /**
     * Specifies operation should apply to the directory specified in the URI, its files, its
     * subdirectories and their files.
     *
     * @type {boolean}
     * @memberof DirectoryForceCloseHandlesSegmentOptions
     */
    recursive?: boolean;
}
/**
 * Defines headers for GetProperties operation.
 */
export declare interface DirectoryGetPropertiesHeaders {
    metadata?: {
        [propertyName: string]: string;
    };
    /**
     * The ETag contains a value that you can use to perform operations conditionally, in quotes.
     */
    etag?: string;
    /**
     * Returns the date and time the Directory was last modified. Operations on files within the
     * directory do not affect the last modified time of the directory.
     */
    lastModified?: Date;
    /**
     * This header uniquely identifies the request that was made and can be used for troubleshooting
     * the request.
     */
    requestId?: string;
    /**
     * Indicates the version of the File service used to execute the request.
     */
    version?: string;
    /**
     * A UTC date/time value generated by the service that indicates the time at which the response
     * was initiated.
     */
    date?: Date;
    /**
     * The value of this header is set to true if the directory metadata is completely encrypted
     * using the specified algorithm. Otherwise, the value is set to false.
     */
    isServerEncrypted?: boolean;
    /**
     * Attributes set for the directory.
     */
    fileAttributes?: string;
    /**
     * Creation time for the directory.
     */
    fileCreatedOn?: Date;
    /**
     * Last write time for the directory.
     */
    fileLastWriteOn?: Date;
    /**
     * Change time for the directory.
     */
    fileChangeOn?: Date;
    /**
     * Key of the permission set for the directory.
     */
    filePermissionKey?: string;
    /**
     * The fileId of the directory.
     */
    fileId?: string;
    /**
     * The parent fileId of the directory.
     */
    fileParentId?: string;
    errorCode?: string;
}
/**
 * Options to configure the {@link ShareDirectoryClient.getProperties} operation.
 *
 * @export
 * @interface DirectoryGetPropertiesOptions
 */
export declare interface DirectoryGetPropertiesOptions extends CommonOptions {
    /**
     * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.
     * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.
     *
     * @type {AbortSignalLike}
     * @memberof DirectoryGetPropertiesOptions
     */
    abortSignal?: AbortSignalLike;
}
/**
 * Contains response data for the getProperties operation.
 */
export declare type DirectoryGetPropertiesResponse = DirectoryGetPropertiesHeaders & {
    /**
     * The underlying HTTP response.
     */
    _response: coreHttp.HttpResponse & {
        /**
         * The parsed HTTP response headers.
         */
        parsedHeaders: DirectoryGetPropertiesHeaders;
    };
};
/**
 * A listed directory item.
 */
export declare interface DirectoryItem {
    name: string;
}
/**
 * Options to configure {@link ShareDirectoryClient.listFilesAndDirectories} operation.
 *
 * @export
 * @interface DirectoryListFilesAndDirectoriesOptions
 */
export declare interface DirectoryListFilesAndDirectoriesOptions extends CommonOptions {
    /**
     * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.
     * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.
     *
     * @type {AbortSignalLike}
     * @memberof DirectoryListFilesAndDirectoriesOptions
     */
    abortSignal?: AbortSignalLike;
    /**
     * Filters the results to return only entries whose
     * name begins with the specified prefix.
     *
     * @type {string}
     * @memberof DirectoryListFilesAndDirectoriesOptions
     */
    prefix?: string;
}
/**
 * Defines headers for ListFilesAndDirectoriesSegment operation.
 */
export declare interface DirectoryListFilesAndDirectoriesSegmentHeaders {
    /**
     * Specifies the format in which the results are returned. Currently this value is
     * 'application/xml'.
     */
    contentType?: string;
    /**
     * This header uniquely identifies the request that was made and can be used for troubleshooting
     * the request.
     */
    requestId?: string;
    /**
     * Indicates the version of the File service used to execute the request.
     */
    version?: string;
    /**
     * A UTC date/time value generated by the service that indicates the time at which the response
     * was initiated.
     */
    date?: Date;
    errorCode?: string;
}
/**
 * Contains response data for the listFilesAndDirectoriesSegment operation.
 */
export declare type DirectoryListFilesAndDirectoriesSegmentResponse = ListFilesAndDirectoriesSegmentResponse & DirectoryListFilesAndDirectoriesSegmentHeaders & {
    /**
     * The underlying HTTP response.
     */
    _response: coreHttp.HttpResponse & {
        /**
         * The parsed HTTP response headers.
         */
        parsedHeaders: DirectoryListFilesAndDirectoriesSegmentHeaders;
        /**
         * The response body as text (string format)
         */
        bodyAsText: string;
        /**
         * The response body as parsed JSON or XML
         */
        parsedBody: ListFilesAndDirectoriesSegmentResponse;
    };
};
/**
 * Defines headers for ListHandles operation.
 */
export declare interface DirectoryListHandlesHeaders {
    /**
     * Specifies the format in which the results are returned. Currently this value is
     * 'application/xml'.
     */
    contentType?: string;
    /**
     * This header uniquely identifies the request that was made and can be used for troubleshooting
     * the request.
     */
    requestId?: string;
    /**
     * Indicates the version of the File service used to execute the request.
     */
    version?: string;
    /**
     * A UTC date/time value generated by the service that indicates the time at which the response
     * was initiated.
     */
    date?: Date;
    errorCode?: string;
}
/**
 * Options to configure the {@link ShareDirectoryClient.listHandles} operation.
 *
 * @export
 * @interface DirectoryListHandlesOptions
 */
export declare interface DirectoryListHandlesOptions extends CommonOptions {
    /**
     * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.
     * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.
     *
     * @type {AbortSignalLike}
     * @memberof DirectoryListHandlesOptions
     */
    abortSignal?: AbortSignalLike;
    /**
     * Specifies whether operation should apply to the directory specified in the URI, its files, its
     * subdirectories and their files.
     *
     * @type {boolean}
     * @memberof DirectoryListHandlesOptions
     */
    recursive?: boolean;
}
/**
 * Contains response data for the listHandles operation.
 */
export declare type DirectoryListHandlesResponse = ListHandlesResponse & DirectoryListHandlesHeaders & {
    /**
     * The underlying HTTP response.
     */
    _response: coreHttp.HttpResponse & {
        /**
         * The parsed HTTP response headers.
         */
        parsedHeaders: DirectoryListHandlesHeaders;
        /**
         * The response body as text (string format)
         */
        bodyAsText: string;
        /**
         * The response body as parsed JSON or XML
         */
        parsedBody: ListHandlesResponse;
    };
};
/**
 * Options to configure Directory - List Handles Segment operations.
 *
 * See:
 * - {@link ShareDirectoryClient.listHandlesSegment}
 * - {@link ShareDirectoryClient.iterateHandleSegments}
 * - {@link ShareDirectoryClient.listHandleItems}
 *
 *
 * @export
 * @interface DirectoryListHandlesSegmentOptions
 */
export declare interface DirectoryListHandlesSegmentOptions extends CommonOptions {
    /**
     * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.
     * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.
     *
     * @type {AbortSignalLike}
     * @memberof DirectoryListHandlesSegmentOptions
     */
    abortSignal?: AbortSignalLike;
    /**
     * Specifies the maximum number of entries to return. If the request does not specify maxResults,
     * or specifies a value greater than 5,000, the server will return up to 5,000 items.
     *
     * @type {number}
     * @memberof DirectoryListHandlesSegmentOptions
     */
    maxResults?: number;
    /**
     * Specifies operation should apply to the directory specified in the URI, its files, its
     * subdirectories and their files.
     *
     * @type {boolean}
     * @memberof DirectoryListHandlesSegmentOptions
     */
    recursive?: boolean;
}
export declare interface DirectoryProperties extends FileAndDirectorySetPropertiesCommonOptions, CommonOptions {
    /**
     * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.
     * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.
     *
     * @type {AbortSignalLike}
     * @memberof DirectoryProperties
     */
    abortSignal?: AbortSignalLike;
}
/**
 * Defines headers for SetMetadata operation.
 */
export declare interface DirectorySetMetadataHeaders {
    /**
     * The ETag contains a value which represents the version of the directory, in quotes.
     */
    etag?: string;
    /**
     * This header uniquely identifies the request that was made and can be used for troubleshooting
     * the request.
     */
    requestId?: string;
    /**
     * Indicates the version of the File service used to execute the request.
     */
    version?: string;
    /**
     * A UTC date/time value generated by the service that indicates the time at which the response
     * was initiated.
     */
    date?: Date;
    /**
     * The value of this header is set to true if the contents of the request are successfully
     * encrypted using the specified algorithm, and false otherwise.
     */
    isServerEncrypted?: boolean;
    errorCode?: string;
}
/**
 * Options to configure the {@link ShareDirectoryClient.setMetadata} operation.
 *
 * @export
 * @interface DirectorySetMetadataOptions
 */
export declare interface DirectorySetMetadataOptions extends CommonOptions {
    /**
     * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.
     * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.
     *
     * @type {AbortSignalLike}
     * @memberof DirectorySetMetadataOptions
     */
    abortSignal?: AbortSignalLike;
}
/**
 * Contains response data for the setMetadata operation.
 */
export declare type DirectorySetMetadataResponse = DirectorySetMetadataHeaders & {
    /**
     * The underlying HTTP response.
     */
    _response: coreHttp.HttpResponse & {
        /**
         * The parsed HTTP response headers.
         */
        parsedHeaders: DirectorySetMetadataHeaders;
    };
};
/**
 * Defines headers for SetProperties operation.
 */
export declare interface DirectorySetPropertiesHeaders {
    /**
     * The ETag contains a value which represents the version of the file, in quotes.
     */
    etag?: string;
    /**
     * This header uniquely identifies the request that was made and can be used for troubleshooting
     * the request.
     */
    requestId?: string;
    /**
     * Returns the date and time the directory was last modified. Any operation that modifies the
     * directory or its properties updates the last modified time. Operations on files do not affect
     * the last modified time of the directory.
     */
    lastModified?: Date;
    /**
     * Indicates the version of the File service used to execute the request.
     */
    version?: string;
    /**
     * A UTC date/time value generated by the service that indicates the time at which the response
     * was initiated.
     */
    date?: Date;
    /**
     * The value of this header is set to true if the contents of the request are successfully
     * encrypted using the specified algorithm, and false otherwise.
     */
    isServerEncrypted?: boolean;
    /**
     * Key of the permission set for the directory.
     */
    filePermissionKey?: string;
    /**
     * Attributes set for the directory.
     */
    fileAttributes?: string;
    /**
     * Creation time for the directory.
     */
    fileCreatedOn?: Date;
    /**
     * Last write time for the directory.
     */
    fileLastWriteOn?: Date;
    /**
     * Change time for the directory.
     */
    fileChangeOn?: Date;
    /**
     * The fileId of the directory.
     */
    fileId?: string;
    /**
     * The parent fileId of the directory.
     */
    fileParentId?: string;
    errorCode?: string;
}
/**
 * Contains response data for the setProperties operation.
 */
export declare type DirectorySetPropertiesResponse = DirectorySetPropertiesHeaders & {
    /**
     * The underlying HTTP response.
     */
    _response: coreHttp.HttpResponse & {
        /**
         * The parsed HTTP response headers.
         */
        parsedHeaders: DirectorySetPropertiesHeaders;
    };
};
/**
 * Options to configure the {@link ShareFileClient.abortCopyFromURL} operation.
 *
 * @export
 * @interface FileAbortCopyFromURLOptions
 */
export declare interface FileAbortCopyFromURLOptions extends CommonOptions {
    /**
     * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.
     * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.
     *
     * @type {AbortSignalLike}
     * @memberof FileAbortCopyFromURLOptions
     */
    abortSignal?: AbortSignalLike;
    /**
     * Lease access conditions.
     *
     * @type {LeaseAccessConditions}
     * @memberof FileAbortCopyFromURLOptions
     */
    leaseAccessConditions?: LeaseAccessConditions;
}
/**
 * Defines headers for AbortCopy operation.
 */
export declare interface FileAbortCopyHeaders {
    /**
     * This header uniquely identifies the request that was made and can be used for troubleshooting
     * the request.
     */
    requestId?: string;
    /**
     * Indicates the version of the File service used to execute the request.
     */
    version?: string;
    /**
     * A UTC date/time value generated by the service that indicates the time at which the response
     * was initiated.
     */
    date?: Date;
    errorCode?: string;
}
/**
 * Contains response data for the abortCopy operation.
 */
export declare type FileAbortCopyResponse = FileAbortCopyHeaders & {
    /**
     * The underlying HTTP response.
     */
    _response: coreHttp.HttpResponse & {
        /**
         * The parsed HTTP response headers.
         */
        parsedHeaders: FileAbortCopyHeaders;
    };
};
export declare interface FileAndDirectoryCreateCommonOptions {
    /**
     * The permission(security descriptor) to be set for the file or directory in the
     * Security Descriptor Definition Language (SDDL). If specified, it must have an owner, group, and discretionary access control list (DACL).
     * A value of inherit may be passed to inherit from the parent directory.
     *
     * Note that only one of filePermission or filePermissionKey can be specified.
     * And if both are not specified, inherit will be set to filePermission as default value by client library.
     */
    filePermission?: string | FilePermissionInheritType;
    /**
     * The key of the permission to be set for the file or directory. This can be created using the Create-Permission API.
     *
     * Note that only one of filePermission or filePermissionKey can be specified.
     */
    filePermissionKey?: string;
    /**
     * The file system attributes to be set on the file or directory.
     */
    fileAttributes?: FileSystemAttributes;
    /**
     * The Coordinated Universal Time (UTC) creation time property for the directory.
     * A value of now may be used to indicate the time of the request.
     * By default, the value will be set as now.
     */
    creationTime?: Date | TimeNowType;
    /**
     * The Coordinated Universal Time (UTC) last write property for the directory.
     * A value of now may be used to indicate the time of the request.
     * By default, the value will be set as now.
     */
    lastWriteTime?: Date | TimeNowType;
}
export declare interface FileAndDirectorySetPropertiesCommonOptions {
    /**
     * The permission(security descriptor) to be set for the file or directory in the
     * Security Descriptor Definition Language (SDDL). If specified, it must have an owner, group, and discretionary access control list (DACL).
     * A value of inherit may be passed to inherit from the parent directory.
     * A value of preserve may be passed to keep the value unchanged.
     *
     * Note that only one of filePermission or filePermissionKey can be specified.
     * And if both are not specified, preserve will be set to filePermission as default value by client library.
     */
    filePermission?: string | FilePermissionInheritType | FilePermissionPreserveType;
    /**
     * The key of the permission to be set for the file or directory. This can be created using the Create-Permission API.
     *
     * Note that only one of filePermission or filePermissionKey can be specified.
     */
    filePermissionKey?: string;
    /**
     * The file system attributes to be set on the file or directory.
     */
    fileAttributes?: FileSystemAttributes | FileAttributesPreserveType;
    /**
     * The Coordinated Universal Time (UTC) creation time property for the directory.
     * A value of now may be used to indicate the time of the request.
     * A value of preserve may be passed to keep an existing value unchanged.
     * By default, the value will be set as preserve.
     */
    creationTime?: Date | TimeNowType | TimePreserveType;
    /**
     * The Coordinated Universal Time (UTC) last write property for the directory.
     * A value of now may be used to indicate the time of the request.
     * A value of preserve may be passed to keep an existing value unchanged.
     * By default, the value will be set as preserve.
     */
    lastWriteTime?: Date | TimeNowType | TimePreserveType;
}
/**
 * Indicates keep existing file attributes unchanged.
 */
export declare type FileAttributesPreserveType = "preserve";
/**
 * Options to configure the {@link ShareFileClient.clearRange} operation.
 *
 * @export
 * @interface FileClearRangeOptions
 */
export declare interface FileClearRangeOptions extends CommonOptions {
    /**
     * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.
     * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.
     *
     * @type {AbortSignalLike}
     * @memberof FileClearRangeOptions
     */
    abortSignal?: AbortSignalLike;
    /**
     * Lease access conditions.
     *
     * @type {LeaseAccessConditions}
     * @memberof FileClearRangeOptions
     */
    leaseAccessConditions?: LeaseAccessConditions;
}
/**
 * Additional response header values for close handles request.
 */
export declare interface FileCloseHandlesHeaders {
    /**
     * This header uniquely identifies the request that was made and can be used for troubleshooting
     * the request.
     */
    requestId?: string;
    /**
     * Indicates the version of the File service used to execute the request.
     */
    version?: string;
    /**
     * A UTC date/time value generated by the service that indicates the time at which the response
     * was initiated.
     */
    date?: Date;
    /**
     * A string describing next handle to be closed. It is returned when more handles need to be
     * closed to complete the request.
     */
    marker?: string;
}
/**
 * Defines headers for Create operation.
 */
export declare interface FileCreateHeaders {
    /**
     * The ETag contains a value which represents the version of the file, in quotes.
     */
    etag?: string;
    /**
     * Returns the date and time the share was last modified. Any operation that modifies the
     * directory or its properties updates the last modified time. Operations on files do not affect
     * the last modified time of the directory.
     */
    lastModified?: Date;
    /**
     * This header uniquely identifies the request that was made and can be used for troubleshooting
     * the request.
     */
    requestId?: string;
    /**
     * Indicates the version of the File service used to execute the request.
     */
    version?: string;
    /**
     * A UTC date/time value generated by the service that indicates the time at which the response
     * was initiated.
     */
    date?: Date;
    /**
     * The value of this header is set to true if the contents of the request are successfully
     * encrypted using the specified algorithm, and false otherwise.
     */
    isServerEncrypted?: boolean;
    /**
     * Key of the permission set for the file.
     */
    filePermissionKey?: string;
    /**
     * Attributes set for the file.
     */
    fileAttributes?: string;
    /**
     * Creation time for the file.
     */
    fileCreatedOn?: Date;
    /**
     * Last write time for the file.
     */
    fileLastWriteOn?: Date;
    /**
     * Change time for the file.
     */
    fileChangeOn?: Date;
    /**
     * The fileId of the file.
     */
    fileId?: string;
    /**
     * The parent fileId of the file.
     */
    fileParentId?: string;
    errorCode?: string;
}
/**
 * Options to configure the {@link ShareFileClient.create} operation.
 *
 * @export
 * @interface FileCreateOptions
 */
export declare interface FileCreateOptions extends FileAndDirectoryCreateCommonOptions, CommonOptions {
    /**
     * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.
     * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.
     *
     * @type {AbortSignalLike}
     * @memberof FileCreateOptions
     */
    abortSignal?: AbortSignalLike;
    /**
     * File HTTP headers like Content-Type.
     *
     * @type {FileHttpHeaders}
     * @memberof FileCreateOptions
     */
    fileHttpHeaders?: FileHttpHeaders;
    /**
     * A collection of key-value string pair to associate with the file storage object.
     *
     * @type {Metadata}
     * @memberof FileCreateOptions
     */
    metadata?: Metadata;
    /**
     * Lease access conditions.
     *
     * @type {LeaseAccessConditions}
     * @memberof FileCreateOptions
     */
    leaseAccessConditions?: LeaseAccessConditions;
}
/**
 * Contains response data for the create operation.
 */
export declare type FileCreateResponse = FileCreateHeaders & {
    /**
     * The underlying HTTP response.
     */
    _response: coreHttp.HttpResponse & {
        /**
         * The parsed HTTP response headers.
         */
        parsedHeaders: FileCreateHeaders;
    };
};
/**
 * Defines headers for Delete operation.
 */
export declare interface FileDeleteHeaders {
    /**
     * This header uniquely identifies the request that was made and can be used for troubleshooting
     * the request.
     */
    requestId?: string;
    /**
     * Indicates the version of the File service used to execute the request.
     */
    version?: string;
    /**
     * A UTC date/time value generated by the service that indicates the time at which the response
     * was initiated.
     */
    date?: Date;
    errorCode?: string;
}
/**
 * Contains response data for the {@link ShareFileClient.deleteIfExists} operation.
 *
 * @export
 * @interface FileDeleteIfExistsResponse
 */
export declare interface FileDeleteIfExistsResponse extends FileDeleteResponse {
    /**
     * Indicate whether the file is successfully deleted. Is false if the file does not exist in the first place.
     *
     * @type {boolean}
     * @memberof FileDeleteIfExistsResponse
     */
    succeeded: boolean;
}
/**
 * Options to configure the {@link ShareFileClient.delete} operation.
 *
 * @export
 * @interface FileDeleteOptions
 */
export declare interface FileDeleteOptions extends CommonOptions {
    /**
     * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.
     * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.
     *
     * @type {AbortSignalLike}
     * @memberof FileDeleteOptions
     */
    abortSignal?: AbortSignalLike;
    /**
     * Lease access conditions.
     *
     * @type {LeaseAccessConditions}
     * @memberof FileDeleteOptions
     */
    leaseAccessConditions?: LeaseAccessConditions;
}
/**
 * Contains response data for the deleteMethod operation.
 */
export declare type FileDeleteResponse = FileDeleteHeaders & {
    /**
     * The underlying HTTP response.
     */
    _response: coreHttp.HttpResponse & {
        /**
         * The parsed HTTP response headers.
         */
        parsedHeaders: FileDeleteHeaders;
    };
};
/**
 * Defines headers for Download operation.
 */
export declare interface FileDownloadHeaders {
    /**
     * Returns the date and time the file was last modified. Any operation that modifies the file or
     * its properties updates the last modified time.
     */
    lastModified?: Date;
    metadata?: {
        [propertyName: string]: string;
    };
    /**
     * The number of bytes present in the response body.
     */
    contentLength?: number;
    /**
     * The content type specified for the file. The default content type is
     * 'application/octet-stream'
     */
    contentType?: string;
    /**
     * Indicates the range of bytes returned if the client requested a subset of the file by setting
     * the Range request header.
     */
    contentRange?: string;
    /**
     * The ETag contains a value that you can use to perform operations conditionally, in quotes.
     */
    etag?: string;
    /**
     * If the file has an MD5 hash and the request is to read the full file, this response header is
     * returned so that the client can check for message content integrity. If the request is to read
     * a specified range and the 'x-ms-range-get-content-md5' is set to true, then the request
     * returns an MD5 hash for the range, as long as the range size is less than or equal to 4 MB. If
     * neither of these sets of conditions is true, then no value is returned for the 'Content-MD5'
     * header.
     */
    contentMD5?: Uint8Array;
    /**
     * Returns the value that was specified for the Content-Encoding request header.
     */
    contentEncoding?: string;
    /**
     * Returned if it was previously specified for the file.
     */
    cacheControl?: string;
    /**
     * Returns the value that was specified for the 'x-ms-content-disposition' header and specifies
     * how to process the response.
     */
    contentDisposition?: string;
    /**
     * Returns the value that was specified for the Content-Language request header.
     */
    contentLanguage?: string;
    /**
     * This header uniquely identifies the request that was made and can be used for troubleshooting
     * the request.
     */
    requestId?: string;
    /**
     * Indicates the version of the File service used to execute the request.
     */
    version?: string;
    /**
     * Indicates that the service supports requests for partial file content.
     */
    acceptRanges?: string;
    /**
     * A UTC date/time value generated by the service that indicates the time at which the response
     * was initiated.
     */
    date?: Date;
    /**
     * Conclusion time of the last attempted Copy File operation where this file was the destination
     * file. This value can specify the time of a completed, aborted, or failed copy attempt.
     */
    copyCompletedOn?: Date;
    /**
     * Only appears when x-ms-copy-status is failed or pending. Describes cause of fatal or non-fatal
     * copy operation failure.
     */
    copyStatusDescription?: string;
    /**
     * String identifier for the last attempted Copy File operation where this file was the
     * destination file.
     */
    copyId?: string;
    /**
     * Contains the number of bytes copied and the total bytes in the source in the last attempted
     * Copy File operation where this file was the destination file. Can show between 0 and
     * Content-Length bytes copied.
     */
    copyProgress?: string;
    /**
     * URL up to 2KB in length that specifies the source file used in the last attempted Copy File
     * operation where this file was the destination file.
     */
    copySource?: string;
    /**
     * State of the copy operation identified by 'x-ms-copy-id'. Possible values include: 'pending',
     * 'success', 'aborted', 'failed'
     */
    copyStatus?: CopyStatusType;
    /**
     * If the file has a MD5 hash, and if request contains range header (Range or x-ms-range), this
     * response header is returned with the value of the whole file's MD5 value. This value may or
     * may not be equal to the value returned in Content-MD5 header, with the latter calculated from
     * the requested range.
     */
    fileContentMD5?: Uint8Array;
    /**
     * The value of this header is set to true if the file data and application metadata are
     * completely encrypted using the specified algorithm. Otherwise, the value is set to false (when
     * the file is unencrypted, or if only parts of the file/application metadata are encrypted).
     */
    isServerEncrypted?: boolean;
    /**
     * Attributes set for the file.
     */
    fileAttributes?: string;
    /**
     * Creation time for the file.
     */
    fileCreatedOn?: Date;
    /**
     * Last write time for the file.
     */
    fileLastWriteOn?: Date;
    /**
     * Change time for the file.
     */
    fileChangeOn?: Date;
    /**
     * Key of the permission set for the file.
     */
    filePermissionKey?: string;
    /**
     * The fileId of the file.
     */
    fileId?: string;
    /**
     * The parent fileId of the file.
     */
    fileParentId?: string;
    /**
     * When a file is leased, specifies whether the lease is of infinite or fixed duration. Possible
     * values include: 'infinite', 'fixed'
     */
    leaseDuration?: LeaseDurationType;
    /**
     * Lease state of the file. Possible values include: 'available', 'leased', 'expired',
     * 'breaking', 'broken'
     */
    leaseState?: LeaseStateType;
    /**
     * The current lease status of the file. Possible values include: 'locked', 'unlocked'
     */
    leaseStatus?: LeaseStatusType;
    errorCode?: string;
}
/**
 * Optional Parameters.
 */
export declare interface FileDownloadOptionalParams extends coreHttp.RequestOptionsBase {
    /**
     * The timeout parameter is expressed in seconds. For more information, see <a
     * href="https://docs.microsoft.com/en-us/rest/api/storageservices/Setting-Timeouts-for-File-Service-Operations?redirectedfrom=MSDN">Setting
     * Timeouts for File Service Operations.</a>
     */
    timeoutInSeconds?: number;
    /**
     * Return file data only from the specified byte range.
     */
    range?: string;
    /**
     * When this header is set to true and specified together with the Range header, the service
     * returns the MD5 hash for the range, as long as the range is less than or equal to 4 MB in
     * size.
     */
    rangeGetContentMD5?: boolean;
    /**
     * Additional parameters for the operation
     */
    leaseAccessConditions?: LeaseAccessConditions;
}
/**
 * Options to configure File - Download operations.
 *
 * See:
 * - {@link ShareFileClient.download}
 * - {@link ShareFileClient.downloadToFile}
 *
 * @export
 * @interface FileDownloadOptions
 */
export declare interface FileDownloadOptions extends CommonOptions {
    /**
     * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.
     * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.
     *
     * @type {AbortSignalLike}
     * @memberof FileDownloadOptions
     */
    abortSignal?: AbortSignalLike;
    /**
     * Optional. ONLY AVAILABLE IN NODE.JS.
     *
     * How many retries will perform when original body download stream unexpected ends.
     * Above kind of ends will not trigger retry policy defined in a pipeline,
     * because they doesn't emit network errors.
     *
     * With this option, every additional retry means an additional ShareFileClient.download() request will be made
     * from the broken point, until the requested range has been successfully downloaded or maxRetryRequests is reached.
     *
     * Default value is 5, please set a larger value when loading large files in poor network.
     *
     * @type {number}
     * @memberof FileDownloadOptions
     */
    maxRetryRequests?: number;
    /**
     * When this header is set to true and
     * specified together with the Range header, the service returns the MD5 hash
     * for the range, as long as the range is less than or equal to 4 MB in size.
     *
     * @type {boolean}
     * @memberof FileDownloadOptions
     */
    rangeGetContentMD5?: boolean;
    /**
     * Download progress updating event handler.
     *
     * @memberof FileDownloadOptions
     */
    onProgress?: (progress: TransferProgressEvent) => void;
    /**
     * Lease access conditions.
     *
     * @type {LeaseAccessConditions}
     * @memberof FileDownloadOptions
     */
    leaseAccessConditions?: LeaseAccessConditions;
}
/**
 * Contains response data for the download operation.
 */
export declare type FileDownloadResponseModel = FileDownloadHeaders & {
    /**
     * BROWSER ONLY
     *
     * The response body as a browser Blob.
     * Always undefined in node.js.
     */
    blobBody?: Promise<Blob>;
    /**
     * NODEJS ONLY
     *
     * The response body as a node.js Readable stream.
     * Always undefined in the browser.
     */
    readableStreamBody?: NodeJS.ReadableStream;
    /**
     * The underlying HTTP response.
     */
    _response: coreHttp.HttpResponse & {
        /**
         * The parsed HTTP response headers.
         */
        parsedHeaders: FileDownloadHeaders;
    };
};
/**
 * Option interface for the {@link ShareFileClient.downloadToBuffer} operation.
 *
 * @export
 * @interface FileDownloadToBufferOptions
 */
export declare interface FileDownloadToBufferOptions extends CommonOptions {
    /**
     * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.
     * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.
     *
     * @type {AbortSignalLike}
     * @memberof FileDownloadToBufferOptions
     */
    abortSignal?: AbortSignalLike;
    /**
     * When downloading Azure files, download method will try to split large file into small ranges.
     * Every small range will be downloaded via a separate request.
     * This option defines size data every small request trying to download.
     * Must be > 0, will use the default value if undefined,
     *
     * @type {number}
     * @memberof FileDownloadToBufferOptions
     */
    rangeSize?: number;
    /**
     * Optional. ONLY AVAILABLE IN NODE.JS.
     *
     * How many retries will perform when original range download stream unexpected ends.
     * Above kind of ends will not trigger retry policy defined in a pipeline,
     * because they doesn't emit network errors.
     *
     * With this option, every additional retry means an additional ShareFileClient.download() request will be made
     * from the broken point, until the requested range has been successfully downloaded or
     * maxRetryRequestsPerRange is reached.
     *
     * Default value is 5, please set a larger value when in poor network.
     *
     * @type {number}
     * @memberof FileDownloadToBufferOptions
     */
    maxRetryRequestsPerRange?: number;
    /**
     * Progress updater.
     *
     * @memberof FileDownloadToBufferOptions
     */
    onProgress?: (progress: TransferProgressEvent) => void;
    /**
     * Concurrency indicates the maximum number of ranges to download in parallel.
     * If not provided, 5 concurrency will be used by default.
     *
     * @type {number}
     * @memberof FileDownloadToBufferOptions
     */
    concurrency?: number;
    /**
     * Lease access conditions.
     *
     * @type {LeaseAccessConditions}
     * @memberof FileDownloadToBufferOptions
     */
    leaseAccessConditions?: LeaseAccessConditions;
}
/**
 * Options to configure the {@link ShareFileClient.exists} operation.
 *
 * @export
 * @interface FileExistsOptions
 */
export declare interface FileExistsOptions extends CommonOptions {
    /**
     * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.
     * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.
     *
     * @type {AbortSignalLike}
     * @memberof FileExistsOptions
     */
    abortSignal?: AbortSignalLike;
}
/**
 * Defines headers for ForceCloseHandles operation.
 */
export declare interface FileForceCloseHandlesHeaders {
    /**
     * This header uniquely identifies the request that was made and can be used for troubleshooting
     * the request.
     */
    requestId?: string;
    /**
     * Indicates the version of the File service used to execute the request.
     */
    version?: string;
    /**
     * A UTC date/time value generated by the service that indicates the time at which the response
     * was initiated.
     */
    date?: Date;
    /**
     * A string describing next handle to be closed. It is returned when more handles need to be
     * closed to complete the request.
     */
    marker?: string;
    /**
     * Contains count of number of handles closed.
     */
    numberOfHandlesClosed?: number;
    /**
     * Contains count of number of handles that failed to close.
     */
    numberOfHandlesFailedToClose?: number;
    errorCode?: string;
}
/**
 * Options to configure File - Force Close Handles operations.
 *
 * See:
 * - {@link ShareFileClient.forceCloseHandlesSegment}
 * - {@link ShareFileClient.forceCloseAllHandles}
 * - {@link ShareFileClient.forceCloseHandle}
 *
 * @export
 * @interface FileForceCloseHandlesOptions
 */
export declare interface FileForceCloseHandlesOptions extends CommonOptions {
    /**
     * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.
     * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.
     *
     * @type {AbortSignalLike}
     * @memberof FileForceCloseHandlesOptions
     */
    abortSignal?: AbortSignalLike;
}
/**
 * Response type for {@link ShareFileClient.forceCloseHandle}.
 */
export declare type FileForceCloseHandlesResponse = CloseHandlesInfo & FileCloseHandlesHeaders & {
    /**
     * The underlying HTTP response.
     */
    _response: HttpResponse & {
        /**
         * The parsed HTTP response headers.
         */
        parsedHeaders: FileForceCloseHandlesHeaders;
    };
};
/**
 * Defines headers for GetProperties operation.
 */
export declare interface FileGetPropertiesHeaders {
    /**
     * Returns the date and time the file was last modified. The date format follows RFC 1123. Any
     * operation that modifies the file or its properties updates the last modified time.
     */
    lastModified?: Date;
    metadata?: {
        [propertyName: string]: string;
    };
    /**
     * Returns the type File. Reserved for future use. Possible values include: 'File'
     */
    fileType?: FileType;
    /**
     * The size of the file in bytes. This header returns the value of the 'x-ms-content-length'
     * header that is stored with the file.
     */
    contentLength?: number;
    /**
     * The content type specified for the file. The default content type is
     * 'application/octet-stream'
     */
    contentType?: string;
    /**
     * The ETag contains a value that you can use to perform operations conditionally, in quotes.
     */
    etag?: string;
    /**
     * If the Content-MD5 header has been set for the file, the Content-MD5 response header is
     * returned so that the client can check for message content integrity.
     */
    contentMD5?: Uint8Array;
    /**
     * If the Content-Encoding request header has previously been set for the file, the
     * Content-Encoding value is returned in this header.
     */
    contentEncoding?: string;
    /**
     * If the Cache-Control request header has previously been set for the file, the Cache-Control
     * value is returned in this header.
     */
    cacheControl?: string;
    /**
     * Returns the value that was specified for the 'x-ms-content-disposition' header and specifies
     * how to process the response.
     */
    contentDisposition?: string;
    /**
     * Returns the value that was specified for the Content-Language request header.
     */
    contentLanguage?: string;
    /**
     * This header uniquely identifies the request that was made and can be used for troubleshooting
     * the request.
     */
    requestId?: string;
    /**
     * Indicates the version of the File service used to execute the request.
     */
    version?: string;
    /**
     * A UTC date/time value generated by the service that indicates the time at which the response
     * was initiated.
     */
    date?: Date;
    /**
     * Conclusion time of the last attempted Copy File operation where this file was the destination
     * file. This value can specify the time of a completed, aborted, or failed copy attempt.
     */
    copyCompletedOn?: Date;
    /**
     * Only appears when x-ms-copy-status is failed or pending. Describes cause of fatal or non-fatal
     * copy operation failure.
     */
    copyStatusDescription?: string;
    /**
     * String identifier for the last attempted Copy File operation where this file was the
     * destination file.
     */
    copyId?: string;
    /**
     * Contains the number of bytes copied and the total bytes in the source in the last attempted
     * Copy File operation where this file was the destination file. Can show between 0 and
     * Content-Length bytes copied.
     */
    copyProgress?: string;
    /**
     * URL up to 2KB in length that specifies the source file used in the last attempted Copy File
     * operation where this file was the destination file.
     */
    copySource?: string;
    /**
     * State of the copy operation identified by 'x-ms-copy-id'. Possible values include: 'pending',
     * 'success', 'aborted', 'failed'
     */
    copyStatus?: CopyStatusType;
    /**
     * The value of this header is set to true if the file data and application metadata are
     * completely encrypted using the specified algorithm. Otherwise, the value is set to false (when
     * the file is unencrypted, or if only parts of the file/application metadata are encrypted).
     */
    isServerEncrypted?: boolean;
    /**
     * Attributes set for the file.
     */
    fileAttributes?: string;
    /**
     * Creation time for the file.
     */
    fileCreatedOn?: Date;
    /**
     * Last write time for the file.
     */
    fileLastWriteOn?: Date;
    /**
     * Change time for the file.
     */
    fileChangeOn?: Date;
    /**
     * Key of the permission set for the file.
     */
    filePermissionKey?: string;
    /**
     * The fileId of the file.
     */
    fileId?: string;
    /**
     * The parent fileId of the file.
     */
    fileParentId?: string;
    /**
     * When a file is leased, specifies whether the lease is of infinite or fixed duration. Possible
     * values include: 'infinite', 'fixed'
     */
    leaseDuration?: LeaseDurationType;
    /**
     * Lease state of the file. Possible values include: 'available', 'leased', 'expired',
     * 'breaking', 'broken'
     */
    leaseState?: LeaseStateType;
    /**
     * The current lease status of the file. Possible values include: 'locked', 'unlocked'
     */
    leaseStatus?: LeaseStatusType;
    errorCode?: string;
}
/**
 * Options to configure the {@link ShareFileClient.getProperties} operation.
 *
 * @export
 * @interface FileGetPropertiesOptions
 */
export declare interface FileGetPropertiesOptions extends CommonOptions {
    /**
     * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.
     * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.
     *
     * @type {AbortSignalLike}
     * @memberof FileGetPropertiesOptions
     */
    abortSignal?: AbortSignalLike;
    /**
     * Lease access conditions.
     *
     * @type {LeaseAccessConditions}
     * @memberof FileGetPropertiesOptions
     */
    leaseAccessConditions?: LeaseAccessConditions;
}
/**
 * Contains response data for the getProperties operation.
 */
export declare type FileGetPropertiesResponse = FileGetPropertiesHeaders & {
    /**
     * The underlying HTTP response.
     */
    _response: coreHttp.HttpResponse & {
        /**
         * The parsed HTTP response headers.
         */
        parsedHeaders: FileGetPropertiesHeaders;
    };
};
/**
 * Defines headers for GetRangeList operation.
 */
export declare interface FileGetRangeListHeaders {
    /**
     * The date/time that the file was last modified. Any operation that modifies the file, including
     * an update of the file's metadata or properties, changes the file's last modified time.
     */
    lastModified?: Date;
    /**
     * The ETag contains a value which represents the version of the file, in quotes.
     */
    etag?: string;
    /**
     * The size of the file in bytes.
     */
    fileContentLength?: number;
    /**
     * This header uniquely identifies the request that was made and can be used for troubleshooting
     * the request.
     */
    requestId?: string;
    /**
     * Indicates the version of the File service used to execute the request.
     */
    version?: string;
    /**
     * A UTC date/time value generated by the service that indicates the time at which the response
     * was initiated.
     */
    date?: Date;
    errorCode?: string;
}
/**
 * The option is defined as parity to REST definition.
 * While it's not ready to be used now, considering Crc64 of source content is
 * not accessible.
 */
/**
 * Options to configure the {@link ShareFileClient.getRangeList} operation.
 *
 * @export
 * @interface FileGetRangeListOptions
 */
export declare interface FileGetRangeListOptions extends CommonOptions {
    /**
     * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.
     * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.
     *
     * @type {AbortSignalLike}
     * @memberof FileGetRangeListOptions
     */
    abortSignal?: AbortSignalLike;
    /**
     * Optional. Specifies the range of bytes over which to list ranges, inclusively.
     *
     * @type {Range}
     * @memberof FileGetRangeListOptions
     */
    range?: Range;
    /**
     * Lease access conditions.
     *
     * @type {LeaseAccessConditions}
     * @memberof FileGetRangeListOptions
     */
    leaseAccessConditions?: LeaseAccessConditions;
}
/**
 * Contains response data for the {@link ShareFileClient.getRangeList} operation.
 */
export declare type FileGetRangeListResponse = FileGetRangeListHeaders & {
    /**
     * Range list for an Azure file.
     *
     * @type {RangeModel[]}
     */
    rangeList: RangeModel[];
    /**
     * The underlying HTTP response.
     */
    _response: HttpResponse & {
        /**
         * The parsed HTTP response headers.
         */
        parsedHeaders: FileGetRangeListHeaders;
        /**
         * The response body as text (string format)
         */
        bodyAsText: string;
        /**
         * The response body as parsed JSON or XML
         */
        parsedBody: RangeModel[];
    };
};
export declare interface FileHttpHeaders {
    /**
     * @member {string} [fileCacheControl] Optional. Sets the file's cache
     * control. If specified, this property is stored with the file and returned
     * with a read request.
     */
    fileCacheControl?: string;
    /**
     * @member {string} [fileContentType] Optional. Sets the file's content type.
     * If specified, this property is stored with the file and returned with a
     * read request.
     */
    fileContentType?: string;
    /**
     * @member {Uint8Array} [fileContentMD5] Optional. An MD5 hash of the file
     * content. Note that this hash is not validated, as the hashes for the
     * individual blocks were validated when each was uploaded.
     */
    fileContentMD5?: Uint8Array;
    /**
     * @member {string} [fileContentEncoding] Optional. Sets the file's content
     * encoding. If specified, this property is stored with the file and returned
     * with a read request.
     */
    fileContentEncoding?: string;
    /**
     * @member {string} [fileContentLanguage] Optional. Set the file's content
     * language. If specified, this property is stored with the file and returned
     * with a read request.
     */
    fileContentLanguage?: string;
    /**
     * @member {string} [fileContentDisposition] Optional. Sets the file's
     * Content-Disposition header.
     */
    fileContentDisposition?: string;
}
/**
 * A listed file item.
 */
export declare interface FileItem {
    name: string;
    properties: FileProperty;
}
/**
 * Defines headers for ListHandles operation.
 */
export declare interface FileListHandlesHeaders {
    /**
     * Specifies the format in which the results are returned. Currently this value is
     * 'application/xml'.
     */
    contentType?: string;
    /**
     * This header uniquely identifies the request that was made and can be used for troubleshooting
     * the request.
     */
    requestId?: string;
    /**
     * Indicates the version of the File service used to execute the request.
     */
    version?: string;
    /**
     * A UTC date/time value generated by the service that indicates the time at which the response
     * was initiated.
     */
    date?: Date;
    errorCode?: string;
}
export declare interface FileListHandlesOptions extends CommonOptions {
    /**
     * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.
     * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.
     *
     * @type {AbortSignalLike}
     * @memberof FileClearRangeOptions
     */
    abortSignal?: AbortSignalLike;
}
/**
 * Contains response data for the listHandles operation.
 */
export declare type FileListHandlesResponse = ListHandlesResponse & FileListHandlesHeaders & {
    /**
     * The underlying HTTP response.
     */
    _response: coreHttp.HttpResponse & {
        /**
         * The parsed HTTP response headers.
         */
        parsedHeaders: FileListHandlesHeaders;
        /**
         * The response body as text (string format)
         */
        bodyAsText: string;
        /**
         * The response body as parsed JSON or XML
         */
        parsedBody: ListHandlesResponse;
    };
};
/**
 * Options to configure File - List Handles Segment operations.
 *
 * See:
 * - {@link ShareFileClient.listHandlesSegment}
 * - {@link ShareFileClient.iterateHandleSegments}
 * - {@link ShareFileClient.listHandleItems}
 *
 * @export
 * @interface FileListHandlesSegmentOptions
 */
export declare interface FileListHandlesSegmentOptions extends CommonOptions {
    /**
     * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.
     * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.
     *
     * @type {AbortSignalLike}
     * @memberof FileClearRangeOptions
     */
    abortSignal?: AbortSignalLike;
    /**
     * Specifies the maximum number of entries to return. If the request does not specify maxResults,
     * or specifies a value greater than 5,000, the server will return up to 5,000 items.
     *
     * @type {number}
     * @memberof FileListHandlesSegmentOptions
     */
    maxPageSize?: number;
}
/**
 * Option interface for File - Upload operations
 *
 * See:
 * - {@link ShareFileClient.uploadFile}
 * - {@link ShareFileClient.uploadSeekableStream}
 *
 * @export
 * @interface FileParallelUploadOptions
 */
export declare interface FileParallelUploadOptions extends CommonOptions {
    /**
     * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.
     * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.
     *
     * @type {AbortSignalLike}
     * @memberof FileParallelUploadOptions
     */
    abortSignal?: AbortSignalLike;
    /**
     * RangeSize specifies the range size to use in each parallel upload,
     * the default (and maximum size) is FILE_RANGE_MAX_SIZE_BYTES.
     *
     * @type {number}
     * @memberof FileParallelUploadOptions
     */
    rangeSize?: number;
    /**
     * Progress updater.
     *
     * @memberof FileParallelUploadOptions
     */
    onProgress?: (progress: TransferProgressEvent) => void;
    /**
     * File HTTP Headers.
     *
     * @type {FileHttpHeaders}
     * @memberof FileParallelUploadOptions
     */
    fileHttpHeaders?: FileHttpHeaders;
    /**
     * Metadata of an Azure file.
     *
     * @type {Metadata}
     * @memberof FileParallelUploadOptions
     */
    metadata?: Metadata;
    /**
     * Concurrency indicates the maximum number of ranges to upload in parallel.
     * If not provided, 5 concurrency will be used by default.
     *
     * @type {number}
     * @memberof FileParallelUploadOptions
     */
    concurrency?: number;
    /**
     * Lease access conditions.
     *
     * @type {LeaseAccessConditions}
     * @memberof FileParallelUploadOptions
     */
    leaseAccessConditions?: LeaseAccessConditions;
}
/**
 * Indicates inherit file permission from the parent directory.
 */
export declare type FilePermissionInheritType = "inherit";
/**
 * Indicates keep existing file permission value unchanged.
 */
export declare type FilePermissionPreserveType = "preserve";
export declare interface FileProperties extends FileAndDirectorySetPropertiesCommonOptions, CommonOptions {
    /**
     * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.
     * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.
     *
     * @type {AbortSignalLike}
     * @memberof FileProperties
     */
    abortSignal?: AbortSignalLike;
    /**
     * File HTTP headers like Content-Type.
     *
     * @type {FileHttpHeaders}
     * @memberof FileProperties
     */
    fileHttpHeaders?: FileHttpHeaders;
    /**
     * Lease access conditions.
     *
     * @type {LeaseAccessConditions}
     * @memberof FileProperties
     */
    leaseAccessConditions?: LeaseAccessConditions;
}
/**
 * File properties.
 */
export declare interface FileProperty {
    /**
     * Content length of the file. This value may not be up-to-date since an SMB client may have
     * modified the file locally. The value of Content-Length may not reflect that fact until the
     * handle is closed or the op-lock is broken. To retrieve current property values, call Get File
     * Properties.
     */
    contentLength: number;
}
/**
 * Options to configure the {@link ShareFileClient.resize} operation.
 *
 * @export
 * @interface FileResizeOptions
 */
export declare interface FileResizeOptions extends FileAndDirectorySetPropertiesCommonOptions, CommonOptions {
    /**
     * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.
     * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.
     *
     * @type {AbortSignalLike}
     * @memberof FileResizeOptions
     */
    abortSignal?: AbortSignalLike;
    /**
     * Lease access conditions.
     *
     * @type {LeaseAccessConditions}
     * @memberof FileResizeOptions
     */
    leaseAccessConditions?: LeaseAccessConditions;
}
/**
 * Abstract for entries that can be listed from Directory.
 */
export declare interface FilesAndDirectoriesListSegment {
    directoryItems: DirectoryItem[];
    fileItems: FileItem[];
}
/**
 * ONLY AVAILABLE IN NODE.JS RUNTIME.
 *
 * This is a helper class to construct a string representing the permissions granted by a ServiceSAS to a file. Setting
 * a value to true means that any SAS which uses these permissions will grant permissions for that operation. Once all
 * the values are set, this should be serialized with toString and set as the permissions field on a
 * {@link FileSASSignatureValues} object. It is possible to construct the permissions string without this class, but
 * the order of the permissions is particular and this class guarantees correctness.
 *
 * @export
 * @class FileSASPermissions
 */
export declare class FileSASPermissions {
    /**
     * Creates a FileSASPermissions from the specified permissions string. This method will throw an
     * Error if it encounters a character that does not correspond to a valid permission.
     *
     * @static
     * @param {string} permissions
     * @returns {FileSASPermissions}
     * @memberof FileSASPermissions
     */
    static parse(permissions: string): FileSASPermissions;
    /**
     * Specifies Read access granted.
     *
     * @type {boolean}
     * @memberof FileSASPermissions
     */
    read: boolean;
    /**
     * Specifies Create access granted.
     *
     * @type {boolean}
     * @memberof FileSASPermissions
     */
    create: boolean;
    /**
     * Specifies Write access granted.
     *
     * @type {boolean}
     * @memberof FileSASPermissions
     */
    write: boolean;
    /**
     * Specifies Delete access granted.
     *
     * @type {boolean}
     * @memberof FileSASPermissions
     */
    delete: boolean;
    /**
     * Converts the given permissions to a string. Using this method will guarantee the permissions are in an
     * order accepted by the service.
     *
     * @returns {string} A string which represents the FileSASPermissions
     * @memberof FileSASPermissions
     */
    toString(): string;
}
/**
 * ONLY AVAILABLE IN NODE.JS RUNTIME.
 *
 * FileSASSignatureValues is used to help generating File service SAS tokens for shares or files.
 *
 * @export
 * @class FileSASSignatureValues
 */
export declare interface FileSASSignatureValues {
    /**
     * The version of the service this SAS will target. If not specified, it will default to the version targeted by the
     * library.
     *
     * @type {string}
     * @memberof FileSASSignatureValues
     */
    version?: string;
    /**
     * Optional. SAS protocols, HTTPS only or HTTPSandHTTP
     *
     * @type {SASProtocol}
     * @memberof FileSASSignatureValues
     */
    protocol?: SASProtocol;
    /**
     * Optional. When the SAS will take effect.
     *
     * @type {Date}
     * @memberof FileSASSignatureValues
     */
    startsOn?: Date;
    /**
     * Optional only when identifier is provided. The time after which the SAS will no longer work.
     *
     * @type {Date}
     * @memberof FileSASSignatureValues
     */
    expiresOn?: Date;
    /**
     * Optional only when identifier is provided.
     * Please refer to either {@link ShareSASPermissions} or {@link FileSASPermissions} depending on the resource
     * being accessed for help constructing the permissions string.
     *
     * @type {FileSASPermissions}
     * @memberof FileSASSignatureValues
     */
    permissions?: FileSASPermissions;
    /**
     * Optional. IP ranges allowed in this SAS.
     *
     * @type {SasIPRange}
     * @memberof FileSASSignatureValues
     */
    ipRange?: SasIPRange;
    /**
     * The name of the share the SAS user may access.
     *
     * @type {string}
     * @memberof FileSASSignatureValues
     */
    shareName: string;
    /**
     * Optional. The path of the file like, "directory/FileName" or "FileName".
     *
     * @type {string}
     * @memberof FileSASSignatureValues
     */
    filePath?: string;
    /**
     * Optional. The name of the access policy on the share this SAS references if any.
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/establishing-a-stored-access-policy
     *
     * @type {string}
     * @memberof FileSASSignatureValues
     */
    identifier?: string;
    /**
     * Optional. The cache-control header for the SAS.
     *
     * @type {string}
     * @memberof FileSASSignatureValues
     */
    cacheControl?: string;
    /**
     * Optional. The content-disposition header for the SAS.
     *
     * @type {string}
     * @memberof FileSASSignatureValues
     */
    contentDisposition?: string;
    /**
     * Optional. The content-encoding header for the SAS.
     *
     * @type {string}
     * @memberof FileSASSignatureValues
     */
    contentEncoding?: string;
    /**
     * Optional. The content-language header for the SAS.
     *
     * @type {string}
     * @memberof FileSASSignatureValues
     */
    contentLanguage?: string;
    /**
     * Optional. The content-type header for the SAS.
     *
     * @type {string}
     * @memberof FileSASSignatureValues
     */
    contentType?: string;
}
/**
 * Storage service properties.
 */
export declare interface FileServiceProperties {
    /**
     * A summary of request statistics grouped by API in hourly aggregates for files.
     */
    hourMetrics?: Metrics;
    /**
     * A summary of request statistics grouped by API in minute aggregates for files.
     */
    minuteMetrics?: Metrics;
    /**
     * The set of CORS rules.
     */
    cors?: CorsRule[];
}
/**
 * Defines headers for SetHTTPHeaders operation.
 */
export declare interface FileSetHTTPHeadersHeaders {
    /**
     * The ETag contains a value which represents the version of the file, in quotes.
     */
    etag?: string;
    /**
     * Returns the date and time the directory was last modified. Any operation that modifies the
     * directory or its properties updates the last modified time. Operations on files do not affect
     * the last modified time of the directory.
     */
    lastModified?: Date;
    /**
     * This header uniquely identifies the request that was made and can be used for troubleshooting
     * the request.
     */
    requestId?: string;
    /**
     * Indicates the version of the File service used to execute the request.
     */
    version?: string;
    /**
     * A UTC date/time value generated by the service that indicates the time at which the response
     * was initiated.
     */
    date?: Date;
    /**
     * The value of this header is set to true if the contents of the request are successfully
     * encrypted using the specified algorithm, and false otherwise.
     */
    isServerEncrypted?: boolean;
    /**
     * Key of the permission set for the file.
     */
    filePermissionKey?: string;
    /**
     * Attributes set for the file.
     */
    fileAttributes?: string;
    /**
     * Creation time for the file.
     */
    fileCreatedOn?: Date;
    /**
     * Last write time for the file.
     */
    fileLastWriteOn?: Date;
    /**
     * Change time for the file.
     */
    fileChangeOn?: Date;
    /**
     * The fileId of the directory.
     */
    fileId?: string;
    /**
     * The parent fileId of the directory.
     */
    fileParentId?: string;
    errorCode?: string;
}
/**
 * Options to configure the {@link ShareFileClient.setHttpHeaders} operation.
 *
 * @export
 * @interface FileSetHttpHeadersOptions
 */
export declare interface FileSetHttpHeadersOptions extends FileAndDirectorySetPropertiesCommonOptions, CommonOptions {
    /**
     * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.
     * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.
     *
     * @type {AbortSignalLike}
     * @memberof FileSetHttpHeadersOptions
     */
    abortSignal?: AbortSignalLike;
    /**
     * Lease access conditions.
     *
     * @type {LeaseAccessConditions}
     * @memberof FileSetHttpHeadersOptions
     */
    leaseAccessConditions?: LeaseAccessConditions;
}
/**
 * Contains response data for the setHTTPHeaders operation.
 */
export declare type FileSetHTTPHeadersResponse = FileSetHTTPHeadersHeaders & {
    /**
     * The underlying HTTP response.
     */
    _response: coreHttp.HttpResponse & {
        /**
         * The parsed HTTP response headers.
         */
        parsedHeaders: FileSetHTTPHeadersHeaders;
    };
};
/**
 * Defines headers for SetMetadata operation.
 */
export declare interface FileSetMetadataHeaders {
    /**
     * The ETag contains a value which represents the version of the file, in quotes.
     */
    etag?: string;
    /**
     * This header uniquely identifies the request that was made and can be used for troubleshooting
     * the request.
     */
    requestId?: string;
    /**
     * Indicates the version of the File service used to execute the request.
     */
    version?: string;
    /**
     * A UTC date/time value generated by the service that indicates the time at which the response
     * was initiated.
     */
    date?: Date;
    /**
     * The value of this header is set to true if the contents of the request are successfully
     * encrypted using the specified algorithm, and false otherwise.
     */
    isServerEncrypted?: boolean;
    errorCode?: string;
}
/**
 * Options to configure the {@link ShareFileClient.setMetadata} operation.
 *
 * @export
 * @interface FileSetMetadataOptions
 */
export declare interface FileSetMetadataOptions extends CommonOptions {
    /**
     * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.
     * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.
     *
     * @type {AbortSignalLike}
     * @memberof FileSetMetadataOptions
     */
    abortSignal?: AbortSignalLike;
    /**
     * Lease access conditions.
     *
     * @type {LeaseAccessConditions}
     * @memberof FileSetMetadataOptions
     */
    leaseAccessConditions?: LeaseAccessConditions;
}
/**
 * Contains response data for the setMetadata operation.
 */
export declare type FileSetMetadataResponse = FileSetMetadataHeaders & {
    /**
     * The underlying HTTP response.
     */
    _response: coreHttp.HttpResponse & {
        /**
         * The parsed HTTP response headers.
         */
        parsedHeaders: FileSetMetadataHeaders;
    };
};
/**
 * Defines headers for StartCopy operation.
 */
export declare interface FileStartCopyHeaders {
    /**
     * If the copy is completed, contains the ETag of the destination file. If the copy is not
     * complete, contains the ETag of the empty file created at the start of the copy.
     */
    etag?: string;
    /**
     * Returns the date/time that the copy operation to the destination file completed.
     */
    lastModified?: Date;
    /**
     * This header uniquely identifies the request that was made and can be used for troubleshooting
     * the request.
     */
    requestId?: string;
    /**
     * Indicates the version of the File service used to execute the request.
     */
    version?: string;
    /**
     * A UTC date/time value generated by the service that indicates the time at which the response
     * was initiated.
     */
    date?: Date;
    /**
     * String identifier for this copy operation. Use with Get File or Get File Properties to check
     * the status of this copy operation, or pass to Abort Copy File to abort a pending copy.
     */
    copyId?: string;
    /**
     * State of the copy operation identified by x-ms-copy-id. Possible values include: 'pending',
     * 'success', 'aborted', 'failed'
     */
    copyStatus?: CopyStatusType;
    errorCode?: string;
}
/**
 * Options to configure the {@link ShareFileClient.startCopyFromURL} operation.
 *
 * @export
 * @interface FileStartCopyOptions
 */
export declare interface FileStartCopyOptions extends CommonOptions {
    /**
     * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.
     * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.
     *
     * @type {AbortSignalLike}
     * @memberof FileStartCopyOptions
     */
    abortSignal?: AbortSignalLike;
    /**
     * A collection of key-value string pair to associate with the file storage object.
     *
     * @type {Metadata}
     * @memberof FileStartCopyOptions
     */
    metadata?: Metadata;
    /**
     * Lease access conditions.
     *
     * @type {LeaseAccessConditions}
     * @memberof FileStartCopyOptions
     */
    leaseAccessConditions?: LeaseAccessConditions;
    /**
     * If specified the permission (security descriptor) shall be set for the directory/file. This
     * header can be used if Permission size is <= 8KB, else x-ms-file-permission-key header shall be
     * used. Default value: Inherit. If SDDL is specified as input, it must have owner, group and
     * dacl. Note: Only one of the x-ms-file-permission or x-ms-file-permission-key should be
     * specified.
     *
     * @type {string}
     * @memberof FileStartCopyOptions
     */
    filePermission?: string;
    /**
     * Key of the permission to be set for the directory/file. Note: Only one of the
     * x-ms-file-permission or x-ms-file-permission-key should be specified.
     *
     * @type {string}
     * @memberof FileStartCopyOptions
     */
    filePermissionKey?: string;
    /**
     * SMB info.
     *
     * @type {CopyFileSmbInfo}
     * @memberof FileStartCopyOptions
     */
    copyFileSmbInfo?: CopyFileSmbInfo;
}
/**
 * Contains response data for the startCopy operation.
 */
export declare type FileStartCopyResponse = FileStartCopyHeaders & {
    /**
     * The underlying HTTP response.
     */
    _response: coreHttp.HttpResponse & {
        /**
         * The parsed HTTP response headers.
         */
        parsedHeaders: FileStartCopyHeaders;
    };
};
/**
 * This is a helper class to construct a string representing the NTFS attributes to a file or directory.
 * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-file#file-system-attributes
 *
 * @export
 * @class FileSystemAttributes
 */
export declare class FileSystemAttributes {
    /**
     * Creates a FileSystemAttributes from the specified attributes string. This method will throw an
     * Error if it encounters a string that does not correspond to a valid attributes.
     *
     * @static
     * @param {string} fileAttributes The value of header x-ms-file-attributes.
     * @returns {FileSystemAttributes}
     * @memberof FileSystemAttributes
     */
    static parse(fileAttributes: string): FileSystemAttributes;
    /**
     * Specifies a directory or file that is read-only.
     *
     * @type {boolean}
     * @memberof FileSystemAttributes
     */
    readonly: boolean;
    /**
     * Specifies a directory or file is hidden.
     *
     * @type {boolean}
     * @memberof FileSystemAttributes
     */
    hidden: boolean;
    /**
     * Specifies a directory or file that the operating system uses a part of, or uses exclusively.
     *
     * @type {boolean}
     * @memberof FileSystemAttributes
     */
    system: boolean;
    /**
     * Specifies a directory or file that does not have other attributes set. This attribute is valid only when used alone.
     *
     * @type {boolean}
     * @memberof FileSystemAttributes
     */
    none: boolean;
    /**
     * Specifies the handle identifies a directory.
     *
     * @type {boolean}
     * @memberof FileSystemAttributes
     */
    directory: boolean;
    /**
     * Specifies a directory or file is an archive. Applications typically use this attribute to mark files for backup or removal.
     *
     * @type {boolean}
     * @memberof FileSystemAttributes
     */
    archive: boolean;
    /**
     * Specifies if a file is temporary.
     */
    temporary: boolean;
    /**
     * Specifies the data of a directory or file is not available immediately.
     * This file system attribute is presented primarily to provide compatibility with Windows - Azure Files does not support with offline storage options.
     *
     * @type {boolean}
     * @memberof FileSystemAttributes
     */
    offline: boolean;
    /**
     * Specifies the directory or file is not to be indexed by the content indexing service.
     *
     * @type {boolean}
     * @memberof FileSystemAttributes
     */
    notContentIndexed: boolean;
    /**
     * Specifies the user data stream not to be read by the background data integrity scanner.
     * This file system attribute is presented primarily to provide compatibility with Windows.
     * Applicable to directory or file.
     *
     * @type {boolean}
     * @memberof FileSystemAttributes
     */
    noScrubData: boolean;
    /**
     * Converts the given attributes to a string.
     *
     * @returns {string} A string which represents the FileSystemAttributes
     * @memberof FileSystemAttributes
     */
    toString(): string;
}
/**
 * Defines values for FileType.
 * Possible values include: 'File'
 * @readonly
 * @enum {string}
 */
export declare type FileType = 'File';
/**
 * Defines headers for UploadRangeFromURL operation.
 */
export declare interface FileUploadRangeFromURLHeaders {
    /**
     * The ETag contains a value which represents the version of the file, in quotes.
     */
    etag?: string;
    /**
     * Returns the date and time the directory was last modified. Any operation that modifies the
     * share or its properties or metadata updates the last modified time. Operations on files do not
     * affect the last modified time of the share.
     */
    lastModified?: Date;
    /**
     * This header is returned so that the client can check for message content integrity. The value
     * of this header is computed by the File service; it is not necessarily the same value as may
     * have been specified in the request headers.
     */
    xMsContentCrc64?: Uint8Array;
    /**
     * This header uniquely identifies the request that was made and can be used for troubleshooting
     * the request.
     */
    requestId?: string;
    /**
     * Indicates the version of the File service used to execute the request.
     */
    version?: string;
    /**
     * A UTC date/time value generated by the service that indicates the time at which the response
     * was initiated.
     */
    date?: Date;
    /**
     * The value of this header is set to true if the contents of the request are successfully
     * encrypted using the specified algorithm, and false otherwise.
     */
    isServerEncrypted?: boolean;
    errorCode?: string;
}
/**
 * Optional Parameters.
 */
export declare interface FileUploadRangeFromURLOptionalParams extends coreHttp.RequestOptionsBase {
    /**
     * The timeout parameter is expressed in seconds. For more information, see <a
     * href="https://docs.microsoft.com/en-us/rest/api/storageservices/Setting-Timeouts-for-File-Service-Operations?redirectedfrom=MSDN">Setting
     * Timeouts for File Service Operations.</a>
     */
    timeoutInSeconds?: number;
    /**
     * Bytes of source data in the specified range.
     */
    sourceRange?: string;
    /**
     * Specify the crc64 calculated for the range of bytes that must be read from the copy source.
     */
    sourceContentCrc64?: Uint8Array;
    /**
     * Additional parameters for the operation
     */
    sourceModifiedAccessConditions?: SourceModifiedAccessConditions;
    /**
     * Additional parameters for the operation
     */
    leaseAccessConditions?: LeaseAccessConditions;
}
/**
 * Options to configure the {@link ShareFileClient.uploadRangeFromURL} operation.
 *
 * @export
 * @interface FileUploadRangeFromURLOptions
 */
export declare interface FileUploadRangeFromURLOptions extends CommonOptions {
    /**
     * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.
     * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.
     *
     * @type {AbortSignalLike}
     * @memberof FileUploadRangeFromURLOptions
     */
    abortSignal?: AbortSignalLike;
    /**
     * The timeout parameter is expressed in seconds. For more information, see <a
     * href="https://docs.microsoft.com/en-us/rest/api/storageservices/Setting-Timeouts-for-File-Service-Operations?redirectedfrom=MSDN">Setting
     * Timeouts for File Service Operations.</a>
     */
    timeoutInSeconds?: number;
    /**
     * Specify the crc64 calculated for the range of bytes that must be read from the copy source.
     */
    sourceContentCrc64?: Uint8Array;
    /**
     * Additional parameters for the operation
     */
    sourceConditions?: SourceModifiedAccessConditions;
    /**
     * Lease access conditions.
     *
     * @type {LeaseAccessConditions}
     * @memberof FileUploadRangeFromURLOptions
     */
    leaseAccessConditions?: LeaseAccessConditions;
}
/**
 * Contains response data for the uploadRangeFromURL operation.
 */
export declare type FileUploadRangeFromURLResponse = FileUploadRangeFromURLHeaders & {
    /**
     * The underlying HTTP response.
     */
    _response: coreHttp.HttpResponse & {
        /**
         * The parsed HTTP response headers.
         */
        parsedHeaders: FileUploadRangeFromURLHeaders;
    };
};
/**
 * Defines headers for UploadRange operation.
 */
export declare interface FileUploadRangeHeaders {
    /**
     * The ETag contains a value which represents the version of the file, in quotes.
     */
    etag?: string;
    /**
     * Returns the date and time the directory was last modified. Any operation that modifies the
     * share or its properties or metadata updates the last modified time. Operations on files do not
     * affect the last modified time of the share.
     */
    lastModified?: Date;
    /**
     * This header is returned so that the client can check for message content integrity. The value
     * of this header is computed by the File service; it is not necessarily the same value as may
     * have been specified in the request headers.
     */
    contentMD5?: Uint8Array;
    /**
     * This header uniquely identifies the request that was made and can be used for troubleshooting
     * the request.
     */
    requestId?: string;
    /**
     * Indicates the version of the File service used to execute the request.
     */
    version?: string;
    /**
     * A UTC date/time value generated by the service that indicates the time at which the response
     * was initiated.
     */
    date?: Date;
    /**
     * The value of this header is set to true if the contents of the request are successfully
     * encrypted using the specified algorithm, and false otherwise.
     */
    isServerEncrypted?: boolean;
    errorCode?: string;
}
/**
 * Options to configure the {@link ShareFileClient.uploadRange} operation.
 *
 * @export
 * @interface FileUploadRangeOptions
 */
export declare interface FileUploadRangeOptions extends CommonOptions {
    /**
     * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.
     * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.
     *
     * @type {AbortSignalLike}
     * @memberof FileUploadRangeOptions
     */
    abortSignal?: AbortSignalLike;
    /**
     * An MD5 hash of the content. This hash is
     * used to verify the integrity of the data during transport. When the
     * Content-MD5 header is specified, the File service compares the hash of the
     * content that has arrived with the header value that was sent. If the two
     * hashes do not match, the operation will fail with error code 400 (Bad
     * Request).
     *
     * @type {Uint8Array}
     * @memberof FileUploadRangeOptions
     */
    contentMD5?: Uint8Array;
    /**
     * Progress updating event handler.
     *
     * @memberof FileUploadRangeOptions
     */
    onProgress?: (progress: TransferProgressEvent) => void;
    /**
     * Lease access conditions.
     *
     * @type {LeaseAccessConditions}
     * @memberof FileUploadRangeOptions
     */
    leaseAccessConditions?: LeaseAccessConditions;
}
/**
 * Contains response data for the uploadRange operation.
 */
export declare type FileUploadRangeResponse = FileUploadRangeHeaders & {
    /**
     * The underlying HTTP response.
     */
    _response: coreHttp.HttpResponse & {
        /**
         * The parsed HTTP response headers.
         */
        parsedHeaders: FileUploadRangeHeaders;
    };
};
/**
 * Option interface for ShareFileClient.uploadStream().
 *
 * @export
 * @interface FileUploadStreamOptions
 */
export declare interface FileUploadStreamOptions extends CommonOptions {
    /**
     * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.
     * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.
     *
     * @type {AbortSignalLike}
     * @memberof FileUploadStreamOptions
     */
    abortSignal?: AbortSignalLike;
    /**
     * Azure File HTTP Headers.
     *
     * @type {FileHttpHeaders}
     * @memberof FileUploadStreamOptions
     */
    fileHttpHeaders?: FileHttpHeaders;
    /**
     * Metadata of the Azure file.
     *
     * @type {Metadata}
     * @memberof FileUploadStreamOptions
     */
    metadata?: Metadata;
    /**
     * Progress updater.
     *
     * @memberof FileUploadStreamOptions
     */
    onProgress?: (progress: TransferProgressEvent) => void;
    /**
     * Lease access conditions.
     *
     * @type {LeaseAccessConditions}
     * @memberof FileUploadStreamOptions
     */
    leaseAccessConditions?: LeaseAccessConditions;
}
/**
 * ONLY AVAILABLE IN NODE.JS RUNTIME.
 *
 * Generates a {@link SASQueryParameters} object which contains all SAS query parameters needed to make an actual
 * REST request.
 *
 * @see https://docs.microsoft.com/en-us/rest/api/storageservices/constructing-an-account-sas
 *
 * @param {StorageSharedKeyCredential} sharedKeyCredential
 * @returns {SASQueryParameters}
 * @memberof AccountSASSignatureValues
 */
export declare function generateAccountSASQueryParameters(accountSASSignatureValues: AccountSASSignatureValues, sharedKeyCredential: StorageSharedKeyCredential): SASQueryParameters;
/**
 * ONLY AVAILABLE IN NODE.JS RUNTIME.
 *
 * Creates an instance of SASQueryParameters.
 *
 * Only accepts required settings needed to create a SAS. For optional settings please
 * set corresponding properties directly, such as permissions, startsOn and identifier.
 *
 * WARNING: When identifier is not provided, permissions and expiresOn are required.
 * You MUST assign value to identifier or expiresOn & permissions manually if you initial with
 * this constructor.
 *
 * @export
 * @param {FileSASSignatureValues} fileSASSignatureValues
 * @param {StorageSharedKeyCredential} sharedKeyCredential
 * @returns {SASQueryParameters}
 */
export declare function generateFileSASQueryParameters(fileSASSignatureValues: FileSASSignatureValues, sharedKeyCredential: StorageSharedKeyCredential): SASQueryParameters;
/**
 * A listed Azure Storage handle item.
 */
export declare interface HandleItem {
    /**
     * XSMB service handle ID
     */
    handleId: string;
    /**
     * File or directory name including full path starting from share root
     */
    path: string;
    /**
     * FileId uniquely identifies the file or directory.
     */
    fileId: string;
    /**
     * ParentId uniquely identifies the parent directory of the object.
     */
    parentId?: string;
    /**
     * SMB session ID in context of which the file handle was opened
     */
    sessionId: string;
    /**
     * Client IP that opened the handle
     */
    clientIp: string;
    /**
     * Time when the session that previously opened the handle has last been reconnected. (UTC)
     */
    openTime: Date;
    /**
     * Time handle was last connected to (UTC)
     */
    lastReconnectTime?: Date;
}
export { HttpHeaders };
export { HttpOperationResponse };
export { HttpRequestBody };
export { IHttpClient };
/**
 * Additional parameters for a set of operations.
 */
export declare interface LeaseAccessConditions {
    /**
     * If specified, the operation only succeeds if the resource's lease is active and matches this
     * ID.
     */
    leaseId?: string;
}
/**
 * Defines values for LeaseDurationType.
 * Possible values include: 'infinite', 'fixed'
 * @readonly
 * @enum {string}
 */
export declare type LeaseDurationType = 'infinite' | 'fixed';
/**
 * lease operations options.
 *
 * @export
 * @interface LeaseOperationOptions
 */
export declare interface LeaseOperationOptions extends CommonOptions {
    /**
     * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.
     * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.
     *
     * @type {AbortSignalLike}
     * @memberof LeaseOperationOptions
     */
    abortSignal?: AbortSignalLike;
}
/**
 * Contains the response data for operations that acquire, change, break or release a lease.
 *
 * See {@link ShareLeaseClient}.
 */
export declare type LeaseOperationResponse = LeaseOperationResponseHeaders & {
    /**
     * The underlying HTTP response.
     */
    _response: HttpResponse & {
        /**
         * The parsed HTTP response headers.
         */
        parsedHeaders: LeaseOperationResponseHeaders;
    };
};
/**
 * The details of the response for a specific lease operation.
 */
export declare interface LeaseOperationResponseHeaders {
    /**
     * The ETag contains a value that you can use to perform operations conditionally. If the request
     * version is 2011-08-18 or newer, the ETag value will be in quotes.
     */
    etag?: string;
    /**
     * Returns the date and time the file was last modified. Any operation that modifies the file,
     * including an update of the file's metadata or properties, changes the last-modified time of
     * the file.
     */
    lastModified?: Date;
    /**
     * Uniquely identifies a file's lease, won't be set when returned by releaseLease.
     */
    leaseId?: string;
    /**
     * This header uniquely identifies the request that was made and can be used for troubleshooting
     * the request.
     */
    requestId?: string;
    /**
     * Indicates the version of the Blob service used to execute the request. This header is returned
     * for requests made against version 2009-09-19 and above.
     */
    version?: string;
    /**
     * UTC date/time value generated by the service that indicates the time at which the response was
     * initiated
     */
    date?: Date;
    errorCode?: string;
}
/**
 * Defines values for LeaseStateType.
 * Possible values include: 'available', 'leased', 'expired', 'breaking', 'broken'
 * @readonly
 * @enum {string}
 */
export declare type LeaseStateType = 'available' | 'leased' | 'expired' | 'breaking' | 'broken';
/**
 * Defines values for LeaseStatusType.
 * Possible values include: 'locked', 'unlocked'
 * @readonly
 * @enum {string}
 */
export declare type LeaseStatusType = 'locked' | 'unlocked';
/**
 * An enumeration of directories and files.
 */
export declare interface ListFilesAndDirectoriesSegmentResponse {
    serviceEndpoint: string;
    shareName: string;
    shareSnapshot?: string;
    directoryPath: string;
    prefix: string;
    marker?: string;
    maxResults?: number;
    segment: FilesAndDirectoriesListSegment;
    continuationToken: string;
}
/**
 * An enumeration of handles.
 */
export declare interface ListHandlesResponse {
    handleList?: HandleItem[];
    continuationToken: string;
}
/**
 * Defines values for ListSharesIncludeType.
 * Possible values include: 'snapshots', 'metadata', 'deleted'
 * @readonly
 * @enum {string}
 */
export declare type ListSharesIncludeType = 'snapshots' | 'metadata' | 'deleted';
/**
 * An enumeration of shares.
 */
export declare interface ListSharesResponse {
    serviceEndpoint: string;
    prefix?: string;
    marker?: string;
    maxResults?: number;
    shareItems?: ShareItem[];
    continuationToken: string;
}
/**
 * The @azure/logger configuration for this package.
 */
export declare const logger: import("@azure/logger").AzureLogger;
export declare interface Metadata {
    [propertyName: string]: string;
}
/**
 * Storage Analytics metrics for file service.
 */
export declare interface Metrics {
    /**
     * The version of Storage Analytics to configure.
     */
    version: string;
    /**
     * Indicates whether metrics are enabled for the File service.
     */
    enabled: boolean;
    /**
     * Indicates whether metrics should generate summary statistics for called API operations.
     */
    includeAPIs?: boolean;
    retentionPolicy?: RetentionPolicy;
}
/**
 * Creates a new {@link Pipeline} object with {@link Credential} provided.
 *
 * @static
 * @param {Credential} credential Such as AnonymousCredential, StorageSharedKeyCredential.
 * @param {StoragePipelineOptions} [pipelineOptions] Optional. Options.
 * @returns {Pipeline} A new Pipeline object.
 * @memberof Pipeline
 */
export declare function newPipeline(credential?: Credential, pipelineOptions?: StoragePipelineOptions): Pipeline;
/**
 * Defines values for PermissionCopyModeType.
 * Possible values include: 'source', 'override'
 * @readonly
 * @enum {string}
 */
declare type PermissionCopyModeType = 'source' | 'override';
/**
 * A Pipeline class containing HTTP request policies.
 * You can create a default Pipeline by calling {@link newPipeline}.
 * Or you can create a Pipeline with your own policies by the constructor of Pipeline.
 *
 * Refer to {@link newPipeline} and provided policies as reference before
 * implementing your customized Pipeline.
 *
 * @export
 * @class Pipeline
 */
export declare class Pipeline {
    /**
     * A list of chained request policy factories.
     *
     * @type {RequestPolicyFactory[]}
     * @memberof Pipeline
     */
    readonly factories: RequestPolicyFactory[];
    /**
     * Configures pipeline logger and HTTP client.
     *
     * @type {PipelineOptions}
     * @memberof Pipeline
     */
    readonly options: PipelineOptions;
    /**
     * Creates an instance of Pipeline. Customize HTTPClient by implementing IHttpClient interface.
     *
     * @param {RequestPolicyFactory[]} factories
     * @param {PipelineOptions} [options={}]
     * @memberof Pipeline
     */
    constructor(factories: RequestPolicyFactory[], options?: PipelineOptions);
    /**
     * Transfer Pipeline object to ServiceClientOptions object which required by
     * ServiceClient constructor.
     *
     * @returns {ServiceClientOptions} The ServiceClientOptions object from this Pipeline.
     * @memberof Pipeline
     */
    toServiceClientOptions(): ServiceClientOptions;
}
/**
 * Option interface for Pipeline constructor.
 *
 * @export
 * @interface PipelineOptions
 */
export declare interface PipelineOptions {
    /**
     * Optional. Configures the HTTP client to send requests and receive responses.
     *
     * @type {IHttpClient}
     * @memberof PipelineOptions
     */
    httpClient?: IHttpClient;
}
/**
 * Range for Service Operations.
 * @see https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-the-range-header-for-file-service-operations
 *
 * @export
 * @interface Range
 */
export declare interface Range {
    /**
     * StartByte, larger than or equal 0.
     *
     * @type {string}
     * @memberof Range
     */
    offset: number;
    /**
     * Optional. Count of bytes, larger than 0.
     * If not provided, will return bytes from offset to the end.
     *
     * @type {string}
     * @memberof Range
     */
    count?: number;
}
/**
 * An Azure Storage file range.
 */
export declare interface RangeModel {
    /**
     * Start of the range.
     */
    start: number;
    /**
     * End of the range.
     */
    end: number;
}
export { RequestPolicy };
export { RequestPolicyFactory };
export { RequestPolicyOptions };
export { RestError };
/**
 * The retention policy.
 */
export declare interface RetentionPolicy {
    /**
     * Indicates whether a retention policy is enabled for the File service. If false, metrics data
     * is retained, and the user is responsible for deleting it.
     */
    enabled: boolean;
    /**
     * Indicates the number of days that metrics data should be retained. All data older than this
     * value will be deleted. Metrics data is deleted on a best-effort basis after the retention
     * period expires.
     */
    days?: number;
}
/**
 * Allowed IP range for a SAS.
 *
 * @export
 * @interface SasIPRange
 */
export declare interface SasIPRange {
    /**
     * Starting IP address in the IP range.
     * If end IP doesn't provide, start IP will the only IP allowed.
     *
     * @type {string}
     * @memberof SasIPRange
     */
    start: string;
    /**
     * Optional. IP address that ends the IP range.
     * If not provided, start IP will the only IP allowed.
     *
     * @type {string}
     * @memberof SasIPRange
     */
    end?: string;
}
/**
 * Protocols for generated SAS.
 *
 * @export
 * @enum {number}
 */
export declare enum SASProtocol {
    /**
     * Protocol that allows HTTPS only
     */
    Https = "https",
    /**
     * Protocol that allows both HTTPS and HTTP
     */
    HttpsAndHttp = "https,http"
}
/**
 * Represents the components that make up an Azure Storage SAS' query parameters. This type is not constructed directly
 * by the user; it is only generated by the {@link AccountSASSignatureValues} and {@link FileSASSignatureValues}
 * types. Once generated, it can be encoded into a {@code String} and appended to a URL directly (though caution should
 * be taken here in case there are existing query parameters, which might affect the appropriate means of appending
 * these query parameters).
 *
 * NOTE: Instances of this class are immutable.
 *
 * @export
 * @class SASQueryParameters
 */
export declare class SASQueryParameters {
    /**
     * The storage API version.
     *
     * @type {string}
     * @memberof SASQueryParameters
     */
    readonly version: string;
    /**
     * Optional. The allowed HTTP protocol(s).
     *
     * @type {SASProtocol}
     * @memberof SASQueryParameters
     */
    readonly protocol?: SASProtocol;
    /**
     * Optional. The start time for this SAS token.
     *
     * @type {Date}
     * @memberof SASQueryParameters
     */
    readonly startsOn?: Date;
    /**
     * Optional only when identifier is provided. The expiry time for this SAS token.
     *
     * @type {Date}
     * @memberof SASQueryParameters
     */
    readonly expiresOn?: Date;
    /**
     * Optional only when identifier is provided.
     * Please refer to {@link AccountSASPermissions}, {@link FileSASPermissions}, or {@link ShareSASPermissions} for
     * more details.
     *
     * @type {string}
     * @memberof SASQueryParameters
     */
    readonly permissions?: string;
    /**
     * Optional. The storage services being accessed (only for Account SAS). Please refer to {@link AccountSASServices}
     * for more details.
     *
     * @type {string}
     * @memberof SASQueryParameters
     */
    readonly services?: string;
    /**
     * Optional. The storage resource types being accessed (only for Account SAS). Please refer to
     * {@link AccountSASResourceTypes} for more details.
     *
     * @type {string}
     * @memberof SASQueryParameters
     */
    readonly resourceTypes?: string;
    /**
     * Optional. The signed identifier (only for {@link FileSASSignatureValues}).
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/establishing-a-stored-access-policy
     *
     * @type {string}
     * @memberof SASQueryParameters
     */
    readonly identifier?: string;
    /**
     * Optional. The storage share or file path (only for {@link FileSASSignatureValues}).
     *
     * @type {string}
     * @memberof SASQueryParameters
     */
    readonly resource?: string;
    /**
     * The signature for the SAS token.
     *
     * @type {string}
     * @memberof SASQueryParameters
     */
    readonly signature: string;
    /**
     * Value for cache-control header in Blob/File Service SAS.
     *
     * @type {string}
     * @memberof SASQueryParameters
     */
    readonly cacheControl?: string;
    /**
     * Value for content-disposition header in Blob/File Service SAS.
     *
     * @type {string}
     * @memberof SASQueryParameters
     */
    readonly contentDisposition?: string;
    /**
     * Value for content-encoding header in Blob/File Service SAS.
     *
     * @type {string}
     * @memberof SASQueryParameters
     */
    readonly contentEncoding?: string;
    /**
     * Value for content-length header in Blob/File Service SAS.
     *
     * @type {string}
     * @memberof SASQueryParameters
     */
    readonly contentLanguage?: string;
    /**
     * Value for content-type header in Blob/File Service SAS.
     *
     * @type {string}
     * @memberof SASQueryParameters
     */
    readonly contentType?: string;
    /**
     * Inner value of getter ipRange.
     *
     * @private
     * @type {SasIPRange}
     * @memberof SASQueryParameters
     */
    private readonly ipRangeInner?;
    readonly ipRange: SasIPRange | undefined;
    /**
     * Creates an instance of SASQueryParameters.
     *
     * @param {string} version Representing the storage version
     * @param {string} signature Representing the signature for the SAS token
     * @param {string} [permissions] Representing the storage permissions
     * @param {string} [services] Representing the storage services being accessed (only for Account SAS)
     * @param {string} [resourceTypes] Representing the storage resource types being accessed (only for Account SAS)
     * @param {SASProtocol} [protocol] Representing the allowed HTTP protocol(s)
     * @param {Date} [startsOn] Representing the start time for this SAS token
     * @param {Date} [expiresOn] Representing the expiry time for this SAS token
     * @param {SasIPRange} [ipRange] Representing the range of valid IP addresses for this SAS token
     * @param {string} [identifier] Representing the signed identifier (only for Service SAS)
     * @param {string} [resource] Representing the storage container or blob (only for Service SAS)
     * @param {string} [cacheControl] Representing the cache-control header (only for Blob/File Service SAS)
     * @param {string} [contentDisposition] Representing the content-disposition header (only for Blob/File Service SAS)
     * @param {string} [contentEncoding] Representing the content-encoding header (only for Blob/File Service SAS)
     * @param {string} [contentLanguage] Representing the content-language header (only for Blob/File Service SAS)
     * @param {string} [contentType] Representing the content-type header (only for Blob/File Service SAS)
     * @memberof SASQueryParameters
     */
    constructor(version: string, signature: string, permissions?: string, services?: string, resourceTypes?: string, protocol?: SASProtocol, startsOn?: Date, expiresOn?: Date, ipRange?: SasIPRange, identifier?: string, resource?: string, cacheControl?: string, contentDisposition?: string, contentEncoding?: string, contentLanguage?: string, contentType?: string);
    /**
     * Encodes all SAS query parameters into a string that can be appended to a URL.
     *
     * @returns {string}
     * @memberof SASQueryParameters
     */
    toString(): string;
    /**
     * A private helper method used to filter and append query key/value pairs into an array.
     *
     * @private
     * @param {string[]} queries
     * @param {string} key
     * @param {string} [value]
     * @returns {void}
     * @memberof SASQueryParameters
     */
    private tryAppendQueryParameter;
}
/**
 * Defines headers for GetProperties operation.
 */
export declare interface ServiceGetPropertiesHeaders {
    /**
     * This header uniquely identifies the request that was made and can be used for troubleshooting
     * the request.
     */
    requestId?: string;
    /**
     * Indicates the version of the File service used to execute the request.
     */
    version?: string;
    errorCode?: string;
}
/**
 * Options to configure the {@link ShareServiceClient.getProperties} operation.
 *
 * @export
 * @interface ServiceGetPropertiesOptions
 */
export declare interface ServiceGetPropertiesOptions extends CommonOptions {
    /**
     * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.
     * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.
     *
     * @type {AbortSignalLike}
     * @memberof AppendBlobCreateOptions
     */
    abortSignal?: AbortSignalLike;
}
/**
 * Contains response data for the getProperties operation.
 */
export declare type ServiceGetPropertiesResponse = FileServiceProperties & ServiceGetPropertiesHeaders & {
    /**
     * The underlying HTTP response.
     */
    _response: coreHttp.HttpResponse & {
        /**
         * The parsed HTTP response headers.
         */
        parsedHeaders: ServiceGetPropertiesHeaders;
        /**
         * The response body as text (string format)
         */
        bodyAsText: string;
        /**
         * The response body as parsed JSON or XML
         */
        parsedBody: FileServiceProperties;
    };
};
/**
 * Options to configure the {@link ShareServiceClient.listShares} operation.
 *
 * @export
 * @interface ServiceListSharesOptions
 */
export declare interface ServiceListSharesOptions extends CommonOptions {
    /**
     * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.
     * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.
     *
     * @type {AbortSignalLike}
     * @memberof ServiceListSharesOptions
     */
    abortSignal?: AbortSignalLike;
    /**
     * Filters the results to return only entries whose
     * name begins with the specified prefix.
     *
     * @type {string}
     * @memberof ServiceListSharesOptions
     */
    prefix?: string;
    /**
     * Specifies that share snapshots should be included in the enumeration. Share Snapshots are listed from oldest to newest in the response.
     *
     * @type {boolean}
     * @memberof ServiceListSharesOptions
     */
    includeMetadata?: boolean;
    /**
     * Specifies that share snapshot should be returned in the response.
     *
     * @type {boolean}
     * @memberof ServiceListSharesOptions
     */
    includeSnapshots?: boolean;
    /**
     * Specifies that share soft deleted should be returned in the response.
     *
     * @type {boolean}
     * @memberof ServiceListSharesOptions
     */
    includeDeleted?: boolean;
}
/**
 * Defines headers for ListSharesSegment operation.
 */
export declare interface ServiceListSharesSegmentHeaders {
    /**
     * This header uniquely identifies the request that was made and can be used for troubleshooting
     * the request.
     */
    requestId?: string;
    /**
     * Indicates the version of the File service used to execute the request.
     */
    version?: string;
    errorCode?: string;
}
/**
 * Contains response data for the listSharesSegment operation.
 */
export declare type ServiceListSharesSegmentResponse = ListSharesResponse & ServiceListSharesSegmentHeaders & {
    /**
     * The underlying HTTP response.
     */
    _response: coreHttp.HttpResponse & {
        /**
         * The parsed HTTP response headers.
         */
        parsedHeaders: ServiceListSharesSegmentHeaders;
        /**
         * The response body as text (string format)
         */
        bodyAsText: string;
        /**
         * The response body as parsed JSON or XML
         */
        parsedBody: ListSharesResponse;
    };
};
/**
 * Defines headers for SetProperties operation.
 */
export declare interface ServiceSetPropertiesHeaders {
    /**
     * This header uniquely identifies the request that was made and can be used for troubleshooting
     * the request.
     */
    requestId?: string;
    /**
     * Indicates the version of the File service used to execute the request.
     */
    version?: string;
    errorCode?: string;
}
/**
 * Options to configure the {@link ShareServiceClient.setProperties} operation.
 *
 * @export
 * @interface ServiceSetPropertiesOptions
 */
export declare interface ServiceSetPropertiesOptions extends CommonOptions {
    /**
     * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.
     * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.
     *
     * @type {AbortSignalLike}
     * @memberof AppendBlobCreateOptions
     */
    abortSignal?: AbortSignalLike;
}
/**
 * Contains response data for the setProperties operation.
 */
export declare type ServiceSetPropertiesResponse = ServiceSetPropertiesHeaders & {
    /**
     * The underlying HTTP response.
     */
    _response: coreHttp.HttpResponse & {
        /**
         * The parsed HTTP response headers.
         */
        parsedHeaders: ServiceSetPropertiesHeaders;
    };
};
/**
 * Options to configure the {@link ShareServiceClient.undelete} operation.
 *
 * @export
 * @interface ServiceUndeleteShareOptions
 */
export declare interface ServiceUndeleteShareOptions extends CommonOptions {
    /**
     * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.
     * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.
     *
     * @type {AbortSignalLike}
     * @memberof ServiceUndeleteShareOptions
     */
    abortSignal?: AbortSignalLike;
}
export declare interface SetPropertiesResponse extends FileSetHTTPHeadersResponse {
}
/**
 * A ShareClient represents a URL to the Azure Storage share allowing you to manipulate its directories and files.
 *
 * @export
 * @class ShareClient
 */
export declare class ShareClient extends StorageClient {
    /**
     * Share operation context provided by protocol layer.
     *
     * @private
     * @type {Share}
     * @memberof ShareClient
     */
    private context;
    private _name;
    readonly name: string;
    /**
     * @param {string} connectionString Account connection string or a SAS connection string of an Azure storage account.
     *                                  [ Note - Account connection string can only be used in NODE.JS runtime. ]
     *                                  Account connection string example -
     *                                  `DefaultEndpointsProtocol=https;AccountName=myaccount;AccountKey=accountKey;EndpointSuffix=core.windows.net`
     *                                  SAS connection string example -
     *                                  `BlobEndpoint=https://myaccount.blob.core.windows.net/;QueueEndpoint=https://myaccount.queue.core.windows.net/;FileEndpoint=https://myaccount.file.core.windows.net/;TableEndpoint=https://myaccount.table.core.windows.net/;SharedAccessSignature=sasString`
     * @param {string} name Share name.
     * @param {StoragePipelineOptions} [options] Optional. Options to configure the HTTP pipeline.
     * @memberof ShareClient
     */
    constructor(connectionString: string, name: string, options?: StoragePipelineOptions);
    /**
     * Creates an instance of ShareClient.
     *
     * @param {string} url A URL string pointing to Azure Storage file share, such as
     *                     "https://myaccount.file.core.windows.net/share". You can
     *                     append a SAS if using AnonymousCredential, such as
     *                     "https://myaccount.file.core.windows.net/share?sasString".
     * @param {Credential} [credential] Such as AnonymousCredential or StorageSharedKeyCredential.
     *                                  If not specified, AnonymousCredential is used.
     * @param {StoragePipelineOptions} [options] Optional. Options to configure the HTTP pipeline.
     * @memberof ShareClient
     */
    constructor(url: string, credential?: Credential, options?: StoragePipelineOptions);
    /**
     * Creates an instance of ShareClient.
     *
     * @param {string} url A URL string pointing to Azure Storage file share, such as
     *                     "https://myaccount.file.core.windows.net/share". You can
     *                     append a SAS if using AnonymousCredential, such as
     *                     "https://myaccount.file.core.windows.net/share?sasString".
     * @param {Pipeline} pipeline Call newPipeline() to create a default
     *                            pipeline, or provide a customized pipeline.
     * @memberof ShareClient
     */
    constructor(url: string, pipeline: Pipeline);
    /**
     * Creates a new ShareClient object identical to the source but with the specified snapshot timestamp.
     * Provide "" will remove the snapshot and return a URL to the base share.
     *
     * @param {string} snapshot The snapshot timestamp.
     * @returns {ShareClient} A new ShareClient object identical to the source but with the specified snapshot timestamp
     * @memberof ShareClient
     */
    withSnapshot(snapshot: string): ShareClient;
    /**
     * Creates a new share under the specified account. If the share with
     * the same name already exists, the operation fails.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-share
     *
     * @param {ShareCreateOptions} [options] Options to Share Create operation.
     * @returns {Promise<ShareCreateResponse>} Response data for the Share Create operation.
     * @memberof ShareClient
     */
    create(options?: ShareCreateOptions): Promise<ShareCreateResponse>;
    /**
     * Creates a new share under the specified account. If the share with
     * the same name already exists, it is not changed.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-share
     *
     * @param {ShareCreateOptions} [options]
     * @returns {Promise<ShareCreateIfNotExistsResponse>}
     * @memberof ShareClient
     */
    createIfNotExists(options?: ShareCreateOptions): Promise<ShareCreateIfNotExistsResponse>;
    /**
     * Creates a {@link ShareDirectoryClient} object.
     *
     * @param directoryName A directory name
     * @returns {ShareDirectoryClient} The ShareDirectoryClient object for the given directory name.
     * @memberof ShareClient
     */
    getDirectoryClient(directoryName: string): ShareDirectoryClient;
    readonly rootDirectoryClient: ShareDirectoryClient;
    /**
     * Creates a new subdirectory under this share.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-directory
     *
     * @param {string} directoryName
     * @param {DirectoryCreateOptions} [options] Options to Directory Create operation.
     * @returns {Promise<{ directoryClient: ShareDirectoryClient, directoryCreateResponse: DirectoryCreateResponse }>} Directory creation response data and the corresponding directory client.
     * @memberof ShareClient
     */
    createDirectory(directoryName: string, options?: DirectoryCreateOptions): Promise<{
        directoryClient: ShareDirectoryClient;
        directoryCreateResponse: DirectoryCreateResponse;
    }>;
    /**
     * Removes the specified empty sub directory under this share.
     * Note that the directory must be empty before it can be deleted.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-directory
     *
     * @param {string} directoryName
     * @param {DirectoryDeleteOptions} [options] Options to Directory Delete operation.
     * @returns {Promise<DirectoryDeleteResponse>} Directory deletion response data.
     * @memberof ShareClient
     */
    deleteDirectory(directoryName: string, options?: DirectoryDeleteOptions): Promise<DirectoryDeleteResponse>;
    /**
     * Creates a new file or replaces a file under the root directory of this share.
     * Note it only initializes the file with no content.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-file
     *
     * @param {string} fileName
     * @param {number} size Specifies the maximum size in bytes for the file, up to 1 TB.
     * @param {FileCreateOptions} [options] Options to File Create operation.
     * @returns {Promise<{ fileClient: ShareFileClient, fileCreateResponse: FileCreateResponse }>} File creation response data and the corresponding file client.
     * @memberof ShareClient
     */
    createFile(fileName: string, size: number, options?: FileCreateOptions): Promise<{
        fileClient: ShareFileClient;
        fileCreateResponse: FileCreateResponse;
    }>;
    /**
     * Removes a file under the root directory of this share from the storage account.
     * When a file is successfully deleted, it is immediately removed from the storage
     * account's index and is no longer accessible to clients. The file's data is later
     * removed from the service during garbage collection.
     *
     * Delete File will fail with status code 409 (Conflict) and error code `SharingViolation`
     * if the file is open on an SMB client.
     *
     * Delete File is not supported on a share snapshot, which is a read-only copy of
     * a share. An attempt to perform this operation on a share snapshot will fail with 400
     * (`InvalidQueryParameterValue`)
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-file2
     *
     * @param {string} directoryName
     * @param {string} fileName
     * @param {FileDeleteOptions} [options] Options to File Delete operation.
     * @returns Promise<FileDeleteResponse> File Delete response data.
     * @memberof ShareClient
     */
    deleteFile(fileName: string, options?: FileDeleteOptions): Promise<FileDeleteResponse>;
    /**
     * Returns true if the Azrue share resource represented by this client exists; false otherwise.
     *
     * NOTE: use this function with care since an existing share might be deleted by other clients or
     * applications. Vice versa new shares might be added by other clients or applications after this
     * function completes.
     *
     * @param {ShareExistsOptions} [options] options to Exists operation.
     * @returns {Promise<boolean>}
     * @memberof ShareClient
     */
    exists(options?: ShareExistsOptions): Promise<boolean>;
    /**
     * Returns all user-defined metadata and system properties for the specified
     * share.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-share-properties
     *
     * WARNING: The `metadata` object returned in the response will have its keys in lowercase, even if
     * they originally contained uppercase characters. This differs from the metadata keys returned by
     * the `listShares` method of {@link ShareServiceClient} using the `includeMetadata` option, which
     * will retain their original casing.
     *
     * @returns {Promise<ShareGetPropertiesResponse>} Response data for the Share Get Properties operation.
     * @memberof ShareClient
     */
    getProperties(options?: ShareGetPropertiesOptions): Promise<ShareGetPropertiesResponse>;
    /**
     * Marks the specified share for deletion. The share and any directories or files
     * contained within it are later deleted during garbage collection.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-share
     *
     * @param {ShareDeleteMethodOptions} [options] Options to Share Delete operation.
     * @returns {Promise<ShareDeleteResponse>} Response data for the Share Delete operation.
     * @memberof ShareClient
     */
    delete(options?: ShareDeleteMethodOptions): Promise<ShareDeleteResponse>;
    /**
     * Marks the specified share for deletion if it exists. The share and any directories or files
     * contained within it are later deleted during garbage collection.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-share
     *
     * @param {ShareDeleteMethodOptions} [options]
     * @returns {Promise<ShareDeleteIfExistsResponse>}
     * @memberof ShareClient
     */
    deleteIfExists(options?: ShareDeleteMethodOptions): Promise<ShareDeleteIfExistsResponse>;
    /**
     * Sets one or more user-defined name-value pairs for the specified share.
     *
     * If no option provided, or no metadata defined in the option parameter, the share
     * metadata will be removed.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-share-metadata
     *
     * @param {Metadata} [metadata] If no metadata provided, all existing directory metadata will be removed.
     * @param {ShareSetMetadataOptions} [option] Options to Share Set Metadata operation.
     * @returns {Promise<ShareSetMetadataResponse>} Response data for the Share Set Metadata operation.
     * @memberof ShareClient
     */
    setMetadata(metadata?: Metadata, options?: ShareSetMetadataOptions): Promise<ShareSetMetadataResponse>;
    /**
     * Gets the permissions for the specified share. The permissions indicate
     * whether share data may be accessed publicly.
     *
     * WARNING: JavaScript Date will potential lost precision when parsing start and expiry string.
     * For example, new Date("2018-12-31T03:44:23.8827891Z").toISOString() will get "2018-12-31T03:44:23.882Z".
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-share-acl
     *
     * @param {ShareGetAccessPolicyOptions} [option] Options to Share Get Access Policy operation.
     * @returns {Promise<ShareGetAccessPolicyResponse>} Response data for the Share Get Access Policy operation.
     * @memberof ShareClient
     */
    getAccessPolicy(options?: ShareGetAccessPolicyOptions): Promise<ShareGetAccessPolicyResponse>;
    /**
     * Sets the permissions for the specified share. The permissions indicate
     * whether directories or files in a share may be accessed publicly.
     *
     * When you set permissions for a share, the existing permissions are replaced.
     * If no shareAcl provided, the existing share ACL will be
     * removed.
     *
     * When you establish a stored access policy on a share, it may take up to 30 seconds to take effect.
     * During this interval, a shared access signature that is associated with the stored access policy will
     * fail with status code 403 (Forbidden), until the access policy becomes active.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-share-acl
     *
     * @param {SignedIdentifier[]} [shareAcl] Array of signed identifiers, each having a unique Id and details of access policy.
     * @param {ShareSetAccessPolicyOptions} [option] Options to Share Set Access Policy operation.
     * @returns {Promise<ShareSetAccessPolicyResponse>} Response data for the Share Set Access Policy operation.
     * @memberof ShareClient
     */
    setAccessPolicy(shareAcl?: SignedIdentifier[], options?: ShareSetAccessPolicyOptions): Promise<ShareSetAccessPolicyResponse>;
    /**
     * Creates a read-only snapshot of a share.
     *
     * @param {ShareCreateSnapshotOptions} [options={}] Options to Share Create Snapshot operation.
     * @returns {Promise<ShareCreateSnapshotResponse>} Response data for the Share Create Snapshot operation.
     * @memberof ShareClient
     */
    createSnapshot(options?: ShareCreateSnapshotOptions): Promise<ShareCreateSnapshotResponse>;
    /**
     * Sets quota for the specified share.
     *
     * @param {number} quotaInGB Specifies the maximum size of the share in gigabytes
     * @param {ShareSetQuotaOptions} [option] Options to Share Set Quota operation.
     * @returns {Promise<ShareSetQuotaResponse>} Response data for the Share Get Quota operation.
     * @memberof ShareClient
     */
    setQuota(quotaInGB: number, options?: ShareSetQuotaOptions): Promise<ShareSetQuotaResponse>;
    /**
     * Retrieves statistics related to the share.
     *
     * @param {ShareGetStatisticsOptions} [option] Options to Share Get Statistics operation.
     * @returns {Promise<ShareGetStatisticsResponse>} Response data for the Share Get Statistics operation.
     * @memberof ShareClient
     */
    getStatistics(options?: ShareGetStatisticsOptions): Promise<ShareGetStatisticsResponse>;
    /**
     * Creates a file permission (a security descriptor) at the share level.
     * The created security descriptor can be used for the files/directories in the share.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-permission
     *
     * @param {ShareCreatePermissionOptions} [options] Options to Share Create Permission operation.
     * @param filePermission File permission described in the SDDL
     */
    createPermission(filePermission: string, options?: ShareCreatePermissionOptions): Promise<ShareCreatePermissionResponse>;
    /**
     * Gets the Security Descriptor Definition Language (SDDL) for a given file permission key
     * which indicates a security descriptor.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-permission
     *
     * @param {ShareGetPermissionOptions} [options] Options to Share Create Permission operation.
     * @param filePermissionKey File permission key which indicates the security descriptor of the permission.
     */
    getPermission(filePermissionKey: string, options?: ShareGetPermissionOptions): Promise<ShareGetPermissionResponse>;
}
/**
 * Defines headers for Create operation.
 */
export declare interface ShareCreateHeaders {
    /**
     * The ETag contains a value which represents the version of the share, in quotes.
     */
    etag?: string;
    /**
     * Returns the date and time the share was last modified. Any operation that modifies the share
     * or its properties or metadata updates the last modified time. Operations on files do not
     * affect the last modified time of the share.
     */
    lastModified?: Date;
    /**
     * This header uniquely identifies the request that was made and can be used for troubleshooting
     * the request.
     */
    requestId?: string;
    /**
     * Indicates the version of the File service used to execute the request.
     */
    version?: string;
    /**
     * A UTC date/time value generated by the service that indicates the time at which the response
     * was initiated.
     */
    date?: Date;
    errorCode?: string;
}
/**
 * Contains response data for the {@link ShareClient.createIfNotExists} operation.
 *
 * @export
 * @interface ShareCreateIfNotExistsResponse
 */
export declare interface ShareCreateIfNotExistsResponse extends ShareCreateResponse {
    /**
     * Indicate whether the share is successfully created. Is false when the share is not changed as it already exists.
     *
     * @type {boolean}
     * @memberof ShareCreateIfNotExistsResponse
     */
    succeeded: boolean;
}
/**
 * Options to configure the {@link ShareClient.create} operation.
 *
 * @export
 * @interface ShareCreateOptions
 */
export declare interface ShareCreateOptions extends CommonOptions {
    /**
     * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.
     * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.
     *
     * @type {AbortSignalLike}
     * @memberof ShareCreateOptions
     */
    abortSignal?: AbortSignalLike;
    /**
     * A name-value pair to associate with a file storage object.
     *
     * @type {{ [propertyName: string]: string }}
     * @memberof ShareCreateOptions
     */
    metadata?: {
        [propertyName: string]: string;
    };
    /**
     * Specifies the maximum size of the share, in
     * gigabytes.
     *
     * @type {number}
     * @memberof ShareCreateOptions
     */
    quota?: number;
}
/**
 * Defines headers for CreatePermission operation.
 */
export declare interface ShareCreatePermissionHeaders {
    /**
     * This header uniquely identifies the request that was made and can be used for troubleshooting
     * the request.
     */
    requestId?: string;
    /**
     * Indicates the version of the File service used to execute the request.
     */
    version?: string;
    /**
     * A UTC date/time value generated by the service that indicates the time at which the response
     * was initiated.
     */
    date?: Date;
    /**
     * Key of the permission set for the directory/file.
     */
    filePermissionKey?: string;
    errorCode?: string;
}
/**
 * Options to configure the {@link ShareClient.createPermission} operation.
 *
 * @export
 * @interface ShareCreatePermissionOptions
 */
export declare interface ShareCreatePermissionOptions extends CommonOptions {
    /**
     * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.
     * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.
     *
     * @type {AbortSignalLike}
     * @memberof ShareCreatePermissionOptions
     */
    abortSignal?: AbortSignalLike;
}
/**
 * Contains response data for the createPermission operation.
 */
export declare type ShareCreatePermissionResponse = ShareCreatePermissionHeaders & {
    /**
     * The underlying HTTP response.
     */
    _response: coreHttp.HttpResponse & {
        /**
         * The parsed HTTP response headers.
         */
        parsedHeaders: ShareCreatePermissionHeaders;
    };
};
/**
 * Contains response data for the create operation.
 */
export declare type ShareCreateResponse = ShareCreateHeaders & {
    /**
     * The underlying HTTP response.
     */
    _response: coreHttp.HttpResponse & {
        /**
         * The parsed HTTP response headers.
         */
        parsedHeaders: ShareCreateHeaders;
    };
};
/**
 * Defines headers for CreateSnapshot operation.
 */
export declare interface ShareCreateSnapshotHeaders {
    /**
     * This header is a DateTime value that uniquely identifies the share snapshot. The value of this
     * header may be used in subsequent requests to access the share snapshot. This value is opaque.
     */
    snapshot?: string;
    /**
     * The ETag contains a value which represents the version of the share snapshot, in quotes. A
     * share snapshot cannot be modified, so the ETag of a given share snapshot never changes.
     * However, if new metadata was supplied with the Snapshot Share request then the ETag of the
     * share snapshot differs from that of the base share. If no metadata was specified with the
     * request, the ETag of the share snapshot is identical to that of the base share at the time the
     * share snapshot was taken.
     */
    etag?: string;
    /**
     * Returns the date and time the share was last modified. A share snapshot cannot be modified, so
     * the last modified time of a given share snapshot never changes. However, if new metadata was
     * supplied with the Snapshot Share request then the last modified time of the share snapshot
     * differs from that of the base share. If no metadata was specified with the request, the last
     * modified time of the share snapshot is identical to that of the base share at the time the
     * share snapshot was taken.
     */
    lastModified?: Date;
    /**
     * This header uniquely identifies the request that was made and can be used for troubleshooting
     * the request.
     */
    requestId?: string;
    /**
     * Indicates the version of the File service used to execute the request.
     */
    version?: string;
    /**
     * A UTC date/time value generated by the service that indicates the time at which the response
     * was initiated.
     */
    date?: Date;
    errorCode?: string;
}
/**
 * Options to configure the {@link ShareClient.createSnapshot} operation.
 *
 * @export
 * @interface ShareCreateSnapshotOptions
 */
export declare interface ShareCreateSnapshotOptions extends CommonOptions {
    /**
     * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.
     * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.
     *
     * @type {AbortSignalLike}
     * @memberof ShareCreateSnapshotOptions
     */
    abortSignal?: AbortSignalLike;
    /**
     * A name-value pair to associate with a file storage object.
     *
     * @type {{ [propertyName: string]: string }}
     * @memberof ShareCreateOptions
     */
    metadata?: {
        [propertyName: string]: string;
    };
}
/**
 * Contains response data for the createSnapshot operation.
 */
export declare type ShareCreateSnapshotResponse = ShareCreateSnapshotHeaders & {
    /**
     * The underlying HTTP response.
     */
    _response: coreHttp.HttpResponse & {
        /**
         * The parsed HTTP response headers.
         */
        parsedHeaders: ShareCreateSnapshotHeaders;
    };
};
/**
 * Defines headers for Delete operation.
 */
export declare interface ShareDeleteHeaders {
    /**
     * This header uniquely identifies the request that was made and can be used for troubleshooting
     * the request.
     */
    requestId?: string;
    /**
     * Indicates the version of the File service used to execute the request.
     */
    version?: string;
    /**
     * A UTC date/time value generated by the service that indicates the time at which the response
     * was initiated.
     */
    date?: Date;
    errorCode?: string;
}
/**
 * Contains response data for the {@link ShareClient.deleteIfExists} operation.
 *
 * @export
 * @interface ShareDeleteIfExistsResponse
 */
export declare interface ShareDeleteIfExistsResponse extends ShareDeleteResponse {
    /**
     * Indicate whether the share is successfully deleted. Is false if the share does not exist in the first place.
     *
     * @type {boolean}
     * @memberof ShareDeleteIfExistsResponse
     */
    succeeded: boolean;
}
/**
 * Options to configure the {@link ShareClient.delete} operation.
 *
 * @export
 * @interface ShareDeleteMethodOptions
 */
export declare interface ShareDeleteMethodOptions extends CommonOptions {
    /**
     * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.
     * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.
     *
     * @type {AbortSignalLike}
     * @memberof ShareDeleteMethodOptions
     */
    abortSignal?: AbortSignalLike;
    /**
     * Specifies the option
     * include to delete the base share and all of its snapshots. Possible values
     * include: 'include'
     *
     * @type {DeleteSnapshotsOptionType}
     * @memberof ShareDeleteMethodOptions
     */
    deleteSnapshots?: DeleteSnapshotsOptionType;
}
/**
 * Contains response data for the deleteMethod operation.
 */
export declare type ShareDeleteResponse = ShareDeleteHeaders & {
    /**
     * The underlying HTTP response.
     */
    _response: coreHttp.HttpResponse & {
        /**
         * The parsed HTTP response headers.
         */
        parsedHeaders: ShareDeleteHeaders;
    };
};
/**
 * A ShareDirectoryClient represents a URL to the Azure Storage directory allowing you to manipulate its files and directories.
 *
 * @export
 * @class ShareDirectoryClient
 */
export declare class ShareDirectoryClient extends StorageClient {
    /**
     * context provided by protocol layer.
     *
     * @private
     * @type {Directory}
     * @memberof ShareDirectoryClient
     */
    private context;
    private _shareName;
    private _path;
    private _name;
    readonly shareName: string;
    readonly path: string;
    readonly name: string;
    /**
     * Creates an instance of DirectoryClient.
     *
     * @param {string} url A URL string pointing to Azure Storage file directory, such as
     *                     "https://myaccount.file.core.windows.net/myshare/mydirectory". You can
     *                     append a SAS if using AnonymousCredential, such as
     *                     "https://myaccount.file.core.windows.net/myshare/mydirectory?sasString".
     *                     This method accepts an encoded URL or non-encoded URL pointing to a directory.
     *                     Encoded URL string will NOT be escaped twice, only special characters in URL path will be escaped.
     *                     However, if a directory name includes %, directory name must be encoded in the URL.
     *                     Such as a directory named "mydir%", the URL should be "https://myaccount.file.core.windows.net/myshare/mydir%25".
     * @param {Credential} [credential] Such as AnonymousCredential or StorageSharedKeyCredential.
     *                                  If not specified, AnonymousCredential is used.
     * @param {StoragePipelineOptions} [options] Optional. Options to configure the HTTP pipeline.
     * @memberof ShareDirectoryClient
     */
    constructor(url: string, credential?: Credential, options?: StoragePipelineOptions);
    /**
     * Creates an instance of DirectoryClient.
     *
     * @param {string} url A URL string pointing to Azure Storage file directory, such as
     *                     "https://myaccount.file.core.windows.net/myshare/mydirectory". You can
     *                     append a SAS if using AnonymousCredential, such as
     *                     "https://myaccount.file.core.windows.net/myshare/mydirectory?sasString".
     *                     This method accepts an encoded URL or non-encoded URL pointing to a directory.
     *                     Encoded URL string will NOT be escaped twice, only special characters in URL path will be escaped.
     *                     However, if a directory name includes %, directory name must be encoded in the URL.
     *                     Such as a directory named "mydir%", the URL should be "https://myaccount.file.core.windows.net/myshare/mydir%25".
     * @param {Pipeline} pipeline Call newPipeline() to create a default
     *                            pipeline, or provide a customized pipeline.
     * @memberof ShareDirectoryClient
     */
    constructor(url: string, pipeline: Pipeline);
    /**
     * Creates a new directory under the specified share or parent directory.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-directory
     *
     * @param {DirectoryCreateOptions} [options] Options to Directory Create operation.
     * @returns {Promise<DirectoryCreateResponse>} Response data for the Directory  operation.
     * @memberof ShareDirectoryClient
     */
    create(options?: DirectoryCreateOptions): Promise<DirectoryCreateResponse>;
    /**
     * Creates a new directory under the specified share or parent directory if it does not already exists.
     * If the directory already exists, it is not modified.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-directory
     *
     * @param {DirectoryCreateOptions} [options]
     * @returns {Promise<DirectoryCreateIfNotExistsResponse>}
     * @memberof ShareDirectoryClient
     */
    createIfNotExists(options?: DirectoryCreateOptions): Promise<DirectoryCreateIfNotExistsResponse>;
    /**
     * Sets properties on the directory.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-directory-properties
     *
     * @param {properties} [DirectoryProperties] Directory properties. If no values are provided,
     *                                            existing values will be preserved.
     * @returns {Promise<DirectorySetPropertiesResponse>}
     * @memberof ShareDirectoryClient
     */
    setProperties(properties?: DirectoryProperties): Promise<DirectorySetPropertiesResponse>;
    /**
     * Creates a ShareDirectoryClient object for a sub directory.
     *
     * @param subDirectoryName A subdirectory name
     * @returns {ShareDirectoryClient} The ShareDirectoryClient object for the given subdirectory name.
     * @memberof ShareDirectoryClient
     *
     * Example usage:
     *
     * ```js
     * const directoryClient = shareClient.getDirectoryClient("<directory name>");
     * await directoryClient.create();
     * console.log("Created directory successfully");
     * ```
     */
    getDirectoryClient(subDirectoryName: string): ShareDirectoryClient;
    /**
     * Creates a new subdirectory under this directory.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-directory
     *
     * @param {string} directoryName
     * @param {DirectoryCreateOptions} [options] Options to Directory Create operation.
     * @returns {Promise<{ directoryClient: ShareDirectoryClient; directoryCreateResponse: DirectoryCreateResponse; }>} Directory create response data and the corresponding DirectoryClient instance.
     * @memberof ShareDirectoryClient
     */
    createSubdirectory(directoryName: string, options?: DirectoryCreateOptions): Promise<{
        directoryClient: ShareDirectoryClient;
        directoryCreateResponse: DirectoryCreateResponse;
    }>;
    /**
     * Removes the specified empty sub directory under this directory.
     * Note that the directory must be empty before it can be deleted.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-directory
     *
     * @param {string} directoryName
     * @param {DirectoryDeleteOptions} [options] Options to Directory Delete operation.
     * @returns {DirectoryDeleteResponse} Directory deletion response data.
     * @memberof ShareDirectoryClient
     */
    deleteSubdirectory(directoryName: string, options?: DirectoryDeleteOptions): Promise<DirectoryDeleteResponse>;
    /**
     * Creates a new file or replaces a file under this directory. Note it only initializes the file with no content.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-file
     *
     * @param {string} fileName
     * @param {number} size Specifies the maximum size in bytes for the file, up to 1 TB.
     * @param {FileCreateOptions} [options] Options to File Create operation.
     * @returns {Promise<{ fileClient: ShareFileClient, fileCreateResponse: FileCreateResponse }>} File creation response data and the corresponding file client.
     * @memberof ShareDirectoryClient
     */
    createFile(fileName: string, size: number, options?: FileCreateOptions): Promise<{
        fileClient: ShareFileClient;
        fileCreateResponse: FileCreateResponse;
    }>;
    /**
     * Removes the specified file under this directory from the storage account.
     * When a file is successfully deleted, it is immediately removed from the storage
     * account's index and is no longer accessible to clients. The file's data is later
     * removed from the service during garbage collection.
     *
     * Delete File will fail with status code 409 (Conflict) and error code SharingViolation
     * if the file is open on an SMB client.
     *
     * Delete File is not supported on a share snapshot, which is a read-only copy of
     * a share. An attempt to perform this operation on a share snapshot will fail with 400 (InvalidQueryParameterValue)
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-file2
     *
     * @param {string} fileName Name of the file to delete
     * @param {FileDeleteOptions} [options] Options to File Delete operation.
     * @returns {Promise<FileDeleteResponse>} File deletion response data.
     * @memberof ShareDirectoryClient
     */
    deleteFile(fileName: string, options?: FileDeleteOptions): Promise<FileDeleteResponse>;
    /**
     * Creates a {@link ShareFileClient} object.
     *
     * @param {string} fileName A file name.
     * @returns {ShareFileClient} A new ShareFileClient object for the given file name.
     * @memberof ShareFileClient
     *
     * Example usage:
     *
     * ```js
     * const content = "Hello world!"
     *
     * const fileClient = directoryClient.getFileClient("<file name>");
     *
     * await fileClient.create(content.length);
     * console.log("Created file successfully!");
     *
     * await fileClient.uploadRange(content, 0, content.length);
     * console.log("Updated file successfully!")
     * ```
     */
    getFileClient(fileName: string): ShareFileClient;
    /**
     * Returns true if the specified directory exists; false otherwise.
     *
     * NOTE: use this function with care since an existing directory might be deleted by other clients or
     * applications. Vice versa new directories might be added by other clients or applications after this
     * function completes.
     *
     * @param {DirectoryExistsOptions} [options] options to Exists operation.
     * @returns {Promise<boolean>}
     * @memberof ShareDirectoryClient
     */
    exists(options?: DirectoryExistsOptions): Promise<boolean>;
    /**
     * Returns all system properties for the specified directory, and can also be used to check the
     * existence of a directory. The data returned does not include the files in the directory or any
     * subdirectories.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-directory-properties
     *
     * @param {DirectoryGetPropertiesOptions} [options] Options to Directory Get Properties operation.
     * @returns {Promise<DirectoryGetPropertiesResponse>} Response data for the Directory Get Properties operation.
     * @memberof ShareDirectoryClient
     */
    getProperties(options?: DirectoryGetPropertiesOptions): Promise<DirectoryGetPropertiesResponse>;
    /**
     * Removes the specified empty directory. Note that the directory must be empty before it can be
     * deleted.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-directory
     *
     * @param {DirectoryDeleteOptions} [options] Options to Directory Delete operation.
     * @returns {Promise<DirectoryDeleteResponse>} Response data for the Directory Delete operation.
     * @memberof ShareDirectoryClient
     */
    delete(options?: DirectoryDeleteOptions): Promise<DirectoryDeleteResponse>;
    /**
     * Removes the specified empty directory if it exists. Note that the directory must be empty before it can be
     * deleted.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-directory
     *
     * @param {DirectoryDeleteOptions} [options]
     * @returns {Promise<DirectoryDeleteIfExistsResponse>}
     * @memberof ShareDirectoryClient
     */
    deleteIfExists(options?: DirectoryDeleteOptions): Promise<DirectoryDeleteIfExistsResponse>;
    /**
     * Updates user defined metadata for the specified directory.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-directory-metadata
     *
     * @param {Metadata} [metadata] If no metadata provided, all existing directory metadata will be removed
     * @param {DirectorySetMetadataOptions} [options] Options to Directory Set Metadata operation.
     * @returns {Promise<DirectorySetMetadataResponse>} Response data for the Directory Set Metadata operation.
     * @memberof ShareDirectoryClient
     */
    setMetadata(metadata?: Metadata, options?: DirectorySetMetadataOptions): Promise<DirectorySetMetadataResponse>;
    /**
     * Returns an AsyncIterableIterator for {@link DirectoryListFilesAndDirectoriesSegmentResponse} objects
     *
     * @private
     * @param {string} [marker] A string value that identifies the portion of
     *                          the list of files and directories to be returned with the next listing operation. The
     *                          operation returns the ContinuationToken value within the response body if the
     *                          listing operation did not return all files and directories remaining to be listed
     *                          with the current page. The ContinuationToken value can be used as the value for
     *                          the marker parameter in a subsequent call to request the next page of list
     *                          items. The marker value is opaque to the client.
     * @param {DirectoryListFilesAndDirectoriesSegmentOptions} [options] Options to list files and directories operation.
     * @returns {AsyncIterableIterator<DirectoryListFilesAndDirectoriesSegmentResponse>}
     * @memberof ShareDirectoryClient
     */
    private iterateFilesAndDirectoriesSegments;
    /**
     * Returns an AsyncIterableIterator for file and directory items
     *
     * @private
     * @param {DirectoryListFilesAndDirectoriesSegmentOptions} [options] Options to list files and directories operation.
     * @returns {AsyncIterableIterator<{ kind: "file" } & FileItem | { kind: "directory" } & DirectoryItem>}
     * @memberof ShareDirectoryClient
     */
    private listFilesAndDirectoriesItems;
    /**
     * Returns an async iterable iterator to list all the files and directories
     * under the specified account.
     *
     * .byPage() returns an async iterable iterator to list the files and directories in pages.
     *
     * Example using `for await` syntax:
     *
     * ```js
     * let i = 1;
     * for await (const entity of directoryClient.listFilesAndDirectories()) {
     *   if (entity.kind === "directory") {
     *     console.log(`${i++} - directory\t: ${entity.name}`);
     *   } else {
     *     console.log(`${i++} - file\t: ${entity.name}`);
     *   }
     * }
     * ```
     *
     * Example using `iter.next()`:
     *
     * ```js
     * let i = 1;
     * let iter = directoryClient.listFilesAndDirectories();
     * let entity = await iter.next();
     * while (!entity.done) {
     *   if (entity.value.kind === "directory") {
     *     console.log(`${i++} - directory\t: ${entity.value.name}`);
     *   } else {
     *     console.log(`${i++} - file\t: ${entity.value.name}`);
     *   }
     *   entity = await iter.next();
     * }
     * ```
     *
     * Example using `byPage()`:
     *
     * ```js
     * // passing optional maxPageSize in the page settings
     * let i = 1;
     * for await (const response of directoryClient
     *   .listFilesAndDirectories()
     *   .byPage({ maxPageSize: 20 })) {
     *   for (const fileItem of response.segment.fileItems) {
     *     console.log(`${i++} - file\t: ${fileItem.name}`);
     *   }
     *   for (const dirItem of response.segment.directoryItems) {
     *     console.log(`${i++} - directory\t: ${dirItem.name}`);
     *   }
     * }
     * ```
     *
     * Example using paging with a marker:
     *
     * ```js
     * let i = 1;
     * let iterator = directoryClient.listFilesAndDirectories().byPage({ maxPageSize: 3 });
     * let response = (await iterator.next()).value;
     *
     * // Prints 3 file and directory names
     * for (const fileItem of response.segment.fileItems) {
     *   console.log(`${i++} - file\t: ${fileItem.name}`);
     * }
     *
     * for (const dirItem of response.segment.directoryItems) {
     *   console.log(`${i++} - directory\t: ${dirItem.name}`);
     * }
     *
     * // Gets next marker
     * let dirMarker = response.continuationToken;
     *
     * // Passing next marker as continuationToken
     * iterator = directoryClient
     *   .listFilesAndDirectories()
     *   .byPage({ continuationToken: dirMarker, maxPageSize: 4 });
     * response = (await iterator.next()).value;
     *
     * // Prints 10 file and directory names
     * for (const fileItem of response.segment.fileItems) {
     *   console.log(`${i++} - file\t: ${fileItem.name}`);
     * }
     *
     * for (const dirItem of response.segment.directoryItems) {
     *   console.log(`${i++} - directory\t: ${dirItem.name}`);
     * }
     * ```
     *
     * @param {DirectoryListFilesAndDirectoriesOptions} [options] Options to list files and directories operation.
     * @memberof ShareDirectoryClient
     * @returns {PagedAsyncIterableIterator<{ kind: "file" } & FileItem | { kind: "directory" } , DirectoryListFilesAndDirectoriesSegmentResponse>}
     * An asyncIterableIterator that supports paging.
     */
    listFilesAndDirectories(options?: DirectoryListFilesAndDirectoriesOptions): PagedAsyncIterableIterator<({
        kind: "file";
    } & FileItem) | ({
        kind: "directory";
    } & DirectoryItem), DirectoryListFilesAndDirectoriesSegmentResponse>;
    /**
     * Returns a list of files or directories under the specified share or directory. It lists the
     * contents only for a single level of the directory hierarchy.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/list-directories-and-files
     *
     * @param {string} [marker] A string value that identifies the portion of the list to be returned with the next list operation.
     * @param {DirectoryListFilesAndDirectoriesSegmentOptions} [options] Options to Directory List Files and Directories Segment operation.
     * @returns {Promise<DirectoryListFilesAndDirectoriesSegmentResponse>} Response data for the Directory List Files and Directories operation.
     * @memberof ShareDirectoryClient
     */
    private listFilesAndDirectoriesSegment;
    /**
     * Returns an AsyncIterableIterator for {@link DirectoryListHandlesResponse}
     *
     * @private
     * @param {string} [marker] A string value that identifies the portion of the list to be
     *                          returned with the next list handles operation. The operation returns a
     *                          marker value within the response body if the list returned was not complete.
     *                          The marker value may then be used in a subsequent call to request the next
     *                          set of list items.
     * @param {DirectoryListHandlesSegmentOptions} [options] Options to list handles operation.
     * @returns {AsyncIterableIterator<DirectoryListHandlesResponse>}
     * @memberof ShareDirectoryClient
     */
    private iterateHandleSegments;
    /**
     * Returns an AsyncIterableIterator for handles
     *
     * @private
     * @param {DirectoryListHandlesSegmentOptions} [options] Options to list handles operation.
     * @returns {AsyncIterableIterator<HandleItem>}
     * @memberof ShareDirectoryClient
     */
    private listHandleItems;
    /**
     * Returns an async iterable iterator to list all the handles.
     * under the specified account.
     *
     * .byPage() returns an async iterable iterator to list the handles in pages.
     *
     * Example using `for await` syntax:
     *
     * ```js
     * let i = 1;
     * let iter = dirClient.listHandles();
     * for await (const handle of iter) {
     *   console.log(`Handle ${i++}: ${handle.path}, opened time ${handle.openTime}, clientIp ${handle.clientIp}`);
     * }
     * ```
     *
     * Example using `iter.next()`:
     *
     * ```js
     * let i = 1;
     * let iter = dirClient.listHandles();
     * let handleItem = await iter.next();
     * while (!handleItem.done) {
     *   console.log(`Handle ${i++}: ${handleItem.value.path}, opened time ${handleItem.value.openTime}, clientIp ${handleItem.value.clientIp}`);
     *   handleItem = await iter.next();
     * }
     * ```
     *
     * Example using `byPage()`:
     *
     * ```js
     * // passing optional maxPageSize in the page settings
     * let i = 1;
     * for await (const response of dirClient.listHandles({ recursive: true }).byPage({ maxPageSize: 20 })) {
     *   if (response.handleList) {
     *     for (const handle of response.handleList) {
     *       console.log(`Handle ${i++}: ${handle.path}, opened time ${handle.openTime}, clientIp ${handle.clientIp}`);
     *     }
     *   }
     * }
     * ```
     *
     * Example using paging with a marker:
     *
     * ```js
     * let i = 1;
     * let iterator = dirClient.listHandles().byPage({ maxPageSize: 2 });
     * let response = await iterator.next();
     *
     * // Prints 2 handles
     * if (response.value.handleList) {
     *   for (const handle of response.value.handleList) {
     *     console.log(`Handle ${i++}: ${handle.path}, opened time ${handle.openTime}, clientIp ${handle.clientIp}`);
     *   }
     * }
     *
     * // Gets next marker
     * let marker = response.value.continuationToken;
     *
     * // Passing next marker as continuationToken
     * console.log(`    continuation`);
     * iterator = dirClient.listHandles().byPage({ continuationToken: marker, maxPageSize: 10 });
     * response = await iterator.next();
     *
     * // Prints 2 more handles assuming you have more than four directory/files opened
     * if (!response.done && response.value.handleList) {
     *   for (const handle of response.value.handleList) {
     *     console.log(`Handle ${i++}: ${handle.path}, opened time ${handle.openTime}, clientIp ${handle.clientIp}`);
     *   }
     * }
     * ```
     *
     * @param {DirectoryListHandlesOptions} [options] Options to list handles operation.
     * @memberof ShareDirectoryClient
     * @returns {PagedAsyncIterableIterator<HandleItem, DirectoryListHandlesResponse>}
     * An asyncIterableIterator that supports paging.
     */
    listHandles(options?: DirectoryListHandlesOptions): PagedAsyncIterableIterator<HandleItem, DirectoryListHandlesResponse>;
    /**
     * Lists handles for a directory.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/list-handles
     *
     * @param {string} [marker] Optional. A string value that identifies the portion of the list to be
     *                          returned with the next list handles operation. The operation returns a
     *                          marker value within the response body if the list returned was not complete.
     *                          The marker value may then be used in a subsequent call to request the next
     *                          set of list items.
     * @param {DirectoryListHandlesSegmentOptions} [options={}]
     * @returns {Promise<DirectoryListHandlesResponse>}
     * @memberof ShareDirectoryClient
     */
    private listHandlesSegment;
    /**
     * Force close all handles for a directory.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/force-close-handles
     *
     * @param {string} [marker] Optional. A string value that identifies the position of handles that will
     *                          be closed with the next force close handles operation.
     *                          The operation returns a marker value within the response
     *                          body if there are more handles to close. The marker value
     *                          may then be used in a subsequent call to close the next set of handles.
     * @param {DirectoryForceCloseHandlesSegmentOptions} [options={}]
     * @returns {Promise<DirectoryForceCloseHandlesResponse>}
     * @memberof ShareDirectoryClient
     */
    private forceCloseHandlesSegment;
    /**
     * Force close all handles for a directory.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/force-close-handles
     *
     * @param {DirectoryForceCloseHandlesSegmentOptions} [options={}]
     * @returns {Promise<CloseHandlesInfo>}
     * @memberof ShareDirectoryClient
     */
    forceCloseAllHandles(options?: DirectoryForceCloseHandlesSegmentOptions): Promise<CloseHandlesInfo>;
    /**
     * Force close a specific handle for a directory.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/force-close-handles
     *
     * @param {Aborter} aborter Create a new Aborter instance with Aborter.none or Aborter.timeout(),
     *                          goto documents of Aborter for more examples about request cancellation
     * @param {string} handleId Specific handle ID, cannot be asterisk "*".
     *                          Use forceCloseHandlesSegment() to close all handles.
     * @param {DirectoryForceCloseHandlesOptions} [options={}]
     * @returns {Promise<DirectoryForceCloseHandlesResponse>}
     * @memberof ShareDirectoryClient
     */
    forceCloseHandle(handleId: string, options?: DirectoryForceCloseHandlesOptions): Promise<DirectoryForceCloseHandlesResponse>;
}
/**
 * Options to configure the {@link ShareClient.exists} operation.
 *
 * @export
 * @interface ShareExistsOptions
 */
export declare interface ShareExistsOptions extends CommonOptions {
    /**
     * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.
     * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.
     *
     * @type {AbortSignalLike}
     * @memberof ShareExistsOptions
     */
    abortSignal?: AbortSignalLike;
}
/**
 * A ShareFileClient represents a URL to an Azure Storage file.
 *
 * @export
 * @class ShareFileClient
 */
export declare class ShareFileClient extends StorageClient {
    /**
     * context provided by protocol layer.
     *
     * @private
     * @type {File}
     * @memberof ShareFileClient
     */
    private context;
    private _shareName;
    private _path;
    private _name;
    readonly shareName: string;
    readonly path: string;
    readonly name: string;
    /**
     * Creates an instance of ShareFileClient.
     *
     * @param {string} url A URL string pointing to Azure Storage file, such as
     *                     "https://myaccount.file.core.windows.net/myshare/mydirectory/file". You can
     *                     append a SAS if using AnonymousCredential, such as
     *                     "https://myaccount.file.core.windows.net/myshare/mydirectory/file?sasString".
     *                     This method accepts an encoded URL or non-encoded URL pointing to a file.
     *                     Encoded URL string will NOT be escaped twice, only special characters in URL path will be escaped.
     *                     However, if a file or directory name includes %, file or directory name must be encoded in the URL.
     *                     Such as a file named "myfile%", the URL should be "https://myaccount.file.core.windows.net/myshare/mydirectory/myfile%25".
     * @param {Credential} [credential] Such as AnonymousCredential or StorageSharedKeyCredential.
     *                                  If not specified, AnonymousCredential is used.
     * @param {StoragePipelineOptions} [options] Optional. Options to configure the HTTP pipeline.
     * @memberof ShareFileClient
     */
    constructor(url: string, credential?: Credential, options?: StoragePipelineOptions);
    /**
     * Creates an instance of ShareFileClient.
     *
     * @param {string} url A URL string pointing to Azure Storage file, such as
     *                     "https://myaccount.file.core.windows.net/myshare/mydirectory/file". You can
     *                     append a SAS if using AnonymousCredential, such as
     *                     "https://myaccount.file.core.windows.net/myshare/mydirectory/file?sasString".
     *                     This method accepts an encoded URL or non-encoded URL pointing to a file.
     *                     Encoded URL string will NOT be escaped twice, only special characters in URL path will be escaped.
     *                     However, if a file or directory name includes %, file or directory name must be encoded in the URL.
     *                     Such as a file named "myfile%", the URL should be "https://myaccount.file.core.windows.net/myshare/mydirectory/myfile%25".
     * @param {Pipeline} pipeline Call newPipeline() to create a default
     *                            pipeline, or provide a customized pipeline.
     * @memberof ShareFileClient
     */
    constructor(url: string, pipeline: Pipeline);
    /**
     * Creates a new file or replaces a file. Note it only initializes the file with no content.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-file
     *
     * @param {number} size Specifies the maximum size in bytes for the file, up to 1 TB.
     * @param {FileCreateOptions} [options] Options to File Create operation.
     * @returns {Promise<FileCreateResponse>} Response data for the File Create  operation.
     * @memberof ShareFileClient
     *
     * Example usage:
     *
     * ```js
     * const content = "Hello world!";
     *
     * // Create the file
     * await fileClient.create(content.length);
     * console.log("Created file successfully!");
     *
     * // Then upload data to the file
     * await fileClient.uploadRange(content, 0, content.length);
     * console.log("Updated file successfully!")
     * ```
     */
    create(size: number, options?: FileCreateOptions): Promise<FileCreateResponse>;
    /**
     * Reads or downloads a file from the system, including its metadata and properties.
     *
     * * In Node.js, data returns in a Readable stream `readableStreamBody`
     * * In browsers, data returns in a promise `contentAsBlob`
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-file
     *
     * @param {number} [offset] From which position of the file to download, >= 0
     * @param {number} [count] How much data to be downloaded, > 0. Will download to the end when undefined
     * @param {FileDownloadOptions} [options] Options to File Download operation.
     * @returns {Promise<FileDownloadResponse>} Response data for the File Download operation.
     * @memberof ShareFileClient
     *
     * Example usage (Node.js):
     *
     * ```js
     * // Download a file to a string
     * const downloadFileResponse = await fileClient.download();
     * console.log(
     *   "Downloaded file content:",
     *   (await streamToBuffer(downloadFileResponse.readableStreamBody)).toString()}
     * );
     *
     * // A helper method used to read a Node.js readable stream into string
     * async function streamToBuffer(readableStream) {
     *   return new Promise((resolve, reject) => {
     *     const chunks = [];
     *     readableStream.on("data", (data) => {
     *       chunks.push(data instanceof Buffer ? data : Buffer.from(data));
     *     });
     *     readableStream.on("end", () => {
     *       resolve(Buffer.concat(chunks));
     *     });
     *     readableStream.on("error", reject);
     *   });
     * }
     * ```
     *
     * Example usage (browsers):
     *
     * ```js
     * // Download a file to a string
     * const downloadFileResponse = await fileClient.download(0);
     * console.log(
     *   "Downloaded file content:",
     *   await blobToString(await downloadFileResponse.blobBody)}
     * );
     *
     * // A helper method used to convert a browser Blob into string.
     * export async function blobToString(blob: Blob): Promise<string> {
     *   const fileReader = new FileReader();
     *   return new Promise<string>((resolve, reject) => {
     *     fileReader.onloadend = (ev: any) => {
     *       resolve(ev.target!.result);
     *     };
     *     fileReader.onerror = reject;
     *     fileReader.readAsText(blob);
     *   });
     * }
     * ```
     */
    download(offset?: number, count?: number, options?: FileDownloadOptions): Promise<FileDownloadResponseModel>;
    /**
     * Returns true if the specified file exists; false otherwise.
     *
     * NOTE: use this function with care since an existing file might be deleted by other clients or
     * applications. Vice versa new files might be added by other clients or applications after this
     * function completes.
     *
     * @param {FileExistsOptions} [options] options to Exists operation.
     * @returns {Promise<boolean>}
     * @memberof ShareFileClient
     */
    exists(options?: FileExistsOptions): Promise<boolean>;
    /**
     * Returns all user-defined metadata, standard HTTP properties, and system properties
     * for the file. It does not return the content of the file.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-file-properties
     *
     * @param {FileGetPropertiesOptions} [options] Options to File Get Properties operation.
     * @returns {Promise<FileGetPropertiesResponse>} Response data for the File Get Properties operation.
     * @memberof ShareFileClient
     */
    getProperties(options?: FileGetPropertiesOptions): Promise<FileGetPropertiesResponse>;
    /**
     * Sets properties on the file.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-file-properties
     *
     * @param {FileProperties} [properties] File properties. For file HTTP headers(e.g. Content-Type),
     *                                       if no values are provided, existing HTTP headers will be removed.
     *                                       For other file properties(e.g. fileAttributes), if no values are provided,
     *                                       existing values will be preserved.
     * @returns {Promise<SetPropertiesResponse>}
     * @memberof ShareFileClient
     */
    setProperties(properties?: FileProperties): Promise<SetPropertiesResponse>;
    /**
     * Removes the file from the storage account.
     * When a file is successfully deleted, it is immediately removed from the storage
     * account's index and is no longer accessible to clients. The file's data is later
     * removed from the service during garbage collection.
     *
     * Delete File will fail with status code 409 (Conflict) and error code SharingViolation
     * if the file is open on an SMB client.
     *
     * Delete File is not supported on a share snapshot, which is a read-only copy of
     * a share. An attempt to perform this operation on a share snapshot will fail with 400 (InvalidQueryParameterValue)
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-file2
     *
     * @param {FileDeleteOptions} [options] Options to File Delete operation.
     * @returns {Promise<FileDeleteResponse>} Response data for the File Delete operation.
     * @memberof ShareFileClient
     */
    delete(options?: FileDeleteOptions): Promise<FileDeleteResponse>;
    /**
     * Removes the file from the storage account if it exists.
     * When a file is successfully deleted, it is immediately removed from the storage
     * account's index and is no longer accessible to clients. The file's data is later
     * removed from the service during garbage collection.
     *
     * Delete File will fail with status code 409 (Conflict) and error code SharingViolation
     * if the file is open on an SMB client.
     *
     * Delete File is not supported on a share snapshot, which is a read-only copy of
     * a share. An attempt to perform this operation on a share snapshot will fail with 400 (InvalidQueryParameterValue)
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-file2
     *
     * @param {FileDeleteOptions} [options]
     * @returns {Promise<FileDeleteIfExistsResponse>}
     * @memberof ShareFileClient
     */
    deleteIfExists(options?: FileDeleteOptions): Promise<FileDeleteIfExistsResponse>;
    /**
     * Sets HTTP headers on the file.
     *
     * If no option provided, or no value provided for the file HTTP headers in the options,
     * these file HTTP headers without a value will be cleared.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-file-properties
     *
     * @param {fileHttpHeaders} [FileHttpHeaders] File HTTP headers like Content-Type.
     *                                             Provide undefined will remove existing HTTP headers.
     * @param {FileSetHttpHeadersOptions} [options] Options to File Set HTTP Headers operation.
     * @returns {Promise<FileSetHTTPHeadersResponse>} Response data for the File Set HTTP Headers operation.
     * @memberof ShareFileClient
     */
    setHttpHeaders(fileHttpHeaders?: FileHttpHeaders, options?: FileSetHttpHeadersOptions): Promise<FileSetHTTPHeadersResponse>;
    /**
     * Resize file.
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-file-properties
     *
     * @param {number} length Resizes a file to the specified size in bytes.
     *                        If the specified byte value is less than the current size of the file,
     *                        then all ranges above the specified byte value are cleared.
     * @param {FileResizeOptions} [options] Options to File Resize operation.
     * @returns {Promise<FileSetHTTPHeadersResponse>} Response data for the File Set HTTP Headers operation.
     * @memberof ShareFileClient
     */
    resize(length: number, options?: FileResizeOptions): Promise<FileSetHTTPHeadersResponse>;
    /**
     * Updates user-defined metadata for the specified file.
     *
     * If no metadata defined in the option parameter, the file
     * metadata will be removed.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-file-metadata
     *
     * @param {Metadata} [metadata] If no metadata provided, all existing directory metadata will be removed
     * @param {FileSetMetadataOptions} [options] Options to File Set Metadata operation.
     * @returns {Promise<FileSetMetadataResponse>} Response data for the File Set Metadata operation.
     * @memberof ShareFileClient
     */
    setMetadata(metadata?: Metadata, options?: FileSetMetadataOptions): Promise<FileSetMetadataResponse>;
    /**
     * Upload a range of bytes to a file. Both the start and count of the
     * range must be specified. The range can be up to 4 MB in size.
     *
     * @param {HttpRequestBody} body Blob, string, ArrayBuffer, ArrayBufferView or a function
     *                               which returns a new Readable stream whose offset is from data source beginning.
     * @param {number} offset Offset position of the destination Azure File to upload.
     * @param {number} contentLength Length of body in bytes. Use Buffer.byteLength() to calculate body length for a
     *                               string including non non-Base64/Hex-encoded characters.
     * @param {FileUploadRangeOptions} [options={}] Options to File Upload Range operation.
     * @returns {Promise<FileUploadRangeResponse>} Response data for the File Upload Range operation.
     * @memberof ShareFileClient
     *
     * Example usage:
     *
     * ```js
     * const content = "Hello world!";
     *
     * // Create the file
     * await fileClient.create(content.length);
     * console.log("Created file successfully!");
     *
     * // Then upload data to the file
     * await fileClient.uploadRange(content, 0, content.length);
     * console.log("Updated file successfully!")
     * ```
     */
    uploadRange(body: HttpRequestBody, offset: number, contentLength: number, options?: FileUploadRangeOptions): Promise<FileUploadRangeResponse>;
    /**
     * Upload a range of bytes to a file where the contents are read from a another file's URL.
     * The range can be up to 4 MB in size.
     *
     * @param {string} sourceURL Specify a URL to the copy source, Shared Access Signature(SAS) maybe needed for authentication.
     * @param {number} sourceOffset The source offset to copy from. Pass 0 to copy from the beginning of source file.
     * @param {number} destOffset Offset of destination file.
     * @param {number} count Number of bytes to be uploaded from source file.
     * @param {FileUploadRangeFromURLOptions} [options={}] Options to configure File - Upload Range from URL operation.
     * @returns {Promise<FileUploadRangeFromURLResponse>}
     * @memberof FileURL
     */
    uploadRangeFromURL(sourceURL: string, sourceOffset: number, destOffset: number, count: number, options?: FileUploadRangeFromURLOptions): Promise<FileUploadRangeFromURLResponse>;
    /**
     * Clears the specified range and
     * releases the space used in storage for that range.
     *
     * @param {number} offset
     * @param {number} contentLength
     * @param {FileClearRangeOptions} [options] Options to File Clear Range operation.
     * @returns {Promise<FileUploadRangeResponse>}
     * @memberof ShareFileClient
     */
    clearRange(offset: number, contentLength: number, options?: FileClearRangeOptions): Promise<FileUploadRangeResponse>;
    /**
     * Returns the list of valid ranges for a file.
     *
     * @param {FileGetRangeListOptions} [options] Options to File Get range List operation.
     * @returns {Promise<FileGetRangeListResponse>}
     * @memberof ShareFileClient
     */
    getRangeList(options?: FileGetRangeListOptions): Promise<FileGetRangeListResponse>;
    /**
     * Copies a blob or file to a destination file within the storage account.
     *
     * @param {string} copySource Specifies the URL of the source file or blob, up to 2 KB in length.
     * To copy a file to another file within the same storage account, you may use Shared Key to
     * authenticate the source file. If you are copying a file from another storage account, or if you
     * are copying a blob from the same storage account or another storage account, then you must
     * authenticate the source file or blob using a shared access signature. If the source is a public
     * blob, no authentication is required to perform the copy operation. A file in a share snapshot
     * can also be specified as a copy source.
     * @param {FileStartCopyOptions} [options] Options to File Start Copy operation.
     * @returns {Promise<FileStartCopyResponse>}
     * @memberof ShareFileClient
     */
    startCopyFromURL(copySource: string, options?: FileStartCopyOptions): Promise<FileStartCopyResponse>;
    /**
     * Aborts a pending Copy File operation, and leaves a destination file with zero length and full
     * metadata.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/abort-copy-file
     *
     * @param {string} copyId Id of the Copy File operation to abort.
     * @param {FileAbortCopyFromURLOptions} [options] Options to File Abort Copy From URL operation.
     * @returns {Promise<FileAbortCopyResponse>}
     * @memberof ShareFileClient
     */
    abortCopyFromURL(copyId: string, options?: FileAbortCopyFromURLOptions): Promise<FileAbortCopyResponse>;
    /**
     * Uploads a Buffer(Node)/Blob/ArrayBuffer/ArrayBufferView to an Azure File.
     *
     * @param {Buffer | Blob | ArrayBuffer | ArrayBufferView} data Buffer(Node), Blob, ArrayBuffer or ArrayBufferView
     * @param {FileParallelUploadOptions} [options]
     * @returns {Promise<void>}
     */
    uploadData(data: Buffer | Blob | ArrayBuffer | ArrayBufferView, options?: FileParallelUploadOptions): Promise<void>;
    /**
     * ONLY AVAILABLE IN BROWSERS.
     *
     * Uploads a browser Blob object to an Azure file. Requires a blobFactory as the data source,
     * which need to return a Blob object with the offset and size provided.
     *
     * @param {(offset: number, size: number) => Blob} blobFactory
     * @param {number} size
     * @param {FileParallelUploadOptions} [options]
     * @returns {Promise<void>}
     */
    uploadSeekableBlob(blobFactory: (offset: number, size: number) => Blob, size: number, options?: FileParallelUploadOptions): Promise<void>;
    /**
     * ONLY AVAILABLE IN NODE.JS RUNTIME.
     *
     * Uploads a local file to an Azure file.
     *
     * @param {string} filePath Full path of local file
     * @param {ShareFileClient} fileClient ShareFileClient
     * @param {FileParallelUploadOptions} [options]
     * @returns {(Promise<void>)}
     */
    uploadFile(filePath: string, options?: FileParallelUploadOptions): Promise<void>;
    /**
     * ONLY AVAILABLE IN NODE.JS RUNTIME.
     *
     * Accepts a Node.js Readable stream factory, and uploads in blocks to an Azure File.
     * The Readable stream factory must returns a Node.js Readable stream starting from the offset defined. The offset
     * is the offset in the Azure file to be uploaded.
     *
     * @export
     * @param {(offset: number) => NodeJS.ReadableStream} streamFactory Returns a Node.js Readable stream starting
     *                                                                  from the offset defined
     * @param {number} size Size of the Azure file
     * @param {ShareFileClient} fileClient ShareFileClient
     * @param {FileParallelUploadOptions} [options]
     * @returns {(Promise<void>)}
     */
    uploadResetableStream(streamFactory: (offset: number, count?: number) => NodeJS.ReadableStream, size: number, options?: FileParallelUploadOptions): Promise<void>;
    /**
     * ONLY AVAILABLE IN NODE.JS RUNTIME.
     *
     * @export
     * @param {(offset: number, count: number) => Buffer} bufferChunk Returns a Node.js Buffer chunk starting
     *                                                                  from the offset defined till the count
     * @param {number} size Size of the Azure file
     * @param {ShareFileClient} fileClient ShareFileClient
     * @param {FileParallelUploadOptions} [options]
     * @returns {(Promise<void>)}
     */
    private uploadBuffer;
    /**
     * ONLY AVAILABLE IN NODE.JS RUNTIME.
     *
     * Downloads an Azure file in parallel to a buffer.
     * Offset and count are optional, pass 0 for both to download the entire file.
     *
     * Warning: Buffers can only support files up to about one gigabyte on 32-bit systems or about two
     * gigabytes on 64-bit systems due to limitations of Node.js/V8. For files larger than this size,
     * consider {@link downloadToFile}.
     *
     * @param {Buffer} buffer Buffer to be fill, must have length larger than count
     * @param {number} offset From which position of the Azure File to download
     * @param {number} [count] How much data to be downloaded. Will download to the end when passing undefined
     * @param {FileDownloadToBufferOptions} [options]
     * @returns {Promise<Buffer>}
     */
    downloadToBuffer(buffer: Buffer, offset?: number, count?: number, options?: FileDownloadToBufferOptions): Promise<Buffer>;
    /**
     * ONLY AVAILABLE IN NODE.JS RUNTIME
     *
     * Downloads an Azure file in parallel to a buffer.
     * Offset and count are optional, pass 0 for both to download the entire file
     *
     * Warning: Buffers can only support files up to about one gigabyte on 32-bit systems or about two
     * gigabytes on 64-bit systems due to limitations of Node.js/V8. For files larger than this size,
     * consider {@link downloadToFile}.
     *
     * @param {number} offset From which position of the Azure file to download
     * @param {number} [count] How much data to be downloaded. Will download to the end when passing undefined
     * @param {FileDownloadToBufferOptions} [options]
     * @returns {Promise<Buffer>}
     */
    downloadToBuffer(offset?: number, count?: number, options?: FileDownloadToBufferOptions): Promise<Buffer>;
    /**
     * ONLY AVAILABLE IN NODE.JS RUNTIME.
     *
     * Uploads a Node.js Readable stream into an Azure file.
     * This method will try to create an Azure, then starts uploading chunk by chunk.
     * Size of chunk is defined by `bufferSize` parameter.
     * Please make sure potential size of stream doesn't exceed file size.
     *
     * PERFORMANCE IMPROVEMENT TIPS:
     * * Input stream highWaterMark is better to set a same value with bufferSize
     *   parameter, which will avoid Buffer.concat() operations.
     *
     * @param {Readable} stream Node.js Readable stream. Must be less or equal than file size.
     * @param {number} size Size of file to be created. Maximum size allowed is 1TB.
     *                      If this value is larger than stream size, there will be empty bytes in file tail.
     * @param {number} bufferSize Size of every buffer allocated in bytes, also the chunk/range size during
     *                            the uploaded file. Size must be > 0 and <= 4 * 1024 * 1024 (4MB)
     * @param {number} maxBuffers Max buffers will allocate during uploading, positive correlation
     *                            with max uploading concurrency
     * @param {FileUploadStreamOptions} [options]
     * @returns {Promise<void>}
     */
    uploadStream(stream: Readable, size: number, bufferSize: number, maxBuffers: number, options?: FileUploadStreamOptions): Promise<void>;
    /**
     * ONLY AVAILABLE IN NODE.JS RUNTIME.
     *
     * Downloads an Azure Blob to a local file.
     * Fails if the the given file path already exits.
     * Offset and count are optional, pass 0 and undefined respectively to download the entire blob.
     *
     * @param {string} filePath
     * @param {number} [offset] From which position of the block blob to download.
     * @param {number} [count] How much data to be downloaded. Will download to the end when passing undefined.
     * @param {BlobDownloadOptions} [options] Options to Blob download options.
     * @returns {Promise<FileDownloadResponse>} The response data for blob download operation,
     *                                                 but with readableStreamBody set to undefined since its
     *                                                 content is already read and written into a local file
     *                                                 at the specified path.
     * @memberof BlobClient
     */
    downloadToFile(filePath: string, offset?: number, count?: number, options?: FileDownloadOptions): Promise<FileDownloadResponseModel>;
    /**
     * Lists handles for a file.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/list-handles
     *
     * @param {string} [marker] Optional. A string value that identifies the portion of the list to be
     *                          returned with the next list handles operation. The operation returns a
     *                          marker value within the response body if the list returned was not complete.
     *                          The marker value may then be used in a subsequent call to request the next
     *                          set of list items.
     * @param {FileListHandlesSegmentOptions} [options={}]
     * @returns {Promise<FileListHandlesResponse>}
     * @memberof FileURL
     */
    private listHandlesSegment;
    /**
     * Returns an AsyncIterableIterator for FileListHandlesResponse
     *
     * @private
     * @param {string} [marker] A string value that identifies the portion of the list to be
     *                          returned with the next list handles operation. The operation returns a
     *                          marker value within the response body if the list returned was not complete.
     *                          The marker value may then be used in a subsequent call to request the next
     *                          set of list items.
     * @param {FileListHandlesSegmentOptions} [options] Options to list handles operation.
     * @returns {AsyncIterableIterator<FileListHandlesResponse>}
     * @memberof ShareFileClient
     */
    private iterateHandleSegments;
    /**
     * Returns an AsyncIterableIterator for handles
     *
     * @private
     * @param {FileListHandlesSegmentOptions} [options] Options to list handles operation.
     * @returns {AsyncIterableIterator<HandleItem>}
     * @memberof ShareFileClient
     */
    private listHandleItems;
    /**
     * Returns an async iterable iterator to list all the handles.
     * under the specified account.
     *
     * .byPage() returns an async iterable iterator to list the handles in pages.
     *
     * @param {FileListHandlesOptions} [options] Options to list handles operation.
     * @memberof ShareFileClient
     * @returns {PagedAsyncIterableIterator<HandleItem, FileListHandlesResponse>}
     * An asyncIterableIterator that supports paging.
     */
    listHandles(options?: FileListHandlesOptions): PagedAsyncIterableIterator<HandleItem, FileListHandlesResponse>;
    /**
     * Force close all handles for a file.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/force-close-handles
     *
     * @param {string} [marker] Optional. A string value that identifies the position of handles that will
     *                          be closed with the next force close handles operation.
     *                          The operation returns a marker value within the response
     *                          body if there are more handles to close. The marker value
     *                          may then be used in a subsequent call to close the next set of handles.
     * @param {FileForceCloseHandlesOptions} [options] Options to force close handles operation.
     * @returns {Promise<FileForceCloseHandlesResponse>}
     * @memberof ShareFileClient
     */
    private forceCloseHandlesSegment;
    /**
     * Force close all handles for a file.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/force-close-handles
     *
     * @param {FileForceCloseHandlesOptions} [options] Options to force close handles operation.
     * @returns {Promise<CloseHandlesInfo>}
     * @memberof ShareFileClient
     */
    forceCloseAllHandles(options?: FileForceCloseHandlesOptions): Promise<CloseHandlesInfo>;
    /**
     * Force close a specific handle for a file.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/force-close-handles
     *
     * @param {string} handleId Specific handle ID, cannot be asterisk "*".
     *                          Use forceCloseAllHandles() to close all handles.
     * @param FileForceCloseHandlesOptions} [options] Options to force close handles operation.
     * @returns {Promise<FileForceCloseHandlesResponse>}
     * @memberof ShareFileClient
     */
    forceCloseHandle(handleId: string, options?: FileForceCloseHandlesOptions): Promise<FileForceCloseHandlesResponse>;
    /**
     * Get a {@link ShareLeaseClient} that manages leases on the file.
     *
     * @param {string} [proposeLeaseId] Initial proposed lease Id.
     * @returns {ShareLeaseClient} A new ShareLeaseClient object for managing leases on the file.
     * @memberof ShareFileClient
     */
    getShareLeaseClient(proposeLeaseId?: string): ShareLeaseClient;
}
/**
 * Defines headers for GetAccessPolicy operation.
 */
export declare interface ShareGetAccessPolicyHeaders {
    /**
     * The ETag contains a value that you can use to perform operations conditionally, in quotes.
     */
    etag?: string;
    /**
     * Returns the date and time the share was last modified. Any operation that modifies the share
     * or its properties updates the last modified time. Operations on files do not affect the last
     * modified time of the share.
     */
    lastModified?: Date;
    /**
     * This header uniquely identifies the request that was made and can be used for troubleshooting
     * the request.
     */
    requestId?: string;
    /**
     * Indicates the version of the File service used to execute the request.
     */
    version?: string;
    /**
     * A UTC date/time value generated by the service that indicates the time at which the response
     * was initiated.
     */
    date?: Date;
    errorCode?: string;
}
/**
 * Options to configure the {@link ShareClient.getAccessPolicy} operation.
 *
 * @export
 * @interface ShareGetAccessPolicyOptions
 */
export declare interface ShareGetAccessPolicyOptions extends CommonOptions {
    /**
     * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.
     * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.
     *
     * @type {AbortSignalLike}
     * @memberof ShareGetAccessPolicyOptions
     */
    abortSignal?: AbortSignalLike;
}
export declare type ShareGetAccessPolicyResponse = {
    signedIdentifiers: SignedIdentifier[];
} & ShareGetAccessPolicyHeaders & {
    /**
     * The underlying HTTP response.
     */
    _response: HttpResponse & {
        /**
         * The parsed HTTP response headers.
         */
        parsedHeaders: ShareGetAccessPolicyHeaders;
        /**
         * The response body as text (string format)
         */
        bodyAsText: string;
        /**
         * The response body as parsed JSON or XML
         */
        parsedBody: SignedIdentifierModel[];
    };
};
/**
 * Defines headers for GetPermission operation.
 */
export declare interface ShareGetPermissionHeaders {
    /**
     * This header uniquely identifies the request that was made and can be used for troubleshooting
     * the request.
     */
    requestId?: string;
    /**
     * Indicates the version of the File service used to execute the request.
     */
    version?: string;
    /**
     * A UTC date/time value generated by the service that indicates the time at which the response
     * was initiated.
     */
    date?: Date;
    errorCode?: string;
}
/**
 * Options to configure the {@link ShareClient.getPermission} operation.
 *
 * @export
 * @interface ShareGetPermissionOptions
 */
export declare interface ShareGetPermissionOptions extends CommonOptions {
    /**
     * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.
     * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.
     *
     * @type {AbortSignalLike}
     * @memberof ShareGetPermissionOptions
     */
    abortSignal?: AbortSignalLike;
}
/**
 * Contains response data for the getPermission operation.
 */
export declare type ShareGetPermissionResponse = SharePermission & ShareGetPermissionHeaders & {
    /**
     * The underlying HTTP response.
     */
    _response: coreHttp.HttpResponse & {
        /**
         * The parsed HTTP response headers.
         */
        parsedHeaders: ShareGetPermissionHeaders;
        /**
         * The response body as text (string format)
         */
        bodyAsText: string;
        /**
         * The response body as parsed JSON or XML
         */
        parsedBody: SharePermission;
    };
};
/**
 * Defines headers for GetProperties operation.
 */
export declare interface ShareGetPropertiesHeaders {
    metadata?: {
        [propertyName: string]: string;
    };
    /**
     * The ETag contains a value that you can use to perform operations conditionally, in quotes.
     */
    etag?: string;
    /**
     * Returns the date and time the share was last modified. Any operation that modifies the share
     * or its properties updates the last modified time. Operations on files do not affect the last
     * modified time of the share.
     */
    lastModified?: Date;
    /**
     * This header uniquely identifies the request that was made and can be used for troubleshooting
     * the request.
     */
    requestId?: string;
    /**
     * Indicates the version of the File service used to execute the request.
     */
    version?: string;
    /**
     * A UTC date/time value generated by the service that indicates the time at which the response
     * was initiated.
     */
    date?: Date;
    /**
     * Returns the current share quota in GB.
     */
    quota?: number;
    /**
     * Returns the current share provisioned ipos.
     */
    provisionedIops?: number;
    /**
     * Returns the current share provisioned ingress in megabytes per second.
     */
    provisionedIngressMBps?: number;
    /**
     * Returns the current share provisioned egress in megabytes per second.
     */
    provisionedEgressMBps?: number;
    /**
     * Returns the current share next allowed quota downgrade time.
     */
    nextAllowedQuotaDowngradeTime?: Date;
    errorCode?: string;
}
/**
 * Options to configure the {@link ShareClient.getProperties} operation.
 *
 * @export
 * @interface ShareGetPropertiesOptions
 */
export declare interface ShareGetPropertiesOptions extends CommonOptions {
    /**
     * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.
     * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.
     *
     * @type {AbortSignalLike}
     * @memberof ShareGetPropertiesOptions
     */
    abortSignal?: AbortSignalLike;
}
/**
 * Contains response data for the getProperties operation.
 */
export declare type ShareGetPropertiesResponse = ShareGetPropertiesHeaders & {
    /**
     * The underlying HTTP response.
     */
    _response: coreHttp.HttpResponse & {
        /**
         * The parsed HTTP response headers.
         */
        parsedHeaders: ShareGetPropertiesHeaders;
    };
};
/**
 * Defines headers for GetStatistics operation.
 */
export declare interface ShareGetStatisticsHeaders {
    /**
     * The ETag contains a value that you can use to perform operations conditionally, in quotes.
     */
    etag?: string;
    /**
     * Returns the date and time the share was last modified. Any operation that modifies the share
     * or its properties updates the last modified time. Operations on files do not affect the last
     * modified time of the share.
     */
    lastModified?: Date;
    /**
     * This header uniquely identifies the request that was made and can be used for troubleshooting
     * the request.
     */
    requestId?: string;
    /**
     * Indicates the version of the File service used to execute the request.
     */
    version?: string;
    /**
     * A UTC date/time value generated by the service that indicates the time at which the response
     * was initiated.
     */
    date?: Date;
    errorCode?: string;
}
/**
 * Options to configure the {@link ShareClient.getStatistics} operation.
 *
 * @export
 * @interface ShareGetStatisticsOptions
 */
export declare interface ShareGetStatisticsOptions extends CommonOptions {
    /**
     * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.
     * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.
     *
     * @type {AbortSignalLike}
     * @memberof ShareGetStatisticsOptions
     */
    abortSignal?: AbortSignalLike;
}
/**
 * Response data for the {@link ShareClient.getStatistics} Operation.
 *
 * @export
 * @interface ShareGetStatisticsResponse
 */
export declare type ShareGetStatisticsResponse = ShareGetStatisticsResponseModel & {
    /**
     * @deprecated shareUsage is going to be deprecated. Please use ShareUsageBytes instead.
     *
     * The approximate size of the data stored on the share, rounded up to the nearest gigabyte. Note
     * that this value may not include all recently created or recently resized files.
     *
     * @type {number}
     * @memberof ShareGetStatisticsResponse
     */
    shareUsage: number;
};
/**
 * Contains response data for the getStatistics operation.
 */
export declare type ShareGetStatisticsResponseModel = ShareStats & ShareGetStatisticsHeaders & {
    /**
     * The underlying HTTP response.
     */
    _response: coreHttp.HttpResponse & {
        /**
         * The parsed HTTP response headers.
         */
        parsedHeaders: ShareGetStatisticsHeaders;
        /**
         * The response body as text (string format)
         */
        bodyAsText: string;
        /**
         * The response body as parsed JSON or XML
         */
        parsedBody: ShareStats;
    };
};
/**
 * A listed Azure Storage share item.
 */
export declare interface ShareItem {
    name: string;
    snapshot?: string;
    deleted?: boolean;
    version?: string;
    properties: ShareProperties;
    metadata?: {
        [propertyName: string]: string;
    };
}
/**
 * A client that manages leases for a {@link ShareFileClient}.
 *
 * @export
 * @class ShareLeaseClient
 */
export declare class ShareLeaseClient {
    private _leaseId;
    private _url;
    private _file;
    readonly leaseId: string;
    readonly url: string;
    /**
     * Creates an instance of ShareLeaseClient.
     * @param {ShareFileClient} client The client to make the lease operation requests.
     * @param {string} leaseId Initial proposed lease id.
     * @memberof ShareLeaseClient
     */
    constructor(client: ShareFileClient, leaseId?: string);
    /**
     * The Lease File operation establishes and manages a lock on a file for write and delete operations.
     *
     * @param {number} duration Specifies the duration of lease. The only allowed value is -1, for a lease that never expires.
     * @param {LeaseOperationOptions} [options={}] Options for the lease management operation.
     * @returns {Promise<LeaseOperationResponse>} Response data for acquire lease operation.
     * @memberof ShareLeaseClient
     */
    acquireLease(duration?: number, options?: LeaseOperationOptions): Promise<LeaseOperationResponse>;
    /**
     * To change the ID of an existing lease.
     *
     * @param {string} proposedLeaseId the proposed new lease Id.
     * @param {LeaseOperationOptions} [options={}] Options for the lease management operation.
     * @returns {Promise<LeaseOperationResponse>} Response data for change lease operation.
     * @memberof ShareLeaseClient
     */
    changeLease(proposedLeaseId: string, options?: LeaseOperationOptions): Promise<LeaseOperationResponse>;
    /**
     * To free the lease if it is no longer needed so that another client may
     * immediately acquire a lease against the file.
     *
     * @param {LeaseOperationOptions} [options={}] Options for the lease management operation.
     * @returns {Promise<LeaseOperationResponse>} Response data for release lease operation.
     * @memberof ShareLeaseClient
     */
    releaseLease(options?: LeaseOperationOptions): Promise<LeaseOperationResponse>;
    /**
     * To force end the lease.
     *
     * @param {LeaseOperationOptions} [options={}] Options for the lease management operation.
     * @returns {Promise<LeaseOperationResponse>} Response data for break lease operation.
     * @memberof ShareLeaseClient
     */
    breakLease(options?: LeaseOperationOptions): Promise<LeaseOperationResponse>;
}
/**
 * A permission (a security descriptor) at the share level.
 */
export declare interface SharePermission {
    /**
     * The permission in the Security Descriptor Definition Language (SDDL).
     */
    permission: string;
}
/**
 * Properties of a share.
 */
export declare interface ShareProperties {
    lastModified: Date;
    etag: string;
    quota: number;
    provisionedIops?: number;
    provisionedIngressMBps?: number;
    provisionedEgressMBps?: number;
    nextAllowedQuotaDowngradeTime?: Date;
    deletedTime?: Date;
    remainingRetentionDays?: number;
}
/**
 * This is a helper class to construct a string representing the permissions granted by a ServiceSAS to a share.
 * Setting a value to true means that any SAS which uses these permissions will grant permissions for that operation.
 * Once all the values are set, this should be serialized with toString and set as the permissions field on a
 * {@link FileSASSignatureValues} object. It is possible to construct the permissions string without this class, but
 * the order of the permissions is particular and this class guarantees correctness.
 *
 * @export
 * @class ShareSASPermissions
 */
export declare class ShareSASPermissions {
    /**
     * Creates an {@link ShareSASPermissions} from the specified permissions string. This method will throw an
     * Error if it encounters a character that does not correspond to a valid permission.
     *
     * @static
     * @param {string} permissions
     * @returns
     * @memberof ShareSASPermissions
     */
    static parse(permissions: string): ShareSASPermissions;
    /**
     * Specifies Read access granted.
     *
     * @type {boolean}
     * @memberof ShareSASPermissions
     */
    read: boolean;
    /**
     * Specifies Create access granted.
     *
     * @type {boolean}
     * @memberof ShareSASPermissions
     */
    create: boolean;
    /**
     * Specifies Write access granted.
     *
     * @type {boolean}
     * @memberof ShareSASPermissions
     */
    write: boolean;
    /**
     * Specifies Delete access granted.
     *
     * @type {boolean}
     * @memberof ShareSASPermissions
     */
    delete: boolean;
    /**
     * Specifies List access granted.
     *
     * @type {boolean}
     * @memberof ShareSASPermissions
     */
    list: boolean;
    /**
     * Converts the given permissions to a string. Using this method will guarantee the permissions are in an
     * order accepted by the service.
     *
     * The order of the characters should be as specified here to ensure correctness.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/constructing-a-service-sas
     *
     * @returns {string}
     * @memberof ShareSASPermissions
     */
    toString(): string;
}
/**
 * A ShareServiceClient represents a URL to the Azure Storage File service allowing you
 * to manipulate file shares.
 *
 * @export
 * @class ShareServiceClient
 */
export declare class ShareServiceClient extends StorageClient {
    /**
     * serviceContext provided by protocol layer.
     *
     * @private
     * @type {Service}
     * @memberof ShareServiceClient
     */
    private serviceContext;
    /**
     *
     * Creates an instance of ShareServiceClient from connection string.
     *
     * @param {string} connectionString Account connection string or a SAS connection string of an Azure storage account.
     *                                  [ Note - Account connection string can only be used in NODE.JS runtime. ]
     *                                  Account connection string example -
     *                                  `DefaultEndpointsProtocol=https;AccountName=myaccount;AccountKey=accountKey;EndpointSuffix=core.windows.net`
     *                                  SAS connection string example -
     *                                  `BlobEndpoint=https://myaccount.blob.core.windows.net/;QueueEndpoint=https://myaccount.queue.core.windows.net/;FileEndpoint=https://myaccount.file.core.windows.net/;TableEndpoint=https://myaccount.table.core.windows.net/;SharedAccessSignature=sasString`
     * @param {StoragePipelineOptions} [options] Options to configure the HTTP pipeline.
     * @returns {ShareServiceClient} A new ShareServiceClient from the given connection string.
     * @memberof ShareServiceClient
     */
    static fromConnectionString(connectionString: string, options?: StoragePipelineOptions): ShareServiceClient;
    /**
     * Creates an instance of ShareServiceClient.
     *
     * @param {string} url A URL string pointing to Azure Storage file service, such as
     *                     "https://myaccount.file.core.windows.net". You can Append a SAS
     *                     if using AnonymousCredential, such as "https://myaccount.file.core.windows.net?sasString".
     * @param {Credential} [credential] Such as AnonymousCredential or StorageSharedKeyCredential.
     *                                  If not specified, AnonymousCredential is used.
     * @param {StoragePipelineOptions} [options] Optional. Options to configure the HTTP pipeline.
     * @memberof ShareServiceClient
     */
    constructor(url: string, credential?: Credential, options?: StoragePipelineOptions);
    /**
     * Creates an instance of ShareServiceClient.
     *
     * @param {string} url A URL string pointing to Azure Storage file service, such as
     *                     "https://myaccount.file.core.windows.net". You can Append a SAS
     *                     if using AnonymousCredential, such as "https://myaccount.file.core.windows.net?sasString".
     * @param {Pipeline} pipeline Call newPipeline() to create a default
     *                            pipeline, or provide a customized pipeline.
     * @memberof ShareServiceClient
     */
    constructor(url: string, pipeline: Pipeline);
    /**
     * Creates a ShareClient object.
     *
     * @param shareName Name of a share.
     * @returns {ShareClient} The ShareClient object for the given share name.
     * @memberof ShareServiceClient
     *
     * Example usage:
     *
     * ```js
     * const shareClient = serviceClient.getShareClient("<share name>");
     * await shareClient.create();
     * console.log("Created share successfully!");
     * ```
     */
    getShareClient(shareName: string): ShareClient;
    /**
     * Creates a Share.
     *
     * @param {string} shareName
     * @param {ShareCreateOptions} [options]
     * @returns {Promise<{ shareCreateResponse: ShareCreateResponse, shareClient: ShareClient }>} Share creation response and the corresponding share client.
     * @memberof ShareServiceClient
     */
    createShare(shareName: string, options?: ShareCreateOptions): Promise<{
        shareCreateResponse: ShareCreateResponse;
        shareClient: ShareClient;
    }>;
    /**
     * Deletes a Share.
     *
     * @param {string} shareName
     * @param {ShareDeleteMethodOptions} [options]
     * @returns {Promise<ShareDeleteResponse>} Share deletion response and the corresponding share client.
     * @memberof ShareServiceClient
     */
    deleteShare(shareName: string, options?: ShareDeleteMethodOptions): Promise<ShareDeleteResponse>;
    /**
     * Gets the properties of a storage account’s file service, including properties
     * for Storage Analytics and CORS (Cross-Origin Resource Sharing) rules.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-file-service-properties}
     *
     * @param {ServiceGetPropertiesOptions} [options={}] Options to Get Properties operation.
     * @returns {Promise<ServiceGetPropertiesResponse>} Response data for the Get Properties operation.
     * @memberof ShareServiceClient
     */
    getProperties(options?: ServiceGetPropertiesOptions): Promise<ServiceGetPropertiesResponse>;
    /**
     * Sets properties for a storage account’s file service endpoint, including properties
     * for Storage Analytics, CORS (Cross-Origin Resource Sharing) rules and soft delete settings.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-file-service-properties}
     *
     * @param {FileServiceProperties} properties
     * @param {ServiceSetPropertiesOptions} [options={}] Options to Set Properties operation.
     * @returns {Promise<ServiceSetPropertiesResponse>} Response data for the Set Properties operation.
     * @memberof ShareServiceClient
     */
    setProperties(properties: FileServiceProperties, options?: ServiceSetPropertiesOptions): Promise<ServiceSetPropertiesResponse>;
    /**
     * Returns an AsyncIterableIterator for {@link ServiceListSharesSegmentResponse} objects
     *
     * @private
     * @param {string} [marker] A string value that identifies the portion of
     *                          the list of shares to be returned with the next listing operation. The
     *                          operation returns the ContinuationToken value within the response body if the
     *                          listing operation did not return all shares remaining to be listed
     *                          with the current page. The ContinuationToken value can be used as the value for
     *                          the marker parameter in a subsequent call to request the next page of list
     *                          items. The marker value is opaque to the client.
     * @param {ServiceListSharesSegmentOptions} [options] Options to list shares operation.
     * @returns {AsyncIterableIterator<ServiceListSharesSegmentResponse>}
     * @memberof ShareServiceClient
     */
    private listSegments;
    /**
     * Returns an AsyncIterableIterator for share items
     *
     * @private
     * @param {ServiceListSharesSegmentOptions} [options] Options to list shares operation.
     * @returns {AsyncIterableIterator<ServiceListSharesSegmentResponse>}
     * @memberof ShareServiceClient
     */
    private listItems;
    /**
     * Returns an async iterable iterator to list all the shares
     * under the specified account.
     *
     * .byPage() returns an async iterable iterator to list the shares in pages.
     *
     * Example using `for await` syntax:
     *
     * ```js
     * let i = 1;
     * for await (const share of serviceClient.listShares()) {
     *   console.log(`Share ${i++}: ${share.name}`);
     * }
     * ```
     *
     * Example using `iter.next()`:
     *
     * ```js
     * let i = 1;
     * let iter = serviceClient.listShares();
     * let shareItem = await iter.next();
     * while (!shareItem.done) {
     *   console.log(`Share ${i++}: ${shareItem.value.name}`);
     *   shareItem = await iter.next();
     * }
     * ```
     *
     * Example using `byPage()`:
     *
     * ```js
     * // passing optional maxPageSize in the page settings
     * let i = 1;
     * for await (const response of serviceClient.listShares().byPage({ maxPageSize: 20 })) {
     *   if (response.shareItems) {
     *    for (const share of response.shareItems) {
     *        console.log(`Share ${i++}: ${share.name}`);
     *     }
     *   }
     * }
     * ```
     *
     * Example using paging with a marker:
     *
     * ```js
     * let i = 1;
     * let iterator = serviceClient.listShares().byPage({ maxPageSize: 2 });
     * let response = (await iterator.next()).value;
     *
     * // Prints 2 share names
     * if (response.shareItems) {
     *   for (const share of response.shareItems) {
     *     console.log(`Share ${i++}: ${share.name}`);
     *   }
     * }
     *
     * // Gets next marker
     * let marker = response.continuationToken;
     *
     * // Passing next marker as continuationToken
     * iterator = serviceClient.listShares().byPage({ continuationToken: marker, maxPageSize: 10 });
     * response = (await iterator.next()).value;
     *
     * // Prints 10 share names
     * if (response.shareItems) {
     *   for (const share of response.shareItems) {
     *     console.log(`Share ${i++}: ${share.name}`);
     *   }
     * }
     * ```
     *
     * @param {ServiceListSharesOptions} [options] Options to list shares operation.
     * @memberof ShareServiceClient
     * @returns {PagedAsyncIterableIterator<ShareItem, ServiceListSharesSegmentResponse>}
     * An asyncIterableIterator that supports paging.
     */
    listShares(options?: ServiceListSharesOptions): PagedAsyncIterableIterator<ShareItem, ServiceListSharesSegmentResponse>;
    /**
     * Gets the properties of a storage account's File service, including properties for Storage
     * Analytics metrics and CORS (Cross-Origin Resource Sharing) rules.
     *
     * @param {string} [marker] A string value that identifies the portion of
     *                          the list to be returned with the next list operation. The operation
     *                          returns a marker value within the response body if the list returned was
     *                          not complete. The marker value may then be used in a subsequent call to
     *                          request the next set of list items. The marker value is opaque to the
     *                          client.
     * @param {ServiceListSharesSegmentOptions} [options={}] Options to List Shares Segment operation.
     * @returns {Promise<ServiceListSharesSegmentResponse>} Response data for the List Shares Segment operation.
     * @memberof ShareServiceClient
     */
    private listSharesSegment;
    /**
     * Restores a previously deleted share.
     * This API is only functional if Share Soft Delete is enabled
     * for the storage account associated with the share.
     *
     * @param deletedShareName The name of the previously deleted share.
     * @param deletedShareVersion The version of the previously deleted share.
     * @param {ShareUndeleteOptions} [options] Options to Share undelete operation.
     * @returns {Promise<ShareClient>} Restored share.
     * @memberof ShareServiceClient
     */
    undeleteShare(deletedShareName: string, deletedShareVersion: string, options?: ServiceUndeleteShareOptions): Promise<ShareClient>;
}
/**
 * Defines headers for SetAccessPolicy operation.
 */
export declare interface ShareSetAccessPolicyHeaders {
    /**
     * The ETag contains a value that you can use to perform operations conditionally, in quotes.
     */
    etag?: string;
    /**
     * Returns the date and time the share was last modified. Any operation that modifies the share
     * or its properties updates the last modified time. Operations on files do not affect the last
     * modified time of the share.
     */
    lastModified?: Date;
    /**
     * This header uniquely identifies the request that was made and can be used for troubleshooting
     * the request.
     */
    requestId?: string;
    /**
     * Indicates the version of the File service used to execute the request.
     */
    version?: string;
    /**
     * A UTC date/time value generated by the service that indicates the time at which the response
     * was initiated.
     */
    date?: Date;
    errorCode?: string;
}
/**
 * Options to configure the {@link ShareClient.setAccessPolicy} operation.
 *
 * @export
 * @interface ShareSetAccessPolicyOptions
 */
export declare interface ShareSetAccessPolicyOptions extends CommonOptions {
    /**
     * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.
     * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.
     *
     * @type {AbortSignalLike}
     * @memberof ShareSetAccessPolicyOptions
     */
    abortSignal?: AbortSignalLike;
}
/**
 * Contains response data for the setAccessPolicy operation.
 */
export declare type ShareSetAccessPolicyResponse = ShareSetAccessPolicyHeaders & {
    /**
     * The underlying HTTP response.
     */
    _response: coreHttp.HttpResponse & {
        /**
         * The parsed HTTP response headers.
         */
        parsedHeaders: ShareSetAccessPolicyHeaders;
    };
};
/**
 * Defines headers for SetMetadata operation.
 */
export declare interface ShareSetMetadataHeaders {
    /**
     * The ETag contains a value that you can use to perform operations conditionally, in quotes.
     */
    etag?: string;
    /**
     * Returns the date and time the share was last modified. Any operation that modifies the share
     * or its properties updates the last modified time. Operations on files do not affect the last
     * modified time of the share.
     */
    lastModified?: Date;
    /**
     * This header uniquely identifies the request that was made and can be used for troubleshooting
     * the request.
     */
    requestId?: string;
    /**
     * Indicates the version of the File service used to execute the request.
     */
    version?: string;
    /**
     * A UTC date/time value generated by the service that indicates the time at which the response
     * was initiated.
     */
    date?: Date;
    errorCode?: string;
}
/**
 * Options to configure the {@link ShareClient.setMetadata} operation.
 *
 * @export
 * @interface ShareSetMetadataOptions
 */
export declare interface ShareSetMetadataOptions extends CommonOptions {
    /**
     * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.
     * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.
     *
     * @type {AbortSignalLike}
     * @memberof ShareSetMetadataOptions
     */
    abortSignal?: AbortSignalLike;
}
/**
 * Contains response data for the setMetadata operation.
 */
export declare type ShareSetMetadataResponse = ShareSetMetadataHeaders & {
    /**
     * The underlying HTTP response.
     */
    _response: coreHttp.HttpResponse & {
        /**
         * The parsed HTTP response headers.
         */
        parsedHeaders: ShareSetMetadataHeaders;
    };
};
/**
 * Defines headers for SetQuota operation.
 */
export declare interface ShareSetQuotaHeaders {
    /**
     * The ETag contains a value that you can use to perform operations conditionally, in quotes.
     */
    etag?: string;
    /**
     * Returns the date and time the share was last modified. Any operation that modifies the share
     * or its properties updates the last modified time. Operations on files do not affect the last
     * modified time of the share.
     */
    lastModified?: Date;
    /**
     * This header uniquely identifies the request that was made and can be used for troubleshooting
     * the request.
     */
    requestId?: string;
    /**
     * Indicates the version of the File service used to execute the request.
     */
    version?: string;
    /**
     * A UTC date/time value generated by the service that indicates the time at which the response
     * was initiated.
     */
    date?: Date;
    errorCode?: string;
}
/**
 * Options to configure the {@link ShareClient.setQuota} operation.
 *
 * @export
 * @interface ShareSetQuotaOptions
 */
export declare interface ShareSetQuotaOptions extends CommonOptions {
    /**
     * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.
     * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.
     *
     * @type {AbortSignalLike}
     * @memberof ShareSetQuotaOptions
     */
    abortSignal?: AbortSignalLike;
}
/**
 * Contains response data for the setQuota operation.
 */
export declare type ShareSetQuotaResponse = ShareSetQuotaHeaders & {
    /**
     * The underlying HTTP response.
     */
    _response: coreHttp.HttpResponse & {
        /**
         * The parsed HTTP response headers.
         */
        parsedHeaders: ShareSetQuotaHeaders;
    };
};
/**
 * Stats for the share.
 */
export declare interface ShareStats {
    /**
     * The approximate size of the data stored in bytes. Note that this value may not include all
     * recently created or recently resized files.
     */
    shareUsageBytes: number;
}
/**
 * Signed Identifier
 *
 * @export
 * @interface SignedIdentifier
 */
export declare interface SignedIdentifier {
    /**
     * @member {string} id a unique id
     */
    id: string;
    /**
     * @member {AccessPolicy} accessPolicy
     */
    accessPolicy: {
        /**
         * @member {Date} startsOn the date-time the policy is active.
         */
        startsOn: Date;
        /**
         * @member {string} expiresOn the date-time the policy expires.
         */
        expiresOn: Date;
        /**
         * @member {string} permissions the permissions for the acl policy
         * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-share-acl
         */
        permissions: string;
    };
}
/**
 * Signed identifier.
 */
export declare interface SignedIdentifierModel {
    /**
     * A unique id.
     */
    id: string;
    /**
     * The access policy.
     */
    accessPolicy?: AccessPolicy;
}
/**
 * Additional parameters for uploadRangeFromURL operation.
 */
export declare interface SourceModifiedAccessConditions {
    /**
     * Specify the crc64 value to operate only on range with a matching crc64 checksum.
     */
    sourceIfMatchCrc64?: Uint8Array;
    /**
     * Specify the crc64 value to operate only on range without a matching crc64 checksum.
     */
    sourceIfNoneMatchCrc64?: Uint8Array;
}
/**
 * StorageBrowserPolicy will handle differences between Node.js and browser runtime, including:
 *
 * 1. Browsers cache GET/HEAD requests by adding conditional headers such as 'IF_MODIFIED_SINCE'.
 * StorageBrowserPolicy is a policy used to add a timestamp query to GET/HEAD request URL
 * thus avoid the browser cache.
 *
 * 2. Remove cookie header for security
 *
 * 3. Remove content-length header to avoid browsers warning
 *
 * @class StorageBrowserPolicy
 * @extends {BaseRequestPolicy}
 */
export declare class StorageBrowserPolicy extends BaseRequestPolicy {
    /**
     * Creates an instance of StorageBrowserPolicy.
     * @param {RequestPolicy} nextPolicy
     * @param {RequestPolicyOptions} options
     * @memberof StorageBrowserPolicy
     */
    constructor(nextPolicy: RequestPolicy, options: RequestPolicyOptions);
    /**
     * Sends out request.
     *
     * @param {WebResource} request
     * @returns {Promise<HttpOperationResponse>}
     * @memberof StorageBrowserPolicy
     */
    sendRequest(request: WebResource): Promise<HttpOperationResponse>;
}
/**
 * StorageBrowserPolicyFactory is a factory class helping generating BrowserPolicy objects.
 *
 * @export
 * @class StorageBrowserPolicyFactory
 * @implements {RequestPolicyFactory}
 */
export declare class StorageBrowserPolicyFactory implements RequestPolicyFactory {
    /**
     * Creates a StorageBrowserPolicyFactory object.
     *
     * @param {RequestPolicy} nextPolicy
     * @param {RequestPolicyOptions} options
     * @returns {StorageBrowserPolicy}
     * @memberof StorageBrowserPolicyFactory
     */
    create(nextPolicy: RequestPolicy, options: RequestPolicyOptions): StorageBrowserPolicy;
}
/**
 * A StorageClient represents a base client class for ServiceClient, ContainerClient and etc.
 *
 * @export
 * @class StorageClient
 */
declare abstract class StorageClient {
    /**
     * URL string value.
     *
     * @type {string}
     * @memberof StorageClient
     */
    readonly url: string;
    readonly accountName: string;
    /* Excluded from this release type: pipeline */
    /**
     * StorageClient is a reference to protocol layer operations entry, which is
     * generated by AutoRest generator.
     *
     * @protected
     * @type {StorageClientContext}
     * @memberof StorageClient
     */
    protected readonly storageClientContext: StorageClientContext;
    /**
     * Creates an instance of StorageClient.
     * @param {string} url
     * @param {Pipeline} pipeline
     * @memberof StorageClient
     */
    protected constructor(url: string, pipeline: Pipeline);
}
declare class StorageClientContext extends coreHttp.ServiceClient {
    version: string;
    fileRangeWriteFromUrl: string;
    url: string;
    /**
     * Initializes a new instance of the StorageClientContext class.
     * @param version Specifies the version of the operation to use for this request.
     * @param url The URL of the service account, share, directory or file that is the target of the
     * desired operation.
     * @param [options] The parameter options
     */
    constructor(version: string, url: string, options?: coreHttp.ServiceClientOptions);
}
/**
 * Option interface for {@link newPipeline} function.
 *
 * @export
 * @interface StoragePipelineOptions
 */
export declare interface StoragePipelineOptions {
    /**
     * Options to configure a proxy for outgoing requests.
     */
    proxyOptions?: ProxyOptions;
    /**
     * Options for adding user agent details to outgoing requests.
     *
     * @type {UserAgentOptions}
     * @memberof StoragePipelineOptions
     */
    userAgentOptions?: UserAgentOptions;
    /**
     * Configures the built-in retry policy behavior.
     *
     * @type {StorageRetryOptions}
     * @memberof StoragePipelineOptions
     */
    retryOptions?: StorageRetryOptions;
    /**
     * Keep alive configurations. Default keep-alive is enabled.
     *
     * @type {KeepAliveOptions}
     * @memberof StoragePipelineOptions
     */
    keepAliveOptions?: KeepAliveOptions;
    /**
     * Configures the HTTP client to send requests and receive responses.
     *
     * @type {IHttpClient}
     * @memberof StoragePipelineOptions
     */
    httpClient?: IHttpClient;
}
/**
 * Retry options interface.
 *
 * @export
 * @interface StorageRetryOptions
 */
export declare interface StorageRetryOptions {
    /**
     * Optional. StorageRetryPolicyType, default is exponential retry policy.
     *
     * @type {StorageRetryPolicyType}
     * @memberof StorageRetryOptions
     */
    readonly retryPolicyType?: StorageRetryPolicyType;
    /**
     * Optional. Max try number of attempts, default is 4.
     * A value of 1 means 1 try and no retries.
     * A value smaller than 1 means default retry number of attempts.
     *
     * @type {number}
     * @memberof StorageRetryOptions
     */
    readonly maxTries?: number;
    /**
     * Optional. Indicates the maximum time in ms allowed for any single try of an HTTP request.
     * A value of zero or undefined means that you accept our default timeout, 60s or 60 * 1000ms.
     *
     * NOTE: When transferring large amounts of data, the default TryTimeout will probably
     * not be sufficient. You should override this value based on the bandwidth available to
     * the host machine and proximity to the Storage service. A good starting point may be something
     * like (60 seconds per MB of anticipated-payload-size)
     *
     * @type {number}
     * @memberof StorageRetryOptions
     */
    readonly tryTimeoutInMs?: number;
    /**
     * Optional. Specifies the amount of delay to use before retrying an operation (default is 4s or 4 * 1000ms).
     * The delay increases (exponentially or linearly) with each retry up to a maximum specified by
     * maxRetryDelayInMs. If you specify 0, then you must also specify 0 for maxRetryDelayInMs.
     *
     * @type {number}
     * @memberof StorageRetryOptions
     */
    readonly retryDelayInMs?: number;
    /**
     * Optional. Specifies the maximum delay allowed before retrying an operation (default is 120s or 120 * 1000ms).
     * If you specify 0, then you must also specify 0 for retryDelayInMs.
     *
     * @type {number}
     * @memberof StorageRetryOptions
     */
    readonly maxRetryDelayInMs?: number;
}
/**
 * Retry policy with exponential retry and linear retry implemented.
 *
 * @class RetryPolicy
 * @extends {BaseRequestPolicy}
 */
export declare class StorageRetryPolicy extends BaseRequestPolicy {
    /**
     * RetryOptions.
     *
     * @private
     * @type {RetryOptions}
     * @memberof StorageRetryPolicy
     */
    private readonly retryOptions;
    /**
     * Creates an instance of RetryPolicy.
     *
     * @param {RequestPolicy} nextPolicy
     * @param {RequestPolicyOptions} options
     * @param {StorageRetryOptions} [retryOptions=DEFAULT_RETRY_OPTIONS]
     * @memberof StorageRetryPolicy
     */
    constructor(nextPolicy: RequestPolicy, options: RequestPolicyOptions, retryOptions?: StorageRetryOptions);
    /**
     * Sends request.
     *
     * @param {WebResource} request
     * @returns {Promise<HttpOperationResponse>}
     * @memberof StorageRetryPolicy
     */
    sendRequest(request: WebResource): Promise<HttpOperationResponse>;
    /**
     * Decide and perform next retry. Won't mutate request parameter.
     *
     * @protected
     * @param {WebResource} request
     * @param {HttpOperationResponse} response
     * @param {boolean} secondaryHas404  If attempt was against the secondary & it returned a StatusNotFound (404), then
     *                                   the resource was not found. This may be due to replication delay. So, in this
     *                                   case, we'll never try the secondary again for this operation.
     * @param {number} attempt           How many retries has been attempted to performed, starting from 1, which includes
     *                                   the attempt will be performed by this method call.
     * @returns {Promise<HttpOperationResponse>}
     * @memberof StorageRetryPolicy
     */
    protected attemptSendRequest(request: WebResource, secondaryHas404: boolean, attempt: number): Promise<HttpOperationResponse>;
    /**
     * Decide whether to retry according to last HTTP response and retry counters.
     *
     * @protected
     * @param {boolean} isPrimaryRetry
     * @param {number} attempt
     * @param {HttpOperationResponse} [response]
     * @param {RestError} [err]
     * @returns {boolean}
     * @memberof StorageRetryPolicy
     */
    protected shouldRetry(isPrimaryRetry: boolean, attempt: number, response?: HttpOperationResponse, err?: RestError): boolean;
    /**
     * Delay a calculated time between retries.
     *
     * @private
     * @param {boolean} isPrimaryRetry
     * @param {number} attempt
     * @param {AbortSignalLike} [abortSignal]
     * @returns
     * @memberof StorageRetryPolicy
     */
    private delay;
}
/**
 * StorageRetryPolicyFactory is a factory class helping generating StorageRetryPolicy objects.
 *
 * @export
 * @class StorageRetryPolicyFactory
 * @implements {RequestPolicyFactory}
 */
export declare class StorageRetryPolicyFactory implements RequestPolicyFactory {
    private retryOptions?;
    /**
     * Creates an instance of StorageRetryPolicyFactory.
     * @param {StorageRetryOptions} [retryOptions]
     * @memberof StorageRetryPolicyFactory
     */
    constructor(retryOptions?: StorageRetryOptions);
    /**
     * Creates a StorageRetryPolicy object.
     * @param {RequestPolicy} nextPolicy
     * @param {RequestPolicyOptions} options
     * @returns {StorageRetryPolicy}
     * @memberof StorageRetryPolicyFactory
     */
    create(nextPolicy: RequestPolicy, options: RequestPolicyOptions): StorageRetryPolicy;
}
/**
 * RetryPolicy types.
 *
 * @export
 * @enum {number}
 */
export declare enum StorageRetryPolicyType {
    /**
     * Exponential retry. Retry time delay grows exponentially.
     */
    EXPONENTIAL = 0,
    /**
     * Linear retry. Retry time delay grows linearly.
     */
    FIXED = 1
}
/**
 * ONLY AVAILABLE IN NODE.JS RUNTIME.
 *
 * StorageSharedKeyCredential for account key authorization of Azure Storage service.
 *
 * @export
 * @class StorageSharedKeyCredential
 * @extends {Credential}
 */
export declare class StorageSharedKeyCredential extends Credential {
    /**
     * Azure Storage account name; readonly.
     *
     * @type {string}
     * @memberof StorageSharedKeyCredential
     */
    readonly accountName: string;
    /**
     * Azure Storage account key; readonly.
     *
     * @type {Buffer}
     * @memberof StorageSharedKeyCredential
     */
    private readonly accountKey;
    /**
     * Creates an instance of StorageSharedKeyCredential.
     * @param {string} accountName
     * @param {string} accountKey
     * @memberof StorageSharedKeyCredential
     */
    constructor(accountName: string, accountKey: string);
    /**
     * Creates a {@link StorageSharedKeyCredentialPolicy} object.
     *
     * @param {RequestPolicy} nextPolicy
     * @param {RequestPolicyOptions} options
     * @returns {StorageSharedKeyCredentialPolicy}
     * @memberof StorageSharedKeyCredential
     */
    create(nextPolicy: RequestPolicy, options: RequestPolicyOptions): StorageSharedKeyCredentialPolicy;
    /**
     * Generates a hash signature for an HTTP request or for a SAS.
     *
     * @param {string} stringToSign
     * @returns {string}
     * @memberof StorageSharedKeyCredential
     */
    computeHMACSHA256(stringToSign: string): string;
}
/**
 * StorageSharedKeyCredentialPolicy is a policy used to sign HTTP request with a shared key.
 *
 * @export
 * @class StorageSharedKeyCredentialPolicy
 * @extends {CredentialPolicy}
 */
export declare class StorageSharedKeyCredentialPolicy extends CredentialPolicy {
    /**
     * Reference to {@link StorageSharedKeyCredential} which generates StorageSharedKeyCredentialPolicy
     *
     * @type {StorageSharedKeyCredential}
     * @memberof StorageSharedKeyCredentialPolicy
     */
    private readonly factory;
    /**
     * Creates an instance of StorageSharedKeyCredentialPolicy.
     * @param {RequestPolicy} nextPolicy
     * @param {RequestPolicyOptions} options
     * @param {StorageSharedKeyCredential} factory
     * @memberof StorageSharedKeyCredentialPolicy
     */
    constructor(nextPolicy: RequestPolicy, options: RequestPolicyOptions, factory: StorageSharedKeyCredential);
    /**
     * Signs request.
     *
     * @protected
     * @param {WebResource} request
     * @returns {WebResource}
     * @memberof StorageSharedKeyCredentialPolicy
     */
    protected signRequest(request: WebResource): WebResource;
    /**
     * Retrieve header value according to shared key sign rules.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/authenticate-with-shared-key
     *
     * @private
     * @param {WebResource} request
     * @param {string} headerName
     * @returns {string}
     * @memberof StorageSharedKeyCredentialPolicy
     */
    private getHeaderValueToSign;
    /**
     * To construct the CanonicalizedHeaders portion of the signature string, follow these steps:
     * 1. Retrieve all headers for the resource that begin with x-ms-, including the x-ms-date header.
     * 2. Convert each HTTP header name to lowercase.
     * 3. Sort the headers lexicographically by header name, in ascending order.
     *    Each header may appear only once in the string.
     * 4. Replace any linear whitespace in the header value with a single space.
     * 5. Trim any whitespace around the colon in the header.
     * 6. Finally, append a new-line character to each canonicalized header in the resulting list.
     *    Construct the CanonicalizedHeaders string by concatenating all headers in this list into a single string.
     *
     * @private
     * @param {WebResource} request
     * @returns {string}
     * @memberof StorageSharedKeyCredentialPolicy
     */
    private getCanonicalizedHeadersString;
    /**
     * Retrieves the webResource canonicalized resource string.
     *
     * @private
     * @param {WebResource} request
     * @returns {string}
     * @memberof StorageSharedKeyCredentialPolicy
     */
    private getCanonicalizedResourceString;
}
/**
 * Indicates setting as the time of the request.
 */
export declare type TimeNowType = "now";
/**
 * Indicates keep existing time value unchanged.
 */
export declare type TimePreserveType = "preserve";
export { WebResource };
export {};
